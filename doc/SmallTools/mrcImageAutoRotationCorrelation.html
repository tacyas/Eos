<HTML>
<HEAD>
<TITLE>mrcImageAutoRotationCorrelation</TITLE>
</HEAD>
<BODY>
<H1>mrcImageAutoRotationCorrelation</H1>
<H2>Usage</H2>
<PRE>
Usage: mrcImageAutoRotationCorrelation
Options:
    [-i[nput]            In                  (NULL      ).as(inFile              ) ] :Essential :Input: testImage [mrcImage]
    [-r[eference]        Ref                 (NULL      ).as(inFile              ) ] :Essential :Input: refImage [mrcImage]
    [-nRot1              nRot1               (1         ).as(Integer             ) ] :Optional  :Rotation number of Ref for Rot1: Def 1
    [-nRot2              nRot2               (1         ).as(Integer             ) ] :Optional  :Rotation number of Ref for Rot2: Def 1
    [-nRot3              nRot3               (1         ).as(Integer             ) ] :Optional  :Rotation number of Ref for Rot3: Def 1
    [-dRot1              dRot1               (1.0       ).as(Real                ) ] :Optional  :Delta Angle [Degree] of Ref for Rot1; Def.: 360/nRot1
    [-dRot2              dRot2               (1.0       ).as(Real                ) ] :Optional  :Delta Angle [Degree] of Ref for Rot2; Def.: 360/nRot2
    [-dRot3              dRot3               (1.0       ).as(Real                ) ] :Optional  :Delta Angle [Degree] of Ref for Rot3; Def.: 360/nRot3
    [-startRot1          startRot1           (0.0       ).as(Real                ) ] :Optional  :Start Angle [Degree] of Ref for Rot1; Def.: 0
    [-startRot2          startRot2           (0.0       ).as(Real                ) ] :Optional  :Start Angle [Degree] of Ref for Rot2; Def.: 0
    [-startRot3          startRot3           (0.0       ).as(Real                ) ] :Optional  :Start Angle [Degree] of Ref for Rot3; Def.: 0
    [-StackOrder         StackOrder          (0         ).as(Integer             ) ] :Optional  :Stack Order for Stacked 2D of references, refer to attention
    [-o[utput]           Out                 (NULL      ).as(outFile             ) ] :Optional  :Output: Parameter [mrcImage-format]
    [-O[utput]           OutASC              (stdout    ).as(outFile             ) ] :Optional  :Output: Parameter [ASCII] 
    [-cor[relation]      corFile             (NULL      ).as(outFile             ) ] :Optional  :Correation Map at Maximum (Linear) [mrcImage-format]
    [-cor[relation]2     corFile2            (NULL      ).as(outFile             ) ] :Optional  :Correation Map2 at Maximum (Set Mode Correlation)[mrcImage-format]
    [-cor[relation]All   corAllFile          (NULL      ).as(outFile             ) ] :Optional  :Correation Map with All Rotation [mrcImage-format]
    [-fit[tedToRef]      fitFile             (NULL      ).as(outFile             ) ] :Optional  :Output: rotatedImage at Maximum(Linear Correlation) [mrcImage]
    [-fit[tedToRef]2     fitFile2            (NULL      ).as(outFile             ) ] :Optional  :Output: rotatedImage at Maximum(Set Correlation mode) [mrcImage]
    [-RefineMode         RefineMode          (0         ).as(Integer             ) ] :Optional  :RefinementStep: Linear:0 or SetMode:1
    [-n[umber]           Rot                 (36        ).as(Real                ) ] :Optional  :Input: Rotation around the vertical axis against image plane: dRot = 360/n [degree]
    [-range              minAngle            (-5.0      ).as(Real                ) 
                         maxAngle            (5.0       ).as(Real                ) ] :Optional  :Input: SearchRange: Rotation around the vertical axis against image plane 
    [-refStep1           refStep1            (1         ).as(Integer             ) ] :Optional  :SearchStep for Ref: Each Image along Rot1
    [-refStep2           refStep2            (1         ).as(Integer             ) ] :Optional  :SearchStep for Ref: Each Image along Rot2
    [-refStep3           refStep3            (1         ).as(Integer             ) ] :Optional  :SearchStep for Ref: Each Image along Rot3
    [-nRot1Area          nRot1AreaMin        (-360      ).as(Real                ) 
                         nRot1AreaMax        (360       ).as(Real                ) 
                         nRot1AreaStep       (25        ).as(Real                ) ] :Optional  :number of Ref for Rot1
    [-nRot2Area          nRot2AreaMin        (-360      ).as(Real                ) 
                         nRot2AreaMax        (360       ).as(Real                ) 
                         nRot2AreaStep       (25        ).as(Real                ) ] :Optional  :number of Ref for Rot2
    [-nRot3Area          nRot3AreaMin        (-360      ).as(Real                ) 
                         nRot3AreaMax        (360       ).as(Real                ) 
                         nRot3AreaStep       (25        ).as(Real                ) ] :Optional  :number of Ref for Rot3
    [-MagRange           MagRangeMin         (1.0       ).as(Real                ) 
                         MagRangeMax         (1.0       ).as(Real                ) 
                         MagRangeStep        (0.1       ).as(Real                ) ] :Optional  :Magnification Range
    [-Iter[ation]        Iter                (1         ).as(Integer             ) ] :Optional  :Iteration for Rotation around the vertical axis against image plane
    [-Method             Method              (0         ).as(Integer             ) ] :Optional  :0: Correlation, 1: SSDA
    [-s[earchRegion]     sminx               (0         ).as(Real                ) 
                         sminy               (0         ).as(Real                ) 
                         smaxx               (0/*N.x-1*/).as(Real                ) 
                         smaxy               (0/*N.y-1*/).as(Real                ) ] :Optional  :SearchRegion [pixel]: used in lmrcImageAutoRotationCorrelation 
    [-Shift                                                                        ] :Optional  :Image Shift, when in > ref
    [-RepeatX            RepeatX             (27.3      ).as(Real                ) ] :Optional  :RepeatX[A]
    [-RepeatXDelta       RepeatXDelta        (5         ).as(Real                ) ] :Optional  :RepeatXDelta[A]
    [-RepeatY            RepeatY             (27.3      ).as(Real                ) ] :Optional  :RepeatY[A]
    [-RepeatYDelta       RepeatYDelta        (5         ).as(Real                ) ] :Optional  :RepeatYDelta[A]
    [-Xshift                                                                       ] :Optional  :X-Shift Only
    [-NoShift                                                                      ] :Optional  :No-Shift
    [-Log                Log                 (stdout    ).as(outFile             ) ] :Optional  :Output: LogFile
    [-pvm                pvm                 (1         ).as(Integer             ) ] :Optional  :Task Number
    [-pvmList            pvmList             (NULL      ).as(inFile              ) ] :Optional  :ConfigurationFile
    [-c[onfig]           configFile          (NULL      ).as(inFile              ) ] :Optional  :ConfigurationFile
    [-m[ode]             mode                (0         ).as(Integer             ) ] :Optional  :Mode
----- Mode -----
When, -Method 0(Default:Correlation)
0: Normal Correlation FxG*
1: Phase  Correlation FxG*/     |FxG*|
2: Phase  Correlation FxG*/sqrt(|FxG*|)
3: Normalized Normal Correlation FxG*/|F||G|)
16: (0,0) = 0 
Refinement Correlation Map
0: sqrt(Sum |Fi-Gi|^2                 / Sum |Gi|^2)
1:      Sum |Gi||phaseFi - phaseGi|   / Sum |Gi|  
2: sqrt(Sum |Gi||phaseFi - phaseGi|^2 / Sum |Gi|  )
      ----- Attention -----
      You must not set bit 16: bit 16 is set in this program as default.
When, -Method 1 (SSDA:Sequential Similarity Detection Algorithm)
When, -Method 2 (Rotational Cross-Correlation Function)
-m NotSupported

>>>>>>>> Attention 1 -----
You should set -n or -range. These parameters are used for reference image rotation

>>>>>>>> Attention 2 -----
You must set -nRot1/2/3.
-nRot[1|2|3]     Number of Reference Images: 
You should set -dRot1/2/3.
-dRot[1|2|3]     Delta Angle [degree] of Reference Images: 
You should set -startRot1/2/3.
-startRot[1|2|3] Start Angle [degree] of Reference Images: 

  e.g.) If mrc3Dto2D -Rot1 89 91 1 -Rot2 0 359 2 -Rot3 3 12 3, 
           -nRot1 3   -dRot1 1 -startRot1 89 
           -nRot2 180 -dRot2 2 -startRot2  0 
           -nRot3 4   -dRot1 3 -startRot1  3 

>>>>>>>> Attention 3 : the relation between dRot1 and nRotArea ----
-nRot[1|2|3]Area Min[degree] Max[degree] Step[degree]
If not -dRot[1|2|3], we cannot estimate nStep, which is the number of skip step using referencefiles .

>>>>>>>> Attention 4 : Stack order of ref-image -----
-StackOrder
    0: for pdb2mrc2d : default
    1: for mrc3Dto2D 
If not -dRot[1|2|3], we cannot estimate nStep, which is the number of skip step using referencefiles .

>>>>>>>> Attention 5 : Refinement Mode -----
-RefineMode 
    0: for LinearCorrelation;  default
    1: for SetModeCorrelation 

>>>>>>>> Attention 6 : Search Area -----
-refStep[1|2|3] 
     Skip image number: Just skip ref-images 
 or 
-nRot[1|2|3]Area 
     Set the search area. You finally can refine parameters by each ref-image following -RefineMode. 

</PRE>
</BODY>
</HTML>
