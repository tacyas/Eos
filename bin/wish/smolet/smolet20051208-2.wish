#!../I686LINUX/smolet
set FileList(list)  FileList2

set PlaneActor(current) 	0 
set PlaneActor(range) 	0
set angle               	1	
set PlaneActor(deltaZ)     1
set desktop(width) 600
set desktop(height) 600
set PlaneActor(width) 2048
set PlaneActor(height) 2048
set PlaneActor(size) 2048

set FileList(tif) FileList2

#
# Box File Read
#
proc readBoxFileList { } {
	global FileList
	global Box 
	global PlaneActor

	set i 1
	if [catch {open $FileList(list) r} file1] {
		puts stderr "Cannot open FileList : $file1 "
	} else {
		while {[gets $file1 line] >= 0} {
			regsub {([^\.]*)\.tif} $line {\1.box}  name
			puts "$line -> $name"

			if [ catch {open [ subst $name]  r } file2 ] {
				puts stderr "Cannot open FlieList : $file2 "
			} else {
				set j 1
				while {[gets $file2 line2 ] >= 0} {
					scan $line2 {%d %d %d %d %d} Box($i,$j,start,x) Box($i,$j,start,y) Box($i,$j,size,x) Box($i,$j,size,y) Box($i,$j,size,unc) 
					set Box($i,$j,start,x) [expr ($Box($i,$j,start,x)/(1.0*$PlaneActor(size)) - 0.5 ) ]
					set Box($i,$j,start,y) [expr ($Box($i,$j,start,y)/(1.0*$PlaneActor(size)) - 0.5 ) ]
					set Box($i,$j,size,x)  [expr ($Box($i,$j,size,x)/(1.0*$PlaneActor(size))  ) ]
					set Box($i,$j,size,y)  [expr ($Box($i,$j,size,y)/(1.0*$PlaneActor(size))  ) ]
					#puts "$Box($i,$j,start,x) $Box($i,$j,start,y)"
					set Box($i,num) $j
					incr j
				}
			}
			set Box(num) $i
			incr i
		}
	}		
}

#
# Box Actor Create
#
proc createBoxActor { } {
	global Box
	global PlaneActor

	for { set i 1 } { $i <= $Box(num) } { incr i } {
		puts "$i box number $Box($i,num)"
		for { set j 1 } { $j <= $Box($i,num) } { incr j } {
			#puts "$i,$j"
			vtkPoints tmpquadPoints$i.$j; set quadPoints($i,$j) tmpquadPoints$i.$j
			set Z [ expr $i*$PlaneActor(deltaZ) ]
			#puts $Z
			$quadPoints($i,$j) SetNumberOfPoints 4
			$quadPoints($i,$j) InsertPoint 0 0                  0                   $Z 
			$quadPoints($i,$j) InsertPoint 1 $Box($i,$j,size,x) 0                   $Z
			$quadPoints($i,$j) InsertPoint 2 $Box($i,$j,size,x) $Box($i,$j,size,y)  $Z
			$quadPoints($i,$j) InsertPoint 3 0                  $Box($i,$j,size,y)  $Z

			vtkPolyLine aPolyLine$i.$j
			[aPolyLine$i.$j GetPointIds ] SetNumberOfIds 4 			
			[aPolyLine$i.$j GetPointIds ] SetId 0 0 
			[aPolyLine$i.$j GetPointIds ] SetId 1 1 
			[aPolyLine$i.$j GetPointIds ] SetId 2 2
			[aPolyLine$i.$j GetPointIds ] SetId 3 3 
			
			vtkQuad tmpQuad$i.$j
			[tmpQuad$i.$j GetPointIds ] SetId 0 0 
			[tmpQuad$i.$j GetPointIds ] SetId 1 1 
			[tmpQuad$i.$j GetPointIds ] SetId 2 2
			[tmpQuad$i.$j GetPointIds ] SetId 3 3 

			vtkUnstructuredGrid tmpQuadGrid$i.$j
			tmpQuadGrid$i.$j Allocate 1 1
			tmpQuadGrid$i.$j InsertNextCell [tmpQuad$i.$j GetCellType] [ tmpQuad$i.$j GetPointIds ]
			#tmpQuadGrid$i.$j InsertNextCell [aPolyLine$i.$j GetCellType] [ aPolyLine$i.$j GetPointIds ]
			tmpQuadGrid$i.$j SetPoints tmpquadPoints$i.$j

			vtkDataSetMapper tmpQuadMapper$i.$j
			tmpQuadMapper$i.$j SetInput tmpQuadGrid$i.$j
			vtkActor tmpQuadActor$i.$j  ; set Box($i,$j,Actor) tmpQuadActor$i.$j
			$Box($i,$j,Actor) SetMapper tmpQuadMapper$i.$j
			$Box($i,$j,Actor) AddPosition $Box($i,$j,start,x) $Box($i,$j,start,y)  0
			$Box($i,$j,Actor) PickableOn
			[ $Box($i,$j,Actor) GetProperty ] SetDiffuseColor 0 1 1
			[ $Box($i,$j,Actor) GetProperty ] SetEdgeColor 0 1 1
			[ $Box($i,$j,Actor) GetProperty ] EdgeVisibilityOn
			[ $Box($i,$j,Actor) GetProperty ] SetOpacity 0.2

			vtkVectorText aLabel$i.$j
				aLabel$i.$j SetText "$j"
			vtkPolyDataMapper aLabelMapper$i.$j
				aLabelMapper$i.$j SetInput [ aLabel$i.$j GetOutput ]
			vtkFollower aLabelActor$i.$j 
				aLabelActor$i.$j SetMapper aLabelMapper$i.$j
				aLabelActor$i.$j SetScale 0.02 0.02 0.02
				aLabelActor$i.$j AddPosition $Box($i,$j,start,x) $Box($i,$j,start,y)  [expr $Z + 0.1 ]		

			set Box($i,$j,Label) aLabelActor$i.$j
		}
	}

}

#
# Image Actor Create
#
proc actorCreate { } { 
	global PlaneActor
	global Box
	#puts "actorCreate Start" ; flush stdout	
	set i 1
	if [catch {open FileList2 r} file1] {
		puts stderr "Cannot open FileList: $file1"
	} else {
		while {[gets $file1 line] >= 0} {

			vtkTIFFReader tmpImage$i; set ImageIn($i) tmpImage$i 
			$ImageIn($i) SetFileName $line

			vtkTexture tmpTexture$i; set Texture($i) tmpTexture$i
			$Texture($i) SetInput [$ImageIn($i) GetOutput]
			$Texture($i) InterpolateOn
	
			vtkPlaneSource tmpPlane$i ; set Plane($i) tmpPlane$i
			tmpPlane$i SetXResolution 1
			tmpPlane$i SetYResolution 1
	
			vtkPolyDataMapper tmpPlaneMapper$i; set PlaneMapper($i) tmpPlaneMapper$i
			$PlaneMapper($i) SetInput [ $Plane($i) GetOutput]
	
 			vtkActor tmpPlaneActor$i; set PlaneActor($i) tmpPlaneActor$i
			$PlaneActor($i) SetMapper $PlaneMapper($i)
			$PlaneActor($i) SetTexture $Texture($i)
			$PlaneActor($i) SetPosition 0 0 [expr $i*$PlaneActor(deltaZ)]
	
			#vtkImageActor Actor$i
			#Actor$i SetInput [ImageIn$i GetOutput]
			#Actor$i SetZSlice $j
			#ren1 AddActor Actor$i
			set Box($i,num) 0
			incr i
		}
	}	

	set PlaneActor(number) $i 
	close $file1

	#puts "actorCreate End"; flush stdout
}

#
# Actor Select
#
proc actorSelect {angle} {
	global PlaneActor 
	global Box 
	#puts "Start actorSelect : $angle"; flush stdout

	#for { set a 1 } { $a <= $PlaneActor(number) } {incr a } {
	#	catch { ren1 AddActor $PlaneActor($a) }
	#}
	set min [expr $PlaneActor(current)-$PlaneActor(range)] ; if {$min <= 0 } { set min 1 }
	set max [expr $PlaneActor(current)+$PlaneActor(range)] ; if {$PlaneActor(number) < $max } { set max $PlaneActor(number)  } 

	set minn [expr $angle-$PlaneActor(range)] ; if {$min <= 0 } { set min 1 }
	set maxn [expr $angle+$PlaneActor(range)] ; if {$PlaneActor(number) < $max } { set max $PlaneActor(number)  } 
	if { $minn < $min } {
		for {set a $max } {$maxn <  $a && $min<= $a } {incr a -1 } {
			puts "remove $a"
			catch { ren1 RemoveProp $PlaneActor($a) }
			if [ catch { set N $Box($a,num) } ] {
				set N 0
			}
			for { set i 1 } { $i <= $N } { incr i } {
				catch { ren1 RemoveProp $Box($a,$i,Actor) }
				catch { ren1 RemoveProp $Box($a,$i,Label) }
			}
		}
		for { set j $minn } {$j < $min && $j <= $maxn } { incr j } {
			puts "add $j"
			if [ catch { set N $Box($a,num) } ] {
				set N 0
			}
			for { set i 1 } { $i <= $N } { incr i } {
				catch {ren1 AddProp $Box($j,$i,Actor) }
				catch {ren1 AddProp $Box($j,$i,Label) }
			}
			catch { ren1 AddProp $PlaneActor($j) } {
				puts "Cannot be Added"
			}
		}
	} else {
		for {set a $min } {$a < $minn && $a <= $max } {incr a} {
			puts "remove $a" 	
			catch { ren1 RemoveProp $PlaneActor($a) }
			if [ catch { set N $Box($a,num) } ] {
				set N 0
			}
			for { set i 1 } { $i <= $N } { incr i } {
				catch { ren1 RemoveProp $Box($a,$i,Actor) }
				catch { ren1 RemoveProp $Box($a,$i,Label) }
			}
		}
		for { set j $maxn } {$max < $j && $minn <= $j } { incr j -1 } {
			puts "add $j"
			if [ catch { set N $Box($j,num) } ] {
				set N 0
			}
			for { set i 1 } { $i <= $N } { incr i } {
				catch { ren1 AddProp $Box($j,$i,Actor) }
				catch { ren1 AddProp $Box($j,$i,Label) }
			}
			catch { ren1 AddProp $PlaneActor($j) } {
				puts "Cannot be Added"
			}	
		}
	}
catch {
vtkPoints polyLinePoints
  polyLinePoints SetNumberOfPoints 3
  polyLinePoints InsertPoint 0 0 0 0
  polyLinePoints InsertPoint 1 0.5 0 0
  polyLinePoints InsertPoint 2 0.5 0.5 0
vtkPolyLine aPolyLine
  [aPolyLine GetPointIds] SetNumberOfIds 3
  [aPolyLine GetPointIds] SetId 0 0
  [aPolyLine GetPointIds] SetId 1 1
  [aPolyLine GetPointIds] SetId 2 2
vtkUnstructuredGrid aPolyLineGrid
  aPolyLineGrid Allocate 1 1
  aPolyLineGrid InsertNextCell [aPolyLine GetCellType] [aPolyLine GetPointIds]
  aPolyLineGrid SetPoints polyLinePoints
vtkDataSetMapper aPolyLineMapper
  aPolyLineMapper SetInput aPolyLineGrid
vtkActor aPolyLineActor
  aPolyLineActor SetMapper aPolyLineMapper
  aPolyLineActor AddPosition 0 0 2
  [aPolyLineActor GetProperty] SetDiffuseColor 1 1 1
	
	#ren1 AddActor aPolyLineActor
}
	set PlaneActor(current) $angle

	#ren1 ResetCameraClippingRange
	#[ren1 GetRenderWindow] Render 
	ren1 ResetCamera
	#[ren1 GetActiveCamera ] SetClippingRange -0.5 0.5 
	[ren1 GetRenderWindow] Render 
	#puts "End actorSelect "; flush stdout
}												 

#::vtk::bind_tk_render_widget $desktop(vtkw)

#message .msg -justify center -text "Hello smolet world!!"

#scale .scale -from 0 -to 121 -length 400 -variable angle -orient horizontal -label "tilt angle" -tickinterval 5 -showvalue true 
#pack .ren .scale .msg 

#wm withdraw .
proc leftButtonFunc { } {
	puts "leftButtonFunc"
}

proc desktopInit { } {
	global desktop
	global vtkw
	global renWin
	global PlaneActor

	vtkRenderWindow renWin
	renWin SetSize $desktop(width) $desktop(height) 
	set vtkw [ vtkTkRenderWidget .ren -width $desktop(width) -height $desktop(height) -rw renWin ]
	#::vtk::bind_tk_render_widget $vtkw

	vtkRenderer ren1
	renWin AddRenderer ren1
	ren1 Transparent
	ren1 SetBackground 0.5 0.5 0.5

	vtkRenderWindowInteractor iren
	iren SetRenderWindow renWin

	set camera1 [ ren1 GetActiveCamera ]
	ren1 ResetCameraClippingRange
	renWin Render
	$camera1 SetObliqueAngles 60 90 

	vtkInteractorStyleJoystickCamera myStyle
	iren SetInteractorStyle myStyle
	myStyle SetLeftButtonPressMethod { leftButtonFunc }

	scale .scale -from 1 -to $PlaneActor(number) -length 400  \
		-variable angle -orient horizontal    \
		-label "tilt angle" -tickinterval 5   \
		-showvalue true -command { actorSelect }
	set ff [ frame .readBox ]
	button $ff.b    -text readBox                -command  { readBoxFileList ; createBoxActor}  
	entry  $ff.file -textvariable FileList(list)
	bind   $ff.file	<Return> {readBoxFileList }
	pack $ff.b $ff.file -side left

	set ff [ frame .writeBox ]
	button $ff.b    -text writeBox               -command { writeBoxFileList } 
	entry  $ff.file -textvariable writeBoxFile   
	bind $ff.file <Return> {writeBoxFileList }  
	pack $ff.b $ff.file -side left

	pack .ren .scale .readBox .writeBox
}


actorCreate
desktopInit
actorSelect $angle

#::vtk::bind_tk_render_widget $vtkw

tkwait window .
