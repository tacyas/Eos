/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Ruby 1.9.1 has a "memoisation optimisation" when compiling with GCC which
 * breaks using rb_intern as an lvalue, as SWIG does.  We work around this
 * issue for now by disabling this.
 * https://sourceforge.net/tracker/?func=detail&aid=2859614&group_id=1645&atid=101645
 */
#ifdef rb_intern
# undef rb_intern
#endif

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef bind
# undef bind
#endif
#ifdef close
# undef close
#endif
#ifdef connect
# undef connect
#endif


/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif



/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a function in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. 
*/
static VALUE swig_ruby_trackings = Qnil;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a 
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  ID trackings_id = rb_intern( "@__trackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* No, it hasn't.  Create one ourselves */ 
  if ( swig_ruby_trackings == Qnil )
    {
      swig_ruby_trackings = rb_hash_new();
      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
    }

  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  return SWIG2NUM(ptr);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  return SWIG2NUM(object);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* Convert the Ruby number to a Ruby object */
  return NUM2SWIG(reference);
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), "%s", msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, "%s", x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        const char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void *SWIGUNUSEDPARM(clientdata))
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) )
    {
      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Array swig_types[0]
#define SWIGTYPE_p_Coord swig_types[1]
#define SWIGTYPE_p_EulerAngleInfo swig_types[2]
#define SWIGTYPE_p_FEIextendedHeader swig_types[3]
#define SWIGTYPE_p_FILE swig_types[4]
#define SWIGTYPE_p_GLboolean swig_types[5]
#define SWIGTYPE_p_GLdouble swig_types[6]
#define SWIGTYPE_p_GLfloat swig_types[7]
#define SWIGTYPE_p_GLint swig_types[8]
#define SWIGTYPE_p_GLuint swig_types[9]
#define SWIGTYPE_p_MRC_Status_t swig_types[10]
#define SWIGTYPE_p_MRC_Status_t_status swig_types[11]
#define SWIGTYPE_p_ProteinStatus swig_types[12]
#define SWIGTYPE_p_Quat swig_types[13]
#define SWIGTYPE_p__FEIextendedHeader swig_types[14]
#define SWIGTYPE_p__mrcImageHeader swig_types[15]
#define SWIGTYPE_p__mrcImageHeaderCCP4 swig_types[16]
#define SWIGTYPE_p__mrcImageHeaderIMOD swig_types[17]
#define SWIGTYPE_p__mrcImageTailer swig_types[18]
#define SWIGTYPE_p_a_4__a_4__float swig_types[19]
#define SWIGTYPE_p_a_4__float swig_types[20]
#define SWIGTYPE_p_a__80___char swig_types[21]
#define SWIGTYPE_p_cameraInfo swig_types[22]
#define SWIGTYPE_p_char swig_types[23]
#define SWIGTYPE_p_contourLinesSet swig_types[24]
#define SWIGTYPE_p_ctfInfo swig_types[25]
#define SWIGTYPE_p_displayMode swig_types[26]
#define SWIGTYPE_p_double swig_types[27]
#define SWIGTYPE_p_elementSwitch swig_types[28]
#define SWIGTYPE_p_float swig_types[29]
#define SWIGTYPE_p_floatVector swig_types[30]
#define SWIGTYPE_p_int swig_types[31]
#define SWIGTYPE_p_lmrcImageBandPassFilterInfo swig_types[32]
#define SWIGTYPE_p_lmrcImageCTFSNInfo swig_types[33]
#define SWIGTYPE_p_lmrcImageCVEInfo swig_types[34]
#define SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo swig_types[35]
#define SWIGTYPE_p_lmrcImageHighPassFilterInfo swig_types[36]
#define SWIGTYPE_p_lmrcImageHighlightInfo swig_types[37]
#define SWIGTYPE_p_lmrcImageLowPassFilterInfo swig_types[38]
#define SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo swig_types[39]
#define SWIGTYPE_p_lmrcImageMultiCTFCompensationSolventFlatteningMode swig_types[40]
#define SWIGTYPE_p_lmrcImageSmoothingInfo swig_types[41]
#define SWIGTYPE_p_lmrcImageTfunctionInfo swig_types[42]
#define SWIGTYPE_p_long swig_types[43]
#define SWIGTYPE_p_mrcImage swig_types[44]
#define SWIGTYPE_p_mrcImageDataSetMode swig_types[45]
#define SWIGTYPE_p_mrcImageFourierPowerSpectrum swig_types[46]
#define SWIGTYPE_p_mrcImageHeader swig_types[47]
#define SWIGTYPE_p_mrcImageInformation swig_types[48]
#define SWIGTYPE_p_mrcImageInformationMode swig_types[49]
#define SWIGTYPE_p_mrcImageParaTypeIntegerCoord swig_types[50]
#define SWIGTYPE_p_mrcImageParaTypeRealCoord swig_types[51]
#define SWIGTYPE_p_mrcImagePyramid swig_types[52]
#define SWIGTYPE_p_mrcImagePyramidList swig_types[53]
#define SWIGTYPE_p_mrcImageTailer swig_types[54]
#define SWIGTYPE_p_mrcPixelDataHowToGet swig_types[55]
#define SWIGTYPE_p_mrcPixelDataType swig_types[56]
#define SWIGTYPE_p_operationMode swig_types[57]
#define SWIGTYPE_p_p_char swig_types[58]
#define SWIGTYPE_p_p_double swig_types[59]
#define SWIGTYPE_p_p_floatVector swig_types[60]
#define SWIGTYPE_p_pdbCenter swig_types[61]
#define SWIGTYPE_p_pdbCoord swig_types[62]
#define SWIGTYPE_p_pdbFile swig_types[63]
#define SWIGTYPE_p_pdbFileSecondaryStructure swig_types[64]
#define SWIGTYPE_p_pdbFileSecondaryStructureMode swig_types[65]
#define SWIGTYPE_p_pdbFileSecondaryStructureRecord swig_types[66]
#define SWIGTYPE_p_pdbRecord swig_types[67]
#define SWIGTYPE_p_pdbSecondaryStructureHelix swig_types[68]
#define SWIGTYPE_p_pdbSecondaryStructureHelixClass swig_types[69]
#define SWIGTYPE_p_pdbSecondaryStructureNo swig_types[70]
#define SWIGTYPE_p_pdbSecondaryStructureSheet swig_types[71]
#define SWIGTYPE_p_pdbSecondaryStructureTurn swig_types[72]
#define SWIGTYPE_p_residueName swig_types[73]
#define SWIGTYPE_p_short swig_types[74]
#define SWIGTYPE_p_unsigned_char swig_types[75]
#define SWIGTYPE_p_unsigned_int swig_types[76]
#define SWIGTYPE_p_unsigned_long swig_types[77]
#define SWIGTYPE_p_unsigned_short swig_types[78]
static swig_type_info *swig_types[80];
static swig_module_info swig_module = {swig_types, 79, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_molvieRuby
#define SWIG_name    "MolvieRuby"

static VALUE mMolvieRuby;

#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIGVERSION 0x020010 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#include <ruby.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <GL/glut.h>

#include "Matrix3D.h"
#include "mrcImage.h"
#include "pdbFile.h"
#include "DisplayListNumber.h"
#include "lmolvieProteinStatus.h"
#include "molvieDefault.h"
#include "molvieDockDefault.h"
#include "molvieFlightDefault.h"
#include "molvieMrcViewerDefault.h"
#include "molvieProjectionDefault.h"
#include "molvieViewerDefault.h"
#include "lmolvie.h"



#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


  #define SWIG_From_double   rb_float_new 


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    char *cstr = StringValuePtr(obj); 
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = (char *)memcpy((char *)malloc((size)*sizeof(char)), cstr, sizeof(char)*(size));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	free((char*)cptr);
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) free((char*)cptr);
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj((char *)(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, (long)(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:/usr/share/swig/2.0.10/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = NUM2DBL(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


/*@SWIG:/usr/share/swig/2.0.10/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = (char)(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


#include <float.h>


SWIGINTERN int
SWIG_AsVal_float (VALUE obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < -FLT_MAX || v > FLT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


/*@SWIG:/usr/share/swig/2.0.10/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

typedef struct {
  short detail;
  unsigned char category;
  unsigned char level;
  
} MRC_Status_t_status;



SWIGINTERN int
SWIG_AsVal_short (VALUE obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (short)(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_char (VALUE obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned char)(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
}





SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}

static swig_class SwigClassEulerAngleInfo;

SWIGINTERN VALUE
_wrap_EulerAngleInfo_EAMode_set(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[5] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","EAMode", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 5);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [5]","EAMode", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->EAMode,arg2,5*sizeof(char));
  else memset(arg1->EAMode,0,5*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_EAMode_get(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","EAMode", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  result = (char *)(char *) ((arg1)->EAMode);
  {
    size_t size = 5;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot1_set(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot1", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Rot1", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->Rot1 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot1_get(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot1", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  result = (double) ((arg1)->Rot1);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot2_set(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot2", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Rot2", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->Rot2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot2_get(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot2", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  result = (double) ((arg1)->Rot2);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot3_set(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot3", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Rot3", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->Rot3 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EulerAngleInfo_Rot3_get(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *arg1 = (struct EulerAngleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EulerAngleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct EulerAngleInfo *","Rot3", 1, self )); 
  }
  arg1 = (struct EulerAngleInfo *)(argp1);
  result = (double) ((arg1)->Rot3);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_EulerAngleInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_EulerAngleInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_EulerAngleInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_EulerAngleInfo(int argc, VALUE *argv, VALUE self) {
  struct EulerAngleInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct EulerAngleInfo *)calloc(1, sizeof(struct EulerAngleInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_EulerAngleInfo(struct EulerAngleInfo *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_matrix3DInit(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DInit", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  matrix3DInit((float (*)[4])arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DCopy(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DCopy", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DCopy", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DCopy((float (*)[4])arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DFromRotationMatrix(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  Array arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DFromRotationMatrix", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_Array,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Array","matrix3DFromRotationMatrix", 2, argv[1] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Array","matrix3DFromRotationMatrix", 2, argv[1]));
    } else {
      arg2 = *((Array *)(argp2));
    }
  }
  matrix3DFromRotationMatrix((float (*)[4])arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DInverse(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DInverse", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  matrix3DInverse((float (*)[4])arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DMultiply(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiply", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiply", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DMultiply((float (*)[4])arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DMultiplyInv(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiplyInv", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiplyInv", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DMultiplyInv((float (*)[4])arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DMultiplyVector(int argc, VALUE *argv, VALUE self) {
  floatVector *arg1 = (floatVector *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_floatVector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "floatVector *","matrix3DMultiplyVector", 1, argv[0] )); 
  }
  arg1 = (floatVector *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiplyVector", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DMultiplyVector(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DMultiplyVectors(int argc, VALUE *argv, VALUE self) {
  floatVector *arg1 = (floatVector *) 0 ;
  int arg2 ;
  matrix3DParaTypeReal (*arg3)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_floatVector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "floatVector *","matrix3DMultiplyVectors", 1, argv[0] )); 
  }
  arg1 = (floatVector *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","matrix3DMultiplyVectors", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "float [4][4]","matrix3DMultiplyVectors", 3, argv[2] )); 
  } 
  arg3 = (float (*)[4])(argp3);
  matrix3DMultiplyVectors(arg1,arg2,(float (*)[4])arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DFileFormat(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","matrix3DFileFormat", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  matrix3DFileFormat(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DFileRead(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","matrix3DFileRead", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DFileRead", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DFileRead(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DFileWrite(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","matrix3DFileWrite", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","matrix3DFileWrite", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  matrix3DFileWrite(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSet(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  char arg2 ;
  matrix3DParaTypeReal arg3 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSet", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","matrix3DRotationSet", 2, argv[1] ));
  } 
  arg2 = (char)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSet", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","matrix3DRotationSet", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  matrix3DRotationSet((float (*)[4])arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DTranslationSet(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DTranslationSet", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DTranslationSet", 2, argv[1] ));
  } 
  arg2 = (matrix3DParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DTranslationSet", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DTranslationSet", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","matrix3DTranslationSet", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  matrix3DTranslationSet((float (*)[4])arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSetXYZ(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSetXYZ", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetXYZ", 2, argv[1] ));
  } 
  arg2 = (matrix3DParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetXYZ", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetXYZ", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","matrix3DRotationSetXYZ", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  matrix3DRotationSetXYZ((float (*)[4])arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSetZYX(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSetZYX", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZYX", 2, argv[1] ));
  } 
  arg2 = (matrix3DParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZYX", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZYX", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","matrix3DRotationSetZYX", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  matrix3DRotationSetZYX((float (*)[4])arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSetZXY(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSetZXY", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZXY", 2, argv[1] ));
  } 
  arg2 = (matrix3DParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZXY", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetZXY", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","matrix3DRotationSetZXY", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  matrix3DRotationSetZXY((float (*)[4])arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSetYXZ(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  matrix3DParaTypeReal arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSetYXZ", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetYXZ", 2, argv[1] ));
  } 
  arg2 = (matrix3DParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetYXZ", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetYXZ", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","matrix3DRotationSetYXZ", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  matrix3DRotationSetYXZ((float (*)[4])arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationSetFollowingEulerAngle(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  char *arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  matrix3DParaTypeReal arg5 ;
  long arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationSetFollowingEulerAngle", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_AsCharArray(argv[1], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const [4]","matrix3DRotationSetFollowingEulerAngle", 2, argv[1] ));
  }
  arg2 = (char *)(temp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetFollowingEulerAngle", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetFollowingEulerAngle", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationSetFollowingEulerAngle", 5, argv[4] ));
  } 
  arg5 = (matrix3DParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_long(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "long","matrix3DRotationSetFollowingEulerAngle", 6, argv[5] ));
  } 
  arg6 = (long)(val6);
  matrix3DRotationSetFollowingEulerAngle((float (*)[4])arg1,(char const (*))arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DRotationAntiSetFollowingEulerAngle(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  char *arg2 ;
  matrix3DParaTypeReal arg3 ;
  matrix3DParaTypeReal arg4 ;
  matrix3DParaTypeReal arg5 ;
  long arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DRotationAntiSetFollowingEulerAngle", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_AsCharArray(argv[1], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const [4]","matrix3DRotationAntiSetFollowingEulerAngle", 2, argv[1] ));
  }
  arg2 = (char *)(temp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationAntiSetFollowingEulerAngle", 3, argv[2] ));
  } 
  arg3 = (matrix3DParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationAntiSetFollowingEulerAngle", 4, argv[3] ));
  } 
  arg4 = (matrix3DParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "matrix3DParaTypeReal","matrix3DRotationAntiSetFollowingEulerAngle", 5, argv[4] ));
  } 
  arg5 = (matrix3DParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_long(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "long","matrix3DRotationAntiSetFollowingEulerAngle", 6, argv[5] ));
  } 
  arg6 = (long)(val6);
  matrix3DRotationAntiSetFollowingEulerAngle((float (*)[4])arg1,(char const (*))arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_matrix3DEulerAngleGetFromMatrix3D(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  char *arg2 ;
  matrix3DParaTypeReal *arg3 = (matrix3DParaTypeReal *) 0 ;
  matrix3DParaTypeReal *arg4 = (matrix3DParaTypeReal *) 0 ;
  matrix3DParaTypeReal *arg5 = (matrix3DParaTypeReal *) 0 ;
  long arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","matrix3DEulerAngleGetFromMatrix3D", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  res2 = SWIG_AsCharArray(argv[1], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const [4]","matrix3DEulerAngleGetFromMatrix3D", 2, argv[1] ));
  }
  arg2 = (char *)(temp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "matrix3DParaTypeReal *","matrix3DEulerAngleGetFromMatrix3D", 3, argv[2] )); 
  }
  arg3 = (matrix3DParaTypeReal *)(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "matrix3DParaTypeReal *","matrix3DEulerAngleGetFromMatrix3D", 4, argv[3] )); 
  }
  arg4 = (matrix3DParaTypeReal *)(argp4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "matrix3DParaTypeReal *","matrix3DEulerAngleGetFromMatrix3D", 5, argv[4] )); 
  }
  arg5 = (matrix3DParaTypeReal *)(argp5);
  ecode6 = SWIG_AsVal_long(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "long","matrix3DEulerAngleGetFromMatrix3D", 6, argv[5] ));
  } 
  arg6 = (long)(val6);
  matrix3DEulerAngleGetFromMatrix3D((float (*)[4])arg1,(char const (*))arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassQuat;

SWIGINTERN VALUE
_wrap_Quat_x_set(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","x", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","x", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_x_get(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","x", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  result = (float) ((arg1)->x);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_y_set(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","y", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","y", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_y_get(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","y", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  result = (float) ((arg1)->y);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_z_set(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","z", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","z", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_z_get(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","z", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  result = (float) ((arg1)->z);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_w_set(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","w", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","w", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->w = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Quat_w_get(int argc, VALUE *argv, VALUE self) {
  Quat *arg1 = (Quat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Quat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat *","w", 1, self )); 
  }
  arg1 = (Quat *)(argp1);
  result = (float) ((arg1)->w);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Quat_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Quat_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Quat);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Quat(int argc, VALUE *argv, VALUE self) {
  Quat *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (Quat *)calloc(1, sizeof(Quat));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Quat(Quat *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_Eul_(int argc, VALUE *argv, VALUE self) {
  float arg1 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  EulerAngles result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_float(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "float","Eul_", 1, argv[0] ));
  } 
  arg1 = (float)(val1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","Eul_", 2, argv[1] ));
  } 
  arg2 = (float)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "float","Eul_", 3, argv[2] ));
  } 
  arg3 = (float)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","Eul_", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  result = Eul_(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj((EulerAngles *)memcpy((EulerAngles *)malloc(sizeof(EulerAngles)),&result,sizeof(EulerAngles)), SWIGTYPE_p_Quat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Eul_ToQuat(int argc, VALUE *argv, VALUE self) {
  EulerAngles arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  Quat result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Quat,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EulerAngles","Eul_ToQuat", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "EulerAngles","Eul_ToQuat", 1, argv[0]));
    } else {
      arg1 = *((EulerAngles *)(argp1));
    }
  }
  result = Eul_ToQuat(arg1);
  vresult = SWIG_NewPointerObj((Quat *)memcpy((Quat *)malloc(sizeof(Quat)),&result,sizeof(Quat)), SWIGTYPE_p_Quat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Eul_ToHMatrix(int argc, VALUE *argv, VALUE self) {
  EulerAngles arg1 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Quat,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EulerAngles","Eul_ToHMatrix", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "EulerAngles","Eul_ToHMatrix", 1, argv[0]));
    } else {
      arg1 = *((EulerAngles *)(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","Eul_ToHMatrix", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  Eul_ToHMatrix(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Eul_FromHMatrix(int argc, VALUE *argv, VALUE self) {
  matrix3DParaTypeReal (*arg1)[4] ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  EulerAngles result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float [4][4]","Eul_FromHMatrix", 1, argv[0] )); 
  } 
  arg1 = (float (*)[4])(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Eul_FromHMatrix", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  result = Eul_FromHMatrix((float (*)[4])arg1,arg2);
  vresult = SWIG_NewPointerObj((EulerAngles *)memcpy((EulerAngles *)malloc(sizeof(EulerAngles)),&result,sizeof(EulerAngles)), SWIGTYPE_p_Quat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Eul_FromQuat(int argc, VALUE *argv, VALUE self) {
  Quat arg1 ;
  int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  EulerAngles result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Quat,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Quat","Eul_FromQuat", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Quat","Eul_FromQuat", 1, argv[0]));
    } else {
      arg1 = *((Quat *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Eul_FromQuat", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  result = Eul_FromQuat(arg1,arg2);
  vresult = SWIG_NewPointerObj((EulerAngles *)memcpy((EulerAngles *)malloc(sizeof(EulerAngles)),&result,sizeof(EulerAngles)), SWIGTYPE_p_Quat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageGeneralTypeList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(mrcImageGeneralTypeList), SWIGTYPE_p_p_char,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_mrcImageGeneralTypeList_set(VALUE self, VALUE _val) {
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only mrcImageGeneralTypeList""' of type '""char *[]""'");
  return _val;
fail:
  return Qnil;
}


static swig_class SwigClassMRC_Status_t;

SWIGINTERN VALUE
_wrap_MRC_Status_t_all_set(int argc, VALUE *argv, VALUE self) {
  union MRC_Status_t *arg1 = (union MRC_Status_t *) 0 ;
  mrcStatusType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union MRC_Status_t *","all", 1, self )); 
  }
  arg1 = (union MRC_Status_t *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcStatusType","all", 2, argv[0] ));
  } 
  arg2 = (mrcStatusType)(val2);
  if (arg1) (arg1)->all = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_all_get(int argc, VALUE *argv, VALUE self) {
  union MRC_Status_t *arg1 = (union MRC_Status_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union MRC_Status_t *","all", 1, self )); 
  }
  arg1 = (union MRC_Status_t *)(argp1);
  result = (mrcStatusType) ((arg1)->all);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_get(int argc, VALUE *argv, VALUE self) {
  union MRC_Status_t *arg1 = (union MRC_Status_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MRC_Status_t_status *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union MRC_Status_t *","status", 1, self )); 
  }
  arg1 = (union MRC_Status_t *)(argp1);
  result = (MRC_Status_t_status *)& ((arg1)->status);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MRC_Status_t_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MRC_Status_t_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MRC_Status_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MRC_Status_t(int argc, VALUE *argv, VALUE self) {
  union MRC_Status_t *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (union MRC_Status_t *)calloc(1, sizeof(union MRC_Status_t));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_MRC_Status_t(union MRC_Status_t *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMRC_Status_t_status;

SWIGINTERN VALUE
_wrap_MRC_Status_t_status_detail_set(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","detail", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","detail", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->detail = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_detail_get(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","detail", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  result = (short) ((arg1)->detail);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_category_set(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","category", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned char","category", 2, argv[0] ));
  } 
  arg2 = (unsigned char)(val2);
  if (arg1) (arg1)->category = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_category_get(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","category", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  result = (unsigned char) ((arg1)->category);
  vresult = SWIG_From_unsigned_SS_char((unsigned char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_level_set(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","level", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned char","level", 2, argv[0] ));
  } 
  arg2 = (unsigned char)(val2);
  if (arg1) (arg1)->level = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MRC_Status_t_status_level_get(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *arg1 = (MRC_Status_t_status *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MRC_Status_t_status, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MRC_Status_t_status *","level", 1, self )); 
  }
  arg1 = (MRC_Status_t_status *)(argp1);
  result = (unsigned char) ((arg1)->level);
  vresult = SWIG_From_unsigned_SS_char((unsigned char)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MRC_Status_t_status_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MRC_Status_t_status_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MRC_Status_t_status);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MRC_Status_t_status(int argc, VALUE *argv, VALUE self) {
  MRC_Status_t_status *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (MRC_Status_t_status *)calloc(1, sizeof(MRC_Status_t_status));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_MRC_Status_t_status(MRC_Status_t_status *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImageParaTypeIntegerCoord;

SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_x_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","x", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","x", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_x_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","x", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->x);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_y_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","y", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","y", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_y_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","y", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->y);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_z_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","z", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","z", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_z_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *arg1 = (struct mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeIntegerCoord *","z", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeIntegerCoord *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->z);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageParaTypeIntegerCoord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageParaTypeIntegerCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageParaTypeIntegerCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageParaTypeIntegerCoord(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeIntegerCoord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImageParaTypeIntegerCoord *)calloc(1, sizeof(struct mrcImageParaTypeIntegerCoord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageParaTypeIntegerCoord(struct mrcImageParaTypeIntegerCoord *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImageParaTypeRealCoord;

SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_x_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","x", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","x", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_x_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","x", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->x);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_y_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","y", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","y", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_y_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","y", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->y);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_z_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","z", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","z", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_z_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *arg1 = (struct mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageParaTypeRealCoord *","z", 1, self )); 
  }
  arg1 = (struct mrcImageParaTypeRealCoord *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->z);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageParaTypeRealCoord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageParaTypeRealCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageParaTypeRealCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageParaTypeRealCoord(int argc, VALUE *argv, VALUE self) {
  struct mrcImageParaTypeRealCoord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImageParaTypeRealCoord *)calloc(1, sizeof(struct mrcImageParaTypeRealCoord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageParaTypeRealCoord(struct mrcImageParaTypeRealCoord *arg1) {
    free((char *) arg1);
}

static swig_class SwigClass_mrcImageHeader;

SWIGINTERN VALUE
_wrap__mrcImageHeader_N_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","N", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->N = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_N_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->N);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Mode_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageMode","Mode", 2, argv[0] ));
  } 
  arg2 = (mrcImageMode)(val2);
  if (arg1) (arg1)->Mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Mode_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageMode) ((arg1)->Mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_StartN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","StartN", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->StartN = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_StartN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->StartN);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_M_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","M", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","M", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->M = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_M_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","M", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->M);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Length_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","Length", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->Length = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Length_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->Length);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Alpha_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Alpha", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Alpha = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Alpha_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Alpha);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Beta_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Beta", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Beta = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Beta_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Beta);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Gamma_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Gamma", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Gamma = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Gamma_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Gamma);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPC_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPC", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPC = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPC_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPC);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPR_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPR", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPR = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPR_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPR);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPS_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPS", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_MAPS_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPS);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMin_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMin", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMin_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMin);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMax_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMax", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMax_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMax);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMean_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMean", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMean = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_AMean_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMean);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_ISPG_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","ISPG", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->ISPG = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_ISPG_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->ISPG);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_NSYMBT_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","NSYMBT", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->NSYMBT = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_NSYMBT_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->NSYMBT);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_EXTRA_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","EXTRA", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(29)]","EXTRA", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(29); ++ii) arg1->EXTRA[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""EXTRA""' of type '""mrcImageParaTypeReal [(29)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_EXTRA_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","EXTRA", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->EXTRA);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_OriginX_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","OriginX", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","OriginX", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->OriginX = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_OriginX_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","OriginX", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->OriginX);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_OriginY_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","OriginY", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","OriginY", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->OriginY = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_OriginY_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","OriginY", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->OriginY);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_LabelN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","LabelN", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->LabelN = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_LabelN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->LabelN);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Label_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  char (*arg2)[(80)] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a__80___char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(10)][(80)]","Label", 2, argv[0] )); 
  } 
  arg2 = (char (*)[(80)])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(10); ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)(80); ++jj) arg1->Label[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeader_Label_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *arg1 = (struct _mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char (*result)[(80)] = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeader *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeader *)(argp1);
  result = (char (*)[(80)])(char (*)[(80)]) ((arg1)->Label);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a__80___char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap__mrcImageHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap__mrcImageHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p__mrcImageHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new__mrcImageHeader(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct _mrcImageHeader *)calloc(1, sizeof(struct _mrcImageHeader));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free__mrcImageHeader(struct _mrcImageHeader *arg1) {
    free((char *) arg1);
}

static swig_class SwigClass_mrcImageHeaderCCP4;

SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_N_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","N", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->N = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_N_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->N);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Mode_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageMode","Mode", 2, argv[0] ));
  } 
  arg2 = (mrcImageMode)(val2);
  if (arg1) (arg1)->Mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Mode_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageMode) ((arg1)->Mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_StartN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","StartN", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->StartN = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_StartN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->StartN);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_NI_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","NI", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","NI", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->NI = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_NI_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","NI", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->NI);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Length_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","Length", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->Length = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Length_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->Length);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Alpha_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Alpha", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Alpha = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Alpha_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Alpha);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Beta_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Beta", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Beta = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Beta_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Beta);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Gamma_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Gamma", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Gamma = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Gamma_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Gamma);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPC_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPC", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPC = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPC_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPC);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPR_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPR", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPR = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPR_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPR);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPS_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPS", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAPS_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPS);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMin_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMin", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMin_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMin);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMax_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMax", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMax_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMax);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMean_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMean", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMean = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_AMean_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMean);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_ISPG_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","ISPG", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->ISPG = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_ISPG_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->ISPG);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_NSYMBT_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","NSYMBT", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->NSYMBT = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_NSYMBT_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->NSYMBT);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_LSKFLG_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","LSKFLG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","LSKFLG", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->LSKFLG = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_LSKFLG_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","LSKFLG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->LSKFLG);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_SKWMAT_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","SKWMAT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [9]","SKWMAT", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)9; ++ii) arg1->SKWMAT[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""SKWMAT""' of type '""mrcImageParaTypeReal [9]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_SKWMAT_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","SKWMAT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->SKWMAT);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_SKWTRN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","SKWTRN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [3]","SKWTRN", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->SKWTRN[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""SKWTRN""' of type '""mrcImageParaTypeReal [3]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_SKWTRN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","SKWTRN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->SKWTRN);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_EXTRA_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","EXTRA", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(15)]","EXTRA", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(15); ++ii) arg1->EXTRA[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""EXTRA""' of type '""mrcImageParaTypeReal [(15)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_EXTRA_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","EXTRA", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->EXTRA);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAP_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAP", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeCharacter [4]","MAP", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeCharacter *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)4; ++ii) arg1->MAP[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""MAP""' of type '""mrcImageParaTypeCharacter [4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MAP_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MAP", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeCharacter *)(mrcImageParaTypeCharacter *) ((arg1)->MAP);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MARCHST_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MARCHST", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MARCHST", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MARCHST = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_MARCHST_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","MARCHST", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MARCHST);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_ARMS_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","ARMS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","ARMS", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->ARMS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_ARMS_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","ARMS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->ARMS);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_LabelN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","LabelN", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->LabelN = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_LabelN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->LabelN);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Label_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  char (*arg2)[(80)] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a__80___char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(10)][(80)]","Label", 2, argv[0] )); 
  } 
  arg2 = (char (*)[(80)])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(10); ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)(80); ++jj) arg1->Label[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_Label_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *arg1 = (struct _mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char (*result)[(80)] = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderCCP4 *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderCCP4 *)(argp1);
  result = (char (*)[(80)])(char (*)[(80)]) ((arg1)->Label);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a__80___char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap__mrcImageHeaderCCP4_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap__mrcImageHeaderCCP4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p__mrcImageHeaderCCP4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new__mrcImageHeaderCCP4(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderCCP4 *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct _mrcImageHeaderCCP4 *)calloc(1, sizeof(struct _mrcImageHeaderCCP4));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free__mrcImageHeaderCCP4(struct _mrcImageHeaderCCP4 *arg1) {
    free((char *) arg1);
}

static swig_class SwigClass_mrcImageHeaderIMOD;

SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_N_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","N", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->N = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_N_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","N", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->N);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Mode_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageMode","Mode", 2, argv[0] ));
  } 
  arg2 = (mrcImageMode)(val2);
  if (arg1) (arg1)->Mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Mode_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageMode) ((arg1)->Mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_StartN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","StartN", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->StartN = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_StartN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","StartN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->StartN);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_M_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeIntegerCoord *arg2 = (mrcImageParaTypeIntegerCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","M", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord *","M", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeIntegerCoord *)(argp2);
  if (arg1) (arg1)->M = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_M_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeIntegerCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","M", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeIntegerCoord *)& ((arg1)->M);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeIntegerCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Length_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","Length", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->Length = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Length_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Length", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->Length);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Alpha_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Alpha", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Alpha = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Alpha_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Alpha", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Alpha);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Beta_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Beta", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Beta = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Beta_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Beta", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Beta);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Gamma_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Gamma", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Gamma = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Gamma_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Gamma", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Gamma);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPC_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPC", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPC = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPC_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPC", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPC);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPR_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPR", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPR = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPR_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPR", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPR);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPS_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MAPS", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MAPS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAPS_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAPS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MAPS);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMin_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMin", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMin_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMin", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMin);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMax_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMax", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMax_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMax", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMax);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMean_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","AMean", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->AMean = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_AMean_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","AMean", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->AMean);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_ISPG_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","ISPG", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->ISPG = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_ISPG_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","ISPG", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->ISPG);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_NSYMBT_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","NSYMBT", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->NSYMBT = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_NSYMBT_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","NSYMBT", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->NSYMBT);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_creatid_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","creatid", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","creatid", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->creatid = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_creatid_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","creatid", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->creatid);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_extra1_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","extra1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_short, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "short [15]","extra1", 2, argv[0] )); 
  } 
  arg2 = (short *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)15; ++ii) arg1->extra1[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""extra1""' of type '""short [15]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_extra1_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","extra1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short *)(short *) ((arg1)->extra1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_short, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nint_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nint", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","nint", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->nint = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nint_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nint", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->nint);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nreal_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nreal", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","nreal", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->nreal = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nreal_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nreal", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->nreal);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_extra2_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","extra2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [5]","extra2", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)5; ++ii) arg1->extra2[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""extra2""' of type '""mrcImageParaTypeReal [5]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_extra2_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","extra2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->extra2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_imodStamp_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","imodStamp", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","imodStamp", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->imodStamp = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_imodStamp_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","imodStamp", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->imodStamp);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_imodFlags_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","imodFlags", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","imodFlags", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->imodFlags = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_imodFlags_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","imodFlags", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->imodFlags);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_idtype_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","idtype", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","idtype", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->idtype = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_idtype_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","idtype", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->idtype);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_lnes_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","lnes", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","lnes", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->lnes = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_lnes_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","lnes", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->lnes);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nd1_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nd1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","nd1", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->nd1 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nd1_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nd1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->nd1);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nd2_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nd2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","nd2", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->nd2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_nd2_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","nd2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->nd2);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_vd1_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","vd1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","vd1", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->vd1 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_vd1_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","vd1", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->vd1);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_vd2_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","vd2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","vd2", 2, argv[0] ));
  } 
  arg2 = (short)(val2);
  if (arg1) (arg1)->vd2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_vd2_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","vd2", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (short) ((arg1)->vd2);
  vresult = SWIG_From_short((short)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_tiltangles_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","tiltangles", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [6]","tiltangles", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)6; ++ii) arg1->tiltangles[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""tiltangles""' of type '""mrcImageParaTypeReal [6]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_tiltangles_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","tiltangles", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->tiltangles);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_xorg_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","xorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","xorg", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->xorg = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_xorg_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","xorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->xorg);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_yorg_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","yorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","yorg", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->yorg = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_yorg_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","yorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->yorg);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_zorg_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","zorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","zorg", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->zorg = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_zorg_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","zorg", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->zorg);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAP_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAP", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeCharacter [4]","MAP", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeCharacter *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)4; ++ii) arg1->MAP[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""MAP""' of type '""mrcImageParaTypeCharacter [4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MAP_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MAP", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeCharacter *)(mrcImageParaTypeCharacter *) ((arg1)->MAP);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MARCHST_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MARCHST", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","MARCHST", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->MARCHST = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_MARCHST_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","MARCHST", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->MARCHST);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_ARMS_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","ARMS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","ARMS", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->ARMS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_ARMS_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","ARMS", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->ARMS);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_LabelN_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","LabelN", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->LabelN = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_LabelN_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","LabelN", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->LabelN);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Label_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  char (*arg2)[(80)] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a__80___char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(10)][(80)]","Label", 2, argv[0] )); 
  } 
  arg2 = (char (*)[(80)])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(10); ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)(80); ++jj) arg1->Label[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Label""' of type '""char [(10)][(80)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_Label_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *arg1 = (struct _mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char (*result)[(80)] = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageHeaderIMOD *","Label", 1, self )); 
  }
  arg1 = (struct _mrcImageHeaderIMOD *)(argp1);
  result = (char (*)[(80)])(char (*)[(80)]) ((arg1)->Label);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a__80___char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap__mrcImageHeaderIMOD_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap__mrcImageHeaderIMOD_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p__mrcImageHeaderIMOD);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new__mrcImageHeaderIMOD(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageHeaderIMOD *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct _mrcImageHeaderIMOD *)calloc(1, sizeof(struct _mrcImageHeaderIMOD));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free__mrcImageHeaderIMOD(struct _mrcImageHeaderIMOD *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImageHeader;

SWIGINTERN VALUE
_wrap_mrcImageHeader_All_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  unsigned char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","All", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned char [(1024)]","All", 2, argv[0] )); 
  } 
  arg2 = (unsigned char *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024); ++ii) arg1->All[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""All""' of type '""unsigned char [(1024)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_All_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","All", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (unsigned char *)(unsigned char *) ((arg1)->All);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Int_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  mrcImageParaTypeInteger *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Int", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger [(1024)/4]","Int", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeInteger *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024)/4; ++ii) arg1->Int[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Int""' of type '""mrcImageParaTypeInteger [(1024)/4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Int_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Int", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeInteger *)(mrcImageParaTypeInteger *) ((arg1)->Int);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Real_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Real", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(1024)/4]","Real", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024)/4; ++ii) arg1->Real[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Real""' of type '""mrcImageParaTypeReal [(1024)/4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Real_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Real", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->Real);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Cont_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  _mrcImageHeader *arg2 = (_mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Cont", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "_mrcImageHeader *","Cont", 2, argv[0] )); 
  }
  arg2 = (_mrcImageHeader *)(argp2);
  if (arg1) (arg1)->Cont = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_Cont_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _mrcImageHeader *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","Cont", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (_mrcImageHeader *)& ((arg1)->Cont);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__mrcImageHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_ContCCP4_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  _mrcImageHeaderCCP4 *arg2 = (_mrcImageHeaderCCP4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","ContCCP4", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "_mrcImageHeaderCCP4 *","ContCCP4", 2, argv[0] )); 
  }
  arg2 = (_mrcImageHeaderCCP4 *)(argp2);
  if (arg1) (arg1)->ContCCP4 = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_ContCCP4_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _mrcImageHeaderCCP4 *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","ContCCP4", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (_mrcImageHeaderCCP4 *)& ((arg1)->ContCCP4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__mrcImageHeaderCCP4, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_ContIMOD_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  _mrcImageHeaderIMOD *arg2 = (_mrcImageHeaderIMOD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","ContIMOD", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "_mrcImageHeaderIMOD *","ContIMOD", 2, argv[0] )); 
  }
  arg2 = (_mrcImageHeaderIMOD *)(argp2);
  if (arg1) (arg1)->ContIMOD = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageHeader_ContIMOD_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *arg1 = (union mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _mrcImageHeaderIMOD *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageHeader *","ContIMOD", 1, self )); 
  }
  arg1 = (union mrcImageHeader *)(argp1);
  result = (_mrcImageHeaderIMOD *)& ((arg1)->ContIMOD);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__mrcImageHeaderIMOD, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageHeader(int argc, VALUE *argv, VALUE self) {
  union mrcImageHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (union mrcImageHeader *)calloc(1, sizeof(union mrcImageHeader));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageHeader(union mrcImageHeader *arg1) {
    free((char *) arg1);
}

static swig_class SwigClass_FEIextendedHeader;

SWIGINTERN VALUE
_wrap__FEIextendedHeader_aTilt_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","aTilt", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","aTilt", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->aTilt = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_aTilt_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","aTilt", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->aTilt);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_bTilt_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","bTilt", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","bTilt", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->bTilt = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_bTilt_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","bTilt", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->bTilt);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_xStage_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","xStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","xStage", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->xStage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_xStage_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","xStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->xStage);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_yStage_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","yStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","yStage", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->yStage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_yStage_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","yStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->yStage);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_zStage_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","zStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","zStage", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->zStage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_zStage_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","zStage", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->zStage);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_xShift_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","xShift", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","xShift", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->xShift = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_xShift_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","xShift", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->xShift);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_yShift_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","yShift", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","yShift", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->yShift = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_yShift_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","yShift", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->yShift);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_defocus_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","defocus", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","defocus", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->defocus = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_defocus_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","defocus", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->defocus);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_expTime_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","expTime", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","expTime", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->expTime = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_expTime_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","expTime", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->expTime);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_mean_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","mean", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mean", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->mean = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_mean_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","mean", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->mean);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_tiltAxis_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","tiltAxis", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","tiltAxis", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->tiltAxis = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_tiltAxis_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","tiltAxis", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->tiltAxis);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_pixelSize_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","pixelSize", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","pixelSize", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->pixelSize = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_pixelSize_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","pixelSize", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->pixelSize);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_magnification_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","magnification", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","magnification", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->magnification = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_magnification_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","magnification", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->magnification);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_ht_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","ht", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","ht", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->ht = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_ht_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","ht", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->ht);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_binning_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","binning", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","binning", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->binning = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_binning_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","binning", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->binning);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_appliedDefocus_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","appliedDefocus", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","appliedDefocus", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->appliedDefocus = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_appliedDefocus_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","appliedDefocus", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->appliedDefocus);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_reminder_set(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","reminder", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(128)/4-16]","reminder", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(128)/4-16; ++ii) arg1->reminder[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""reminder""' of type '""mrcImageParaTypeReal [(128)/4-16]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__FEIextendedHeader_reminder_get(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *arg1 = (struct _FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _FEIextendedHeader *","reminder", 1, self )); 
  }
  arg1 = (struct _FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->reminder);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap__FEIextendedHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap__FEIextendedHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p__FEIextendedHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new__FEIextendedHeader(int argc, VALUE *argv, VALUE self) {
  struct _FEIextendedHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct _FEIextendedHeader *)calloc(1, sizeof(struct _FEIextendedHeader));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free__FEIextendedHeader(struct _FEIextendedHeader *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassFEIextendedHeader;

SWIGINTERN VALUE
_wrap_FEIextendedHeader_Real_set(int argc, VALUE *argv, VALUE self) {
  union FEIextendedHeader *arg1 = (union FEIextendedHeader *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union FEIextendedHeader *","Real", 1, self )); 
  }
  arg1 = (union FEIextendedHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(128)/4]","Real", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(128)/4; ++ii) arg1->Real[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Real""' of type '""mrcImageParaTypeReal [(128)/4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FEIextendedHeader_Real_get(int argc, VALUE *argv, VALUE self) {
  union FEIextendedHeader *arg1 = (union FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union FEIextendedHeader *","Real", 1, self )); 
  }
  arg1 = (union FEIextendedHeader *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->Real);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FEIextendedHeader_Cont_set(int argc, VALUE *argv, VALUE self) {
  union FEIextendedHeader *arg1 = (union FEIextendedHeader *) 0 ;
  _FEIextendedHeader *arg2 = (_FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union FEIextendedHeader *","Cont", 1, self )); 
  }
  arg1 = (union FEIextendedHeader *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "_FEIextendedHeader *","Cont", 2, argv[0] )); 
  }
  arg2 = (_FEIextendedHeader *)(argp2);
  if (arg1) (arg1)->Cont = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FEIextendedHeader_Cont_get(int argc, VALUE *argv, VALUE self) {
  union FEIextendedHeader *arg1 = (union FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _FEIextendedHeader *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FEIextendedHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union FEIextendedHeader *","Cont", 1, self )); 
  }
  arg1 = (union FEIextendedHeader *)(argp1);
  result = (_FEIextendedHeader *)& ((arg1)->Cont);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__FEIextendedHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FEIextendedHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FEIextendedHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FEIextendedHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FEIextendedHeader(int argc, VALUE *argv, VALUE self) {
  union FEIextendedHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (union FEIextendedHeader *)calloc(1, sizeof(union FEIextendedHeader));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FEIextendedHeader(union FEIextendedHeader *arg1) {
    free((char *) arg1);
}

static swig_class SwigClass_mrcImageTailer;

SWIGINTERN VALUE
_wrap__mrcImageTailer_Code_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Code", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [4]","Code", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->Code,arg2,4*sizeof(char));
  else memset(arg1->Code,0,4*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Code_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Code", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (char *)(char *) ((arg1)->Code);
  {
    size_t size = 4;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Mode_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","Mode", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->Mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Mode_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Mode", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->Mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_EulerAngleMode_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","EulerAngleMode", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [4]","EulerAngleMode", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->EulerAngleMode,arg2,4*sizeof(char));
  else memset(arg1->EulerAngleMode,0,4*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_EulerAngleMode_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","EulerAngleMode", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (char *)(char *) ((arg1)->EulerAngleMode);
  {
    size_t size = 4;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot1_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot1", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Rot1", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Rot1 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot1_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot1", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Rot1);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot2_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot2", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Rot2", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Rot2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot2_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot2", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Rot2);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot3_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot3", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","Rot3", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->Rot3 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Rot3_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Rot3", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->Rot3);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Mirror_set(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Mirror", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","Mirror", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->Mirror = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap__mrcImageTailer_Mirror_get(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *arg1 = (struct _mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct _mrcImageTailer *","Mirror", 1, self )); 
  }
  arg1 = (struct _mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->Mirror);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap__mrcImageTailer_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap__mrcImageTailer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p__mrcImageTailer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new__mrcImageTailer(int argc, VALUE *argv, VALUE self) {
  struct _mrcImageTailer *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct _mrcImageTailer *)calloc(1, sizeof(struct _mrcImageTailer));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free__mrcImageTailer(struct _mrcImageTailer *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImageTailer;

SWIGINTERN VALUE
_wrap_mrcImageTailer_All_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  unsigned char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","All", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned char [(1024)]","All", 2, argv[0] )); 
  } 
  arg2 = (unsigned char *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024); ++ii) arg1->All[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""All""' of type '""unsigned char [(1024)]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_All_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","All", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  result = (unsigned char *)(unsigned char *) ((arg1)->All);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Int_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  mrcImageParaTypeInteger *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Int", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger [(1024)/4]","Int", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeInteger *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024)/4; ++ii) arg1->Int[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Int""' of type '""mrcImageParaTypeInteger [(1024)/4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Int_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Int", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeInteger *)(mrcImageParaTypeInteger *) ((arg1)->Int);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Real_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  mrcImageParaTypeReal *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Real", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal [(1024)/4]","Real", 2, argv[0] )); 
  } 
  arg2 = (mrcImageParaTypeReal *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)(1024)/4; ++ii) arg1->Real[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Real""' of type '""mrcImageParaTypeReal [(1024)/4]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Real_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Real", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  result = (mrcImageParaTypeReal *)(mrcImageParaTypeReal *) ((arg1)->Real);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Cont_set(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  _mrcImageTailer *arg2 = (_mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Cont", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "_mrcImageTailer *","Cont", 2, argv[0] )); 
  }
  arg2 = (_mrcImageTailer *)(argp2);
  if (arg1) (arg1)->Cont = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageTailer_Cont_get(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *arg1 = (union mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _mrcImageTailer *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "union mrcImageTailer *","Cont", 1, self )); 
  }
  arg1 = (union mrcImageTailer *)(argp1);
  result = (_mrcImageTailer *)& ((arg1)->Cont);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__mrcImageTailer, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageTailer_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageTailer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageTailer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageTailer(int argc, VALUE *argv, VALUE self) {
  union mrcImageTailer *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (union mrcImageTailer *)calloc(1, sizeof(union mrcImageTailer));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageTailer(union mrcImageTailer *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImage;

SWIGINTERN VALUE
_wrap_mrcImage_Header_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageHeader *arg2 = (mrcImageHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Header", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageHeader *","Header", 2, argv[0] )); 
  }
  arg2 = (mrcImageHeader *)(argp2);
  if (arg1) (arg1)->Header = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_Header_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageHeader *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Header", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageHeader *)& ((arg1)->Header);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BytePerImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BytePerImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","BytePerImage", 2, argv[0] ));
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->BytePerImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BytePerImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BytePerImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result =  ((arg1)->BytePerImage);
  vresult = SWIG_From_size_t((size_t)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BytePerBand_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BytePerBand", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","BytePerBand", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->BytePerBand = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BytePerBand_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BytePerBand", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->BytePerBand);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BandPerPixel_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BandPerPixel", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","BandPerPixel", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->BandPerPixel = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_BandPerPixel_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","BandPerPixel", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->BandPerPixel);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_PixelPerImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","PixelPerImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","PixelPerImage", 2, argv[0] ));
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->PixelPerImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_PixelPerImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","PixelPerImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result =  ((arg1)->PixelPerImage);
  vresult = SWIG_From_size_t((size_t)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_status_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcStatusType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","status", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcStatusType","status", 2, argv[0] ));
  } 
  arg2 = (mrcStatusType)(val2);
  if (arg1) (arg1)->status = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_status_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","status", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcStatusType) ((arg1)->status);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_Image_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Image", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","Image", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->Image) free((char*)arg1->Image);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->Image = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->Image = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_Image_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Image", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (char *) ((arg1)->Image);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageCharImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageCharImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned char *","ImageCharImage", 2, argv[0] )); 
  }
  arg2 = (unsigned char *)(argp2);
  if (arg1) (arg1)->ImageCharImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageCharImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageCharImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (unsigned char *) ((arg1)->ImageCharImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageShortImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageShortImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_short, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned short *","ImageShortImage", 2, argv[0] )); 
  }
  arg2 = (unsigned short *)(argp2);
  if (arg1) (arg1)->ImageShortImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageShortImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageShortImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (unsigned short *) ((arg1)->ImageShortImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageLongImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  long *arg2 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageLongImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_long, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "long *","ImageLongImage", 2, argv[0] )); 
  }
  arg2 = (long *)(argp2);
  if (arg1) (arg1)->ImageLongImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageLongImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageLongImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (long *) ((arg1)->ImageLongImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageULongImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  unsigned long *arg2 = (unsigned long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageULongImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_unsigned_long, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned long *","ImageULongImage", 2, argv[0] )); 
  }
  arg2 = (unsigned long *)(argp2);
  if (arg1) (arg1)->ImageULongImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageULongImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageULongImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (unsigned long *) ((arg1)->ImageULongImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_long, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageFloatImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageFloatImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float *","ImageFloatImage", 2, argv[0] )); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->ImageFloatImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageFloatImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageFloatImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (float *) ((arg1)->ImageFloatImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageDoubleImage_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageDoubleImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","ImageDoubleImage", 2, argv[0] )); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->ImageDoubleImage = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageDoubleImage_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageDoubleImage", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (double *) ((arg1)->ImageDoubleImage);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_Tailer_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageTailer *arg2 = (mrcImageTailer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Tailer", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageTailer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageTailer *","Tailer", 2, argv[0] )); 
  }
  arg2 = (mrcImageTailer *)(argp2);
  if (arg1) (arg1)->Tailer = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_Tailer_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageTailer *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","Tailer", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageTailer *) ((arg1)->Tailer);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageTailer, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_numTailer_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","numTailer", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","numTailer", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->numTailer = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_numTailer_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","numTailer", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->numTailer);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_FEIHeader_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  FEIextendedHeader *arg2 = (FEIextendedHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","FEIHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FEIextendedHeader, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FEIextendedHeader *","FEIHeader", 2, argv[0] )); 
  }
  arg2 = (FEIextendedHeader *)(argp2);
  if (arg1) (arg1)->FEIHeader = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_FEIHeader_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FEIextendedHeader *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","FEIHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (FEIextendedHeader *) ((arg1)->FEIHeader);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FEIextendedHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_numFEIHeader_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","numFEIHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","numFEIHeader", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->numFEIHeader = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_numFEIHeader_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","numFEIHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->numFEIHeader);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_dummyHeader_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","dummyHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","dummyHeader", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->dummyHeader) free((char*)arg1->dummyHeader);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->dummyHeader = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->dummyHeader = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_dummyHeader_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","dummyHeader", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (char *) ((arg1)->dummyHeader);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_dummyHeaderByte_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","dummyHeaderByte", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","dummyHeaderByte", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->dummyHeaderByte = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_dummyHeaderByte_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","dummyHeaderByte", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->dummyHeaderByte);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagByteSwap_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagByteSwap", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","flagByteSwap", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->flagByteSwap = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagByteSwap_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagByteSwap", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->flagByteSwap);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagCCP4_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagCCP4", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","flagCCP4", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->flagCCP4 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagCCP4_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagCCP4", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->flagCCP4);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageOffset_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageOffset", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","ImageOffset", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  if (arg1) (arg1)->ImageOffset = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_ImageOffset_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","ImageOffset", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageParaTypeInteger) ((arg1)->ImageOffset);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_SymmetryOperator_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  mrcImageSymmetryOperator *arg2 = (mrcImageSymmetryOperator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","SymmetryOperator", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageSymmetryOperator *","SymmetryOperator", 2, argv[0] ));
  }
  arg2 = (mrcImageSymmetryOperator *)(buf2);
  if (arg1->SymmetryOperator) free((char*)arg1->SymmetryOperator);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->SymmetryOperator = (mrcImageSymmetryOperator *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->SymmetryOperator = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_SymmetryOperator_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageSymmetryOperator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","SymmetryOperator", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (mrcImageSymmetryOperator *) ((arg1)->SymmetryOperator);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagSigned_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagSigned", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagSigned", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagSigned = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImage_flagSigned_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *arg1 = (struct mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImage *","flagSigned", 1, self )); 
  }
  arg1 = (struct mrcImage *)(argp1);
  result = (int) ((arg1)->flagSigned);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImage_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImage(int argc, VALUE *argv, VALUE self) {
  struct mrcImage *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImage *)calloc(1, sizeof(struct mrcImage));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImage(struct mrcImage *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImagePyramidList;

SWIGINTERN VALUE
_wrap_mrcImagePyramidList_mrc_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","mrc", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrc", 2, argv[0] )); 
  }
  arg2 = (mrcImage *)(argp2);
  if (arg1) (arg1)->mrc = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramidList_mrc_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImage *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","mrc", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  result = (mrcImage *)& ((arg1)->mrc);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImage, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramidList_up_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","up", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","up", 2, argv[0] )); 
  }
  arg2 = (mrcImage *)(argp2);
  if (arg1) (arg1)->up = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramidList_up_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImage *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","up", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  result = (mrcImage *) ((arg1)->up);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImage, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramidList_down_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","down", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","down", 2, argv[0] )); 
  }
  arg2 = (mrcImage *)(argp2);
  if (arg1) (arg1)->down = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramidList_down_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *arg1 = (struct mrcImagePyramidList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImage *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramidList *","down", 1, self )); 
  }
  arg1 = (struct mrcImagePyramidList *)(argp1);
  result = (mrcImage *) ((arg1)->down);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImage, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImagePyramidList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImagePyramidList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImagePyramidList);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImagePyramidList(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramidList *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImagePyramidList *)calloc(1, sizeof(struct mrcImagePyramidList));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImagePyramidList(struct mrcImagePyramidList *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImagePyramid;

SWIGINTERN VALUE
_wrap_mrcImagePyramid_top_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramid *arg1 = (struct mrcImagePyramid *) 0 ;
  mrcImagePyramidList *arg2 = (mrcImagePyramidList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramid, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramid *","top", 1, self )); 
  }
  arg1 = (struct mrcImagePyramid *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImagePyramidList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImagePyramidList *","top", 2, argv[0] )); 
  }
  arg2 = (mrcImagePyramidList *)(argp2);
  if (arg1) (arg1)->top = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramid_top_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramid *arg1 = (struct mrcImagePyramid *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImagePyramidList *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramid, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramid *","top", 1, self )); 
  }
  arg1 = (struct mrcImagePyramid *)(argp1);
  result = (mrcImagePyramidList *) ((arg1)->top);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramid_current_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramid *arg1 = (struct mrcImagePyramid *) 0 ;
  mrcImagePyramidList *arg2 = (mrcImagePyramidList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramid, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramid *","current", 1, self )); 
  }
  arg1 = (struct mrcImagePyramid *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImagePyramidList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImagePyramidList *","current", 2, argv[0] )); 
  }
  arg2 = (mrcImagePyramidList *)(argp2);
  if (arg1) (arg1)->current = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImagePyramid_current_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramid *arg1 = (struct mrcImagePyramid *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImagePyramidList *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImagePyramid, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImagePyramid *","current", 1, self )); 
  }
  arg1 = (struct mrcImagePyramid *)(argp1);
  result = (mrcImagePyramidList *) ((arg1)->current);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImagePyramidList, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImagePyramid_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImagePyramid_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImagePyramid);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImagePyramid(int argc, VALUE *argv, VALUE self) {
  struct mrcImagePyramid *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImagePyramid *)calloc(1, sizeof(struct mrcImagePyramid));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImagePyramid(struct mrcImagePyramid *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassMrcImageInformation;

SWIGINTERN VALUE
_wrap_mrcImageInformation_mean_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","mean", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","mean", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mean = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_mean_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","mean", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->mean);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_rootMeanSquare_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","rootMeanSquare", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","rootMeanSquare", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->rootMeanSquare = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_rootMeanSquare_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","rootMeanSquare", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->rootMeanSquare);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfSphereSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","meanOfSphereSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->meanOfSphereSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfSphereSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->meanOfSphereSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfSphereSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sdOfSphereSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sdOfSphereSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfSphereSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sdOfSphereSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfSphereSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","seOfSphereSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->seOfSphereSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfSphereSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfSphereSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->seOfSphereSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfCylinderSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","meanOfCylinderSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->meanOfCylinderSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfCylinderSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->meanOfCylinderSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfCylinderSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sdOfCylinderSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sdOfCylinderSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfCylinderSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sdOfCylinderSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfCylinderSurface_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","seOfCylinderSurface", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->seOfCylinderSurface = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfCylinderSurface_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfCylinderSurface", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->seOfCylinderSurface);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfEdge_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","meanOfEdge", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->meanOfEdge = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfEdge_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->meanOfEdge);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfEdge_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sdOfEdge", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sdOfEdge = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfEdge_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sdOfEdge);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfEdge_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","seOfEdge", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->seOfEdge = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfEdge_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfEdge", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->seOfEdge);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_max_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","max", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","max", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->max = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_max_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","max", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->max);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxCoord_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxCoord", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","maxCoord", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->maxCoord = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxCoord_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxCoord", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->maxCoord);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_min_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","min", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","min", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->min = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_min_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","min", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->min);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minCoord_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minCoord", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","minCoord", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->minCoord = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minCoord_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minCoord", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->minCoord);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sd_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sd", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sd", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sd = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sd_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sd", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sd);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_se_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","se", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","se", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->se = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_se_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","se", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->se);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_rmax_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","rmax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","rmax", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->rmax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_rmax_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","rmax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->rmax);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagrmax_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagrmax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","flagrmax", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->flagrmax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagrmax_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagrmax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (long) ((arg1)->flagrmax);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_RMS_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","RMS", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","RMS", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->RMS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_RMS_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","RMS", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->RMS);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_mode_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","mode", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","mode", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_mode_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","mode", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (int) ((arg1)->mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfAllAxis_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfAllAxis", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","sdOfAllAxis", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->sdOfAllAxis = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfAllAxis_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfAllAxis", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->sdOfAllAxis);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_aveOfAllAxis_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","aveOfAllAxis", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","aveOfAllAxis", 2, argv[0] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  if (arg1) (arg1)->aveOfAllAxis = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_aveOfAllAxis_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeRealCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","aveOfAllAxis", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (mrcImageParaTypeRealCoord *)& ((arg1)->aveOfAllAxis);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","thresOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->thresOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->thresOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","meanOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->meanOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->meanOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sdOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sdOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sdOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","seOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->seOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->seOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","maxOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->maxOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->maxOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","minOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->minOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->minOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_medianOfHighValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","medianOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","medianOfHighValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->medianOfHighValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_medianOfHighValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","medianOfHighValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->medianOfHighValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","thresOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->thresOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->thresOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","meanOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->meanOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_meanOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","meanOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->meanOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sdOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sdOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_sdOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","sdOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->sdOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","seOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->seOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_seOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","seOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->seOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","maxOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->maxOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_maxOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","maxOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->maxOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","minOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->minOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_minOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","minOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->minOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_medianOfLowValueArea_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","medianOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","medianOfLowValueArea", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->medianOfLowValueArea = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_medianOfLowValueArea_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","medianOfLowValueArea", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->medianOfLowValueArea);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagXrange_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagXrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagXrange", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagXrange = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagXrange_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagXrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (int) ((arg1)->flagXrange);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagYrange_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagYrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagYrange", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagYrange = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagYrange_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagYrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (int) ((arg1)->flagYrange);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagZrange_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagZrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagZrange", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagZrange = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagZrange_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagZrange", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (int) ((arg1)->flagZrange);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_XrangeMin_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","XrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","XrangeMin", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->XrangeMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_XrangeMin_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","XrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->XrangeMin);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_XrangeMax_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","XrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","XrangeMax", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->XrangeMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_XrangeMax_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","XrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->XrangeMax);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_YrangeMin_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","YrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","YrangeMin", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->YrangeMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_YrangeMin_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","YrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->YrangeMin);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_YrangeMax_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","YrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","YrangeMax", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->YrangeMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_YrangeMax_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","YrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->YrangeMax);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_ZrangeMin_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","ZrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","ZrangeMin", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->ZrangeMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_ZrangeMin_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","ZrangeMin", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->ZrangeMin);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_ZrangeMax_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","ZrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","ZrangeMax", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->ZrangeMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_ZrangeMax_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","ZrangeMax", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->ZrangeMax);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagCentre_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagCentre", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagCentre", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagCentre = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_flagCentre_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","flagCentre", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (int) ((arg1)->flagCentre);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreX_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreX", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","CentreX", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->CentreX = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreX_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreX", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->CentreX);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreY_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreY", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","CentreY", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->CentreY = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreY_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreY", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->CentreY);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreZ_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreZ", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","CentreZ", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->CentreZ = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_CentreZ_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","CentreZ", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->CentreZ);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresHigh_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresHigh", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","thresHigh", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->thresHigh = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresHigh_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresHigh", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->thresHigh);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresLow_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresLow", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","thresLow", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->thresLow = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInformation_thresLow_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *arg1 = (struct mrcImageInformation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageInformation *","thresLow", 1, self )); 
  }
  arg1 = (struct mrcImageInformation *)(argp1);
  result = (double) ((arg1)->thresLow);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageInformation_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageInformation_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageInformation);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageInformation(int argc, VALUE *argv, VALUE self) {
  struct mrcImageInformation *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImageInformation *)calloc(1, sizeof(struct mrcImageInformation));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageInformation(struct mrcImageInformation *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageSmoothingInfo;

SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sx_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","sx", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->sx = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sx_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->sx);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sy_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","sy", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->sy = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sy_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->sy);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sz_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  mrcImageParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","sz", 2, argv[0] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  if (arg1) (arg1)->sz = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sz_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcImageParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  result = (mrcImageParaTypeReal) ((arg1)->sz);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sigma_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sigma", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","sigma", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->sigma = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_sigma_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *arg1 = (struct lmrcImageSmoothingInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageSmoothingInfo *","sigma", 1, self )); 
  }
  arg1 = (struct lmrcImageSmoothingInfo *)(argp1);
  result = (double) ((arg1)->sigma);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageSmoothingInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageSmoothingInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageSmoothingInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageSmoothingInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageSmoothingInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageSmoothingInfo *)calloc(1, sizeof(struct lmrcImageSmoothingInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageSmoothingInfo(struct lmrcImageSmoothingInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageCVEInfo;

SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sx_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sx", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sx = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sx_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  result = (long) ((arg1)->sx);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sy_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sy", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sy = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sy_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  result = (long) ((arg1)->sy);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sz_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sz", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sz = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_sz_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *arg1 = (struct lmrcImageCVEInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCVEInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageCVEInfo *)(argp1);
  result = (long) ((arg1)->sz);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageCVEInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageCVEInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageCVEInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageCVEInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCVEInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageCVEInfo *)calloc(1, sizeof(struct lmrcImageCVEInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageCVEInfo(struct lmrcImageCVEInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageTfunctionInfo;

SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sx_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sx", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sx = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sx_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sx", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  result = (long) ((arg1)->sx);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sy_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sy", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sy = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sy_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sy", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  result = (long) ((arg1)->sy);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sz_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","sz", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->sz = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_sz_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *arg1 = (struct lmrcImageTfunctionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageTfunctionInfo *","sz", 1, self )); 
  }
  arg1 = (struct lmrcImageTfunctionInfo *)(argp1);
  result = (long) ((arg1)->sz);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageTfunctionInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageTfunctionInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageTfunctionInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageTfunctionInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageTfunctionInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageTfunctionInfo *)calloc(1, sizeof(struct lmrcImageTfunctionInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageTfunctionInfo(struct lmrcImageTfunctionInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageHighlightInfo;

SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_Bias_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","Bias", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","Bias", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->Bias = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_Bias_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","Bias", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  result = (float) ((arg1)->Bias);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_Grad_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","Grad", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","Grad", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->Grad = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_Grad_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *arg1 = (struct lmrcImageHighlightInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighlightInfo *","Grad", 1, self )); 
  }
  arg1 = (struct lmrcImageHighlightInfo *)(argp1);
  result = (float) ((arg1)->Grad);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageHighlightInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageHighlightInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageHighlightInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageHighlightInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighlightInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageHighlightInfo *)calloc(1, sizeof(struct lmrcImageHighlightInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageHighlightInfo(struct lmrcImageHighlightInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageLowPassFilterInfo;

SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_hvp_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","hvp", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","hvp", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hvp = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_hvp_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","hvp", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  result = (float) ((arg1)->hvp);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_width_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","width", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","width", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->width = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_width_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *arg1 = (struct lmrcImageLowPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageLowPassFilterInfo *","width", 1, self )); 
  }
  arg1 = (struct lmrcImageLowPassFilterInfo *)(argp1);
  result = (float) ((arg1)->width);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilterInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageLowPassFilterInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageLowPassFilterInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageLowPassFilterInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageLowPassFilterInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageLowPassFilterInfo *)calloc(1, sizeof(struct lmrcImageLowPassFilterInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageLowPassFilterInfo(struct lmrcImageLowPassFilterInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageHighPassFilterInfo;

SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_hvp_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","hvp", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","hvp", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hvp = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_hvp_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","hvp", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  result = (float) ((arg1)->hvp);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_width_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","width", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","width", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->width = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_width_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","width", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  result = (float) ((arg1)->width);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_pathWindowLow_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","pathWindowLow", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","pathWindowLow", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->pathWindowLow = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_pathWindowLow_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","pathWindowLow", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  result = (float) ((arg1)->pathWindowLow);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_pathWindowHigh_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","pathWindowHigh", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","pathWindowHigh", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->pathWindowHigh = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_pathWindowHigh_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *arg1 = (struct lmrcImageHighPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageHighPassFilterInfo *","pathWindowHigh", 1, self )); 
  }
  arg1 = (struct lmrcImageHighPassFilterInfo *)(argp1);
  result = (float) ((arg1)->pathWindowHigh);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilterInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageHighPassFilterInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageHighPassFilterInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageHighPassFilterInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageHighPassFilterInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageHighPassFilterInfo *)calloc(1, sizeof(struct lmrcImageHighPassFilterInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageHighPassFilterInfo(struct lmrcImageHighPassFilterInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageBandPassFilterInfo;

SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_hvl_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","hvl", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","hvl", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hvl = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_hvl_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","hvl", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (float) ((arg1)->hvl);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_hvh_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","hvh", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","hvh", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hvh = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_hvh_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","hvh", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (float) ((arg1)->hvh);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_wl_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","wl", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","wl", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->wl = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_wl_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","wl", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (float) ((arg1)->wl);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_wh_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","wh", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","wh", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->wh = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_wh_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","wh", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (float) ((arg1)->wh);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_flagLowWeight_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","flagLowWeight", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagLowWeight", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagLowWeight = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_flagLowWeight_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","flagLowWeight", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (int) ((arg1)->flagLowWeight);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_lowWeight_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","lowWeight", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lowWeight", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->lowWeight = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_lowWeight_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *arg1 = (struct lmrcImageBandPassFilterInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageBandPassFilterInfo *","lowWeight", 1, self )); 
  }
  arg1 = (struct lmrcImageBandPassFilterInfo *)(argp1);
  result = (double) ((arg1)->lowWeight);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilterInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageBandPassFilterInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageBandPassFilterInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageBandPassFilterInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageBandPassFilterInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageBandPassFilterInfo *)calloc(1, sizeof(struct lmrcImageBandPassFilterInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageBandPassFilterInfo(struct lmrcImageBandPassFilterInfo *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_mrcInit(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcInit", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcInit", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  result = (mrcStatusType)mrcInit(arg1,arg2);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcDefaultHeaderValueSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcDefaultHeaderValueSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (mrcStatusType)mrcDefaultHeaderValueSet(arg1);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcDefaultHeaderValueSetOnlyFixedValue(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcDefaultHeaderValueSetOnlyFixedValue", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (mrcStatusType)mrcDefaultHeaderValueSetOnlyFixedValue(arg1);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHiddenDataSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHiddenDataSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mrcHiddenDataSet", 2, argv[1] ));
  } 
  arg2 = (long)(val2);
  result = (mrcStatusType)mrcHiddenDataSet(arg1,arg2);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFree(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageFree", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageFree", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  mrcImageFree(arg1,arg2);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerInit(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerInit", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mrcTailerInit", 2, argv[1] ));
  } 
  arg2 = (long)(val2);
  mrcTailerInit(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerCopy(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerCopy", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerCopy", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","mrcTailerCopy", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  mrcTailerCopy(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileReadGeneral(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileReadGeneral", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileReadGeneral", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileReadGeneral", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char *","mrcFileReadGeneral", 4, argv[3] ));
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","mrcFileReadGeneral", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  result = (mrcStatusType)mrcFileReadGeneral(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageReadGeneral(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageReadGeneral", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageReadGeneral", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcImageReadGeneral", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char *","mrcImageReadGeneral", 4, argv[3] ));
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","mrcImageReadGeneral", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  result = (mrcStatusType)mrcImageReadGeneral(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHeaderReadGeneral(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHeaderReadGeneral", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcHeaderReadGeneral", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcHeaderReadGeneral", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char *","mrcHeaderReadGeneral", 4, argv[3] ));
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","mrcHeaderReadGeneral", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  result = (mrcStatusType)mrcHeaderReadGeneral(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerReadGeneral(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerReadGeneral", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcTailerReadGeneral", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcTailerReadGeneral", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char *","mrcTailerReadGeneral", 4, argv[3] ));
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","mrcTailerReadGeneral", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  result = (mrcStatusType)mrcTailerReadGeneral(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileGeneralListPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","mrcFileGeneralListPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  result = (mrcStatusType)mrcFileGeneralListPrint(arg1);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileRead(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileRead", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileRead", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileRead", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcFileRead", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcFileRead(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageRead(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageRead", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageRead", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcImageRead", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageRead", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcImageRead(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHeaderRead(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHeaderRead", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcHeaderRead", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcHeaderRead", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcHeaderRead", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcHeaderRead(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerRead(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerRead", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcTailerRead", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcTailerRead", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcTailerRead", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcTailerRead(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileReadFEIextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileReadFEIextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileReadFEIextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileReadFEIextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcFileReadFEIextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcFileReadFEIextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageReadFEIextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageReadFEIextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageReadFEIextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcImageReadFEIextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageReadFEIextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcImageReadFEIextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHeaderReadFEIextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHeaderReadFEIextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcHeaderReadFEIextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcHeaderReadFEIextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcHeaderReadFEIextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcHeaderReadFEIextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerReadFEIextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerReadFEIextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcTailerReadFEIextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcTailerReadFEIextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcTailerReadFEIextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcTailerReadFEIextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileReadIMODextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileReadIMODextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileReadIMODextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileReadIMODextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcFileReadIMODextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcFileReadIMODextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageReadIMODextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageReadIMODextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageReadIMODextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcImageReadIMODextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageReadIMODextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcImageReadIMODextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHeaderReadIMODextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHeaderReadIMODextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcHeaderReadIMODextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcHeaderReadIMODextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcHeaderReadIMODextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcHeaderReadIMODextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerReadIMODextendedMRC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerReadIMODextendedMRC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcTailerReadIMODextendedMRC", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcTailerReadIMODextendedMRC", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcTailerReadIMODextendedMRC", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcTailerReadIMODextendedMRC(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageByteSwap(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageByteSwap", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mrcImageByteSwap", 2, argv[1] ));
  } 
  arg2 = (long)(val2);
  result = (int)mrcImageByteSwap(arg1,arg2);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileWrite(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileWrite", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileWrite", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileWrite", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcFileWrite", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcFileWrite(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageWrite(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageWrite", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcImageWrite", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcImageWrite", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageWrite", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcImageWrite(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcHeaderWrite(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcHeaderWrite", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcHeaderWrite", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcHeaderWrite", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcHeaderWrite", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcHeaderWrite(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcTailerWrite(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcTailerWrite", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcTailerWrite", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcTailerWrite", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcTailerWrite", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  result = (mrcStatusType)mrcTailerWrite(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcFileWriteLowerResolution(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcFileWriteLowerResolution", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcFileWriteLowerResolution", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcFileWriteLowerResolution", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcFileWriteLowerResolution", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  ecode5 = SWIG_AsVal_long(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","mrcFileWriteLowerResolution", 5, argv[4] ));
  } 
  arg5 = (long)(val5);
  result = (mrcStatusType)mrcFileWriteLowerResolution(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageDataGetbyAU(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  double *arg5 = (double *) 0 ;
  mrcPixelDataType arg6 ;
  mrcPixelDataHowToGet arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageDataGetbyAU", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataGetbyAU", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataGetbyAU", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataGetbyAU", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double *","mrcImageDataGetbyAU", 5, argv[4] )); 
  }
  arg5 = (double *)(argp5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataType","mrcImageDataGetbyAU", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataType)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","mrcImageDataGetbyAU", 7, argv[6] ));
  } 
  arg7 = (mrcPixelDataHowToGet)(val7);
  result = (double)mrcImageDataGetbyAU(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataGet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  double *arg5 = (double *) 0 ;
  mrcPixelDataType arg6 ;
  mrcPixelDataHowToGet arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataGet", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataGet", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataGet", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double *","mrcPixelDataGet", 5, argv[4] )); 
  }
  arg5 = (double *)(argp5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataType","mrcPixelDataGet", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataType)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","mrcPixelDataGet", 7, argv[6] ));
  } 
  arg7 = (mrcPixelDataHowToGet)(val7);
  result = (double)mrcPixelDataGet(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelsDataGet(int argc, VALUE *argv, VALUE self) {
  float *arg1 = (float *) 0 ;
  mrcImageParaTypeRealCoord *arg2 = (mrcImageParaTypeRealCoord *) 0 ;
  int arg3 ;
  mrcImage *arg4 = (mrcImage *) 0 ;
  mrcPixelDataType arg5 ;
  mrcPixelDataHowToGet arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float *","mrcPixelsDataGet", 1, argv[0] )); 
  }
  arg1 = (float *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImageParaTypeRealCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord *","mrcPixelsDataGet", 2, argv[1] )); 
  }
  arg2 = (mrcImageParaTypeRealCoord *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","mrcPixelsDataGet", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelsDataGet", 4, argv[3] )); 
  }
  arg4 = (mrcImage *)(argp4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcPixelDataType","mrcPixelsDataGet", 5, argv[4] ));
  } 
  arg5 = (mrcPixelDataType)(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","mrcPixelsDataGet", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataHowToGet)(val6);
  mrcPixelsDataGet(arg1,arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataGetbyMatrix3D(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  matrix3DParaTypeReal (*arg3)[4] ;
  mrcPixelDataHowToGet arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGetbyMatrix3D", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGetbyMatrix3D", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "float [4][4]","mrcPixelDataGetbyMatrix3D", 3, argv[2] )); 
  } 
  arg3 = (float (*)[4])(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","mrcPixelDataGetbyMatrix3D", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","mrcPixelDataGetbyMatrix3D", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  mrcPixelDataGetbyMatrix3D(arg1,arg2,(float (*)[4])arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataGetFloatImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGetFloatImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatImage", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatImage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatImage", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  result = (double)mrcPixelDataGetFloatImage(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataGetFloatFTRe(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGetFloatFTRe", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTRe", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTRe", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTRe", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  result = (double)mrcPixelDataGetFloatFTRe(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataGetFloatFTIm(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataGetFloatFTIm", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTIm", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTIm", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataGetFloatFTIm", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  result = (double)mrcPixelDataGetFloatFTIm(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcInfoSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  FILE *arg3 = (FILE *) 0 ;
  mrcImageParaTypeInteger arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcInfoSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FILE *","mrcInfoSet", 2, argv[1] )); 
  }
  arg2 = (FILE *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FILE *","mrcInfoSet", 3, argv[2] )); 
  }
  arg3 = (FILE *)(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcInfoSet", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  mrcInfoSet(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageDataSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  mrcImageParaTypeReal arg5 ;
  float arg6 ;
  mrcImageDataSetMode arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageDataSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcImageDataSet", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSet", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSet", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSet", 5, argv[4] ));
  } 
  arg5 = (mrcImageParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_float(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "float","mrcImageDataSet", 6, argv[5] ));
  } 
  arg6 = (float)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "mrcImageDataSetMode","mrcImageDataSet", 7, argv[6] ));
  } 
  arg7 = (mrcImageDataSetMode)(val7);
  mrcImageDataSet(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageDataSetbyAU(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  double arg5 ;
  mrcPixelDataType arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageDataSetbyAU", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSetbyAU", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSetbyAU", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageDataSetbyAU", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","mrcImageDataSetbyAU", 5, argv[4] ));
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataType","mrcImageDataSetbyAU", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataType)(val6);
  result = (double)mrcImageDataSetbyAU(arg1,arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  double arg5 ;
  mrcPixelDataType arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataSet", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataSet", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcPixelDataSet", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","mrcPixelDataSet", 5, argv[4] ));
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataType","mrcPixelDataSet", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataType)(val6);
  result = (double)mrcPixelDataSet(arg1,arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataSetFloatImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataSetFloatImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatImage", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatImage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatImage", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","mrcPixelDataSetFloatImage", 5, argv[4] ));
  } 
  arg5 = (double)(val5);
  mrcPixelDataSetFloatImage(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataSetFloatFTRe(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataSetFloatFTRe", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTRe", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTRe", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTRe", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","mrcPixelDataSetFloatFTRe", 5, argv[4] ));
  } 
  arg5 = (double)(val5);
  mrcPixelDataSetFloatFTRe(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcPixelDataSetFloatFTIm(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeInteger arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcPixelDataSetFloatFTIm", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTIm", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTIm", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcPixelDataSetFloatFTIm", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeInteger)(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","mrcPixelDataSetFloatFTIm", 5, argv[4] ));
  } 
  arg5 = (double)(val5);
  mrcPixelDataSetFloatFTIm(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcStatDataSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcStatDataSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcStatDataSet", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeInteger)(val2);
  mrcStatDataSet(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageXSection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXSection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXSection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageXSection", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  lmrcImageXSection(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageYSection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYSection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYSection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageYSection", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  lmrcImageYSection(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageXProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageXProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageYProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageYProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageZProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageZProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageZProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageZProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageXYProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXYProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageXYProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageXYProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageYZProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYZProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageYZProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageYZProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageZXProjection(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageZXProjection", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageZXProjection", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageZXProjection(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  unsigned long arg2 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","lmrcImageHistgram", 2, argv[1] ));
  } 
  arg2 = (unsigned long)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageHistgram(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram2(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  double arg2 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram2", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageHistgram2", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram2", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageHistgram2(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram5(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  unsigned long arg2 ;
  double arg3 ;
  double arg4 ;
  mrcImage *arg5 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram5", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","lmrcImageHistgram5", 2, argv[1] ));
  } 
  arg2 = (unsigned long)(val2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageHistgram5", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","lmrcImageHistgram5", 4, argv[3] ));
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram5", 5, argv[4] )); 
  }
  arg5 = (mrcImage *)(argp5);
  lmrcImageHistgram5(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram3(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  unsigned long arg2 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram3", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","lmrcImageHistgram3", 2, argv[1] ));
  } 
  arg2 = (unsigned long)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram3", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageHistgram3(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram4(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  double arg2 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram4", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageHistgram4", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram4", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageHistgram4(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHistgram6(int argc, VALUE *argv, VALUE self) {
  double **arg1 = (double **) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  mrcImage *arg5 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double **","lmrcImageHistgram6", 1, argv[0] )); 
  }
  arg1 = (double **)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageHistgram6", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageHistgram6", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","lmrcImageHistgram6", 4, argv[3] ));
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHistgram6", 5, argv[4] )); 
  }
  arg5 = (mrcImage *)(argp5);
  lmrcImageHistgram6(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageInformation(int argc, VALUE *argv, VALUE self) {
  mrcImageInformation *arg1 = (mrcImageInformation *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImageInformation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImageInformation *","lmrcImageInformation", 1, argv[0] )); 
  }
  arg1 = (mrcImageInformation *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageInformation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageInformation(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCopy(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeRealCoord arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCopy", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCopy", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_mrcImageParaTypeRealCoord,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord","lmrcImageCopy", 3, argv[2] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "mrcImageParaTypeRealCoord","lmrcImageCopy", 3, argv[2]));
    } else {
      arg3 = *((mrcImageParaTypeRealCoord *)(argp3));
    }
  }
  lmrcImageCopy(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IsFloatImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","IsFloatImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","IsFloatImage", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","IsFloatImage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  result = (int)IsFloatImage(arg1,arg2,arg3);
  vresult = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IsFloatFT(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","IsFloatFT", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","IsFloatFT", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","IsFloatFT", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  result = (int)IsFloatFT(arg1,arg2,arg3);
  vresult = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IsImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","IsImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","IsImage", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","IsImage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  result = (int)IsImage(arg1,arg2,arg3);
  vresult = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IsFT(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","IsFT", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","IsFT", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","IsFT", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  result = (int)IsFT(arg1,arg2,arg3);
  vresult = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IsFFT(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  char *arg2 = (char *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","IsFFT", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","IsFFT", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","IsFFT", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  result = (int)IsFFT(arg1,arg2,arg3);
  vresult = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageInfoSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  FILE *arg3 = (FILE *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageInfoSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FILE *","mrcImageInfoSet", 2, argv[1] )); 
  }
  arg2 = (FILE *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FILE *","mrcImageInfoSet", 3, argv[2] )); 
  }
  arg3 = (FILE *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageInfoSet", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  mrcImageInfoSet(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageDividedByImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageDividedByImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageDividedByImage", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageDividedByImage", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageDividedByImage(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImagetMapForZero(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagetMapForZero", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagetMapForZero", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagetMapForZero", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImagetMapForZero(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSN(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSN", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSN", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSN", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImageSN(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageDividedByReal(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageDividedByReal", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageDividedByReal", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  lmrcImageDividedByReal(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageDividedByRealForOnlyPositive(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageDividedByRealForOnlyPositive", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageDividedByRealForOnlyPositive", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  lmrcImageDividedByRealForOnlyPositive(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageAddedByReal(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageAddedByReal", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageAddedByReal", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  lmrcImageAddedByReal(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageStdDev(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdDev", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdDev", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdDev", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageStdDev", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageStdDev(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageStdErr(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdErr", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdErr", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStdErr", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageStdErr", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageStdErr(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageAdd(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  long *arg3 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageAdd", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageAdd", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "long *","lmrcImageAdd", 3, argv[2] )); 
  }
  arg3 = (long *)(argp3);
  lmrcImageAdd(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcSQRImageAdd(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  long *arg3 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcSQRImageAdd", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcSQRImageAdd", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "long *","lmrcSQRImageAdd", 3, argv[2] )); 
  }
  arg3 = (long *)(argp3);
  lmrcSQRImageAdd(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSquare(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSquare", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  lmrcImageSquare(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRoot(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRoot", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","lmrcImageRoot", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  lmrcImageRoot(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageAbs(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageAbs", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageAbs", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageAbs(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageConvolution(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageConvolution", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageConvolution", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageConvolution", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmrcImageConvolution", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmrcImageConvolution(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageToIntImage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageToIntImage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageToIntImage", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","lmrcImageToIntImage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  lmrcImageToIntImage(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lfft2d(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lfft2d", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lfft2d", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lfft2d(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFFT(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageFFT", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageFFT", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","lmrcImageFFT", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  lmrcImageFFT(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFFTFirstDimensionOnly(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageFFTFirstDimensionOnly", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageFFTFirstDimensionOnly", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","lmrcImageFFTFirstDimensionOnly", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  lmrcImageFFTFirstDimensionOnly(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFFTFGconj(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFGconj", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFGconj", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFGconj", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcFFTFGconj(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFFTFxG(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFxG", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFxG", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcFFTFxG", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcFFTFxG(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCorrelation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelation", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageCorrelation", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageCorrelation(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCorrelationModePrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImageCorrelationModePrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  lmrcImageCorrelationModePrint(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFFTCenterChange(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageFFTCenterChange", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmrcImageFFTCenterChange", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmrcImageFFTCenterChange(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImagePattersonFunctionCalc(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImage *arg3 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagePattersonFunctionCalc", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagePattersonFunctionCalc", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagePattersonFunctionCalc", 3, argv[2] )); 
  }
  arg3 = (mrcImage *)(argp3);
  lmrcImagePattersonFunctionCalc(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImagePattersonFunctionPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImagePattersonFunctionPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagePattersonFunctionPrint", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmrcImagePattersonFunctionPrint", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmrcImagePattersonFunctionPrint(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageGuinierFunctionPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImageGuinierFunctionPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageGuinierFunctionPrint", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmrcImageGuinierFunctionPrint", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmrcImageGuinierFunctionPrint(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCorrelationWithCTFCompensation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  ctfInfo *arg3 = (ctfInfo *) 0 ;
  mrcImage *arg4 = (mrcImage *) 0 ;
  ctfInfo *arg5 = (ctfInfo *) 0 ;
  long arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelationWithCTFCompensation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelationWithCTFCompensation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImageCorrelationWithCTFCompensation", 3, argv[2] )); 
  }
  arg3 = (ctfInfo *)(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCorrelationWithCTFCompensation", 4, argv[3] )); 
  }
  arg4 = (mrcImage *)(argp4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImageCorrelationWithCTFCompensation", 5, argv[4] )); 
  }
  arg5 = (ctfInfo *)(argp5);
  ecode6 = SWIG_AsVal_long(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "long","lmrcImageCorrelationWithCTFCompensation", 6, argv[5] ));
  } 
  arg6 = (long)(val6);
  lmrcImageCorrelationWithCTFCompensation(arg1,arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcError(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  mrcStatusType arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","mrcError", 1, argv[0] ));
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcError", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcError", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcStatusType","mrcError", 4, argv[3] ));
  } 
  arg4 = (mrcStatusType)(val4);
  result = (mrcStatusType)mrcError(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcErrorMsg(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  mrcStatusType arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  mrcStatusType result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","mrcErrorMsg", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","mrcErrorMsg", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char *","mrcErrorMsg", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char *","mrcErrorMsg", 4, argv[3] ));
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcStatusType","mrcErrorMsg", 5, argv[4] ));
  } 
  arg5 = (mrcStatusType)(val5);
  result = (mrcStatusType)mrcErrorMsg(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoXAxisMag(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoXAxisMag", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoXAxisMag(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoXAxisPhase(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoXAxisPhase", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoXAxisPhase(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoYAxisMag(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoYAxisMag", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoYAxisMag(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoYAxisPhase(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoYAxisPhase", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoYAxisPhase(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistribution(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistribution", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoScatteringAngularDistribution(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionAverage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionAverage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoScatteringAngularDistributionAverage(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionSD(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionSD", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoScatteringAngularDistributionSD(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoSpacing(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  floatVector *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoSpacing", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  result = (floatVector *)lmrcFSInfoSpacing(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionDivisionAverage(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeInteger arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  floatVector **result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionDivisionAverage", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionAverage", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","lmrcFSInfoScatteringAngularDistributionDivisionAverage", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmrcFSInfoScatteringAngularDistributionDivisionAverage", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  result = (floatVector **)lmrcFSInfoScatteringAngularDistributionDivisionAverage(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionDivisionSD(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeInteger arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  floatVector **result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionDivisionSD", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionSD", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","lmrcFSInfoScatteringAngularDistributionDivisionSD", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmrcFSInfoScatteringAngularDistributionDivisionSD", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  result = (floatVector **)lmrcFSInfoScatteringAngularDistributionDivisionSD(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeReal arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  floatVector **result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  result = (floatVector **)lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcFSInfoScatteringAngularDistributionDivisionSDDelR(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg2 ;
  mrcImageParaTypeInteger arg3 ;
  mrcImageParaTypeReal arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  floatVector **result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", 2, argv[1] ));
  } 
  arg2 = (mrcImageParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  result = (floatVector **)lmrcFSInfoScatteringAngularDistributionDivisionSDDelR(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_floatVector, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCheckSameSize(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCheckSameSize", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCheckSameSize", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageCheckSameSize(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCheckFFT(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCheckFFT", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCheckFFT", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  lmrcImageCheckFFT(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothingModeInfo(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImageSmoothingModeInfo", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  lmrcImageSmoothingModeInfo(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageSmoothing(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageSmoothingInfo *arg3 = (lmrcImageSmoothingInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSmoothing", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageSmoothing", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageSmoothingInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageSmoothingInfo *","lmrcImageSmoothing", 3, argv[2] )); 
  }
  arg3 = (lmrcImageSmoothingInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageSmoothing", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageSmoothing(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCVE(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageCVEInfo *arg3 = (lmrcImageCVEInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCVE", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCVE", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageCVEInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageCVEInfo *","lmrcImageCVE", 3, argv[2] )); 
  }
  arg3 = (lmrcImageCVEInfo *)(argp3);
  lmrcImageCVE(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageTfunction(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageTfunctionInfo *arg3 = (lmrcImageTfunctionInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageTfunction", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageTfunction", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageTfunctionInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageTfunctionInfo *","lmrcImageTfunction", 3, argv[2] )); 
  }
  arg3 = (lmrcImageTfunctionInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageTfunction", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageTfunction(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlightingInfoPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImageHighlightingInfoPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  lmrcImageHighlightingInfoPrint(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighlighting(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageHighlightInfo *arg3 = (lmrcImageHighlightInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHighlighting", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHighlighting", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageHighlightInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageHighlightInfo *","lmrcImageHighlighting", 3, argv[2] )); 
  }
  arg3 = (lmrcImageHighlightInfo *)(argp3);
  lmrcImageHighlighting(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageLowPassFilter(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageLowPassFilterInfo *arg3 = (lmrcImageLowPassFilterInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageLowPassFilter", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageLowPassFilter", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageLowPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageLowPassFilterInfo *","lmrcImageLowPassFilter", 3, argv[2] )); 
  }
  arg3 = (lmrcImageLowPassFilterInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageLowPassFilter", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageLowPassFilter(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageHighPassFilter(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageHighPassFilterInfo *arg3 = (lmrcImageHighPassFilterInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHighPassFilter", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageHighPassFilter", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageHighPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageHighPassFilterInfo *","lmrcImageHighPassFilter", 3, argv[2] )); 
  }
  arg3 = (lmrcImageHighPassFilterInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageHighPassFilter", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageHighPassFilter(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageBandPassFilter(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageBandPassFilterInfo *arg3 = (lmrcImageBandPassFilterInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageBandPassFilter", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageBandPassFilter", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageBandPassFilterInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageBandPassFilterInfo *","lmrcImageBandPassFilter", 3, argv[2] )); 
  }
  arg3 = (lmrcImageBandPassFilterInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageBandPassFilter", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageBandPassFilter(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageShrink(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeIntegerCoord arg3 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShrink", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShrink", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_mrcImageParaTypeIntegerCoord,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImageParaTypeIntegerCoord","lmrcImageShrink", 3, argv[2] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "mrcImageParaTypeIntegerCoord","lmrcImageShrink", 3, argv[2]));
    } else {
      arg3 = *((mrcImageParaTypeIntegerCoord *)(argp3));
    }
  }
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageShrink", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageShrink(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageShift(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeRealCoord arg3 ;
  mrcPixelDataHowToGet arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShift", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShift", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_mrcImageParaTypeRealCoord,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "mrcImageParaTypeRealCoord","lmrcImageShift", 3, argv[2] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "mrcImageParaTypeRealCoord","lmrcImageShift", 3, argv[2]));
    } else {
      arg3 = *((mrcImageParaTypeRealCoord *)(argp3));
    }
  }
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageShift", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  lmrcImageShift(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageShiftFollowingGC(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShiftFollowingGC", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageShiftFollowingGC", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmrcImageShiftFollowingGC", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmrcImageShiftFollowingGC(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcInfoPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeInteger arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","mrcInfoPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcInfoPrint", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeInteger","mrcInfoPrint", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeInteger)(val3);
  mrcInfoPrint(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassLmrcImageMultiCTFCompensationInfo;

SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_maxiteration_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","maxiteration", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","maxiteration", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->maxiteration = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_maxiteration_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","maxiteration", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (long) ((arg1)->maxiteration);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_okrms_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","okrms", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","okrms", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->okrms = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_okrms_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","okrms", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (double) ((arg1)->okrms);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_diversefactor_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","diversefactor", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","diversefactor", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->diversefactor = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_diversefactor_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","diversefactor", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (long) ((arg1)->diversefactor);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_z_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","z", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","z", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_z_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","z", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (double) ((arg1)->z);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_nhist_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","nhist", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","nhist", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->nhist = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_nhist_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","nhist", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (long) ((arg1)->nhist);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_logfile_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","logfile", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FILE, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FILE *","logfile", 2, argv[0] )); 
  }
  arg2 = (FILE *)(argp2);
  if (arg1) (arg1)->logfile = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_logfile_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","logfile", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (FILE *) ((arg1)->logfile);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FILE, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_solventMode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  lmrcImageMultiCTFCompensationSolventFlatteningMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","solventMode", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "lmrcImageMultiCTFCompensationSolventFlatteningMode","solventMode", 2, argv[0] ));
  } 
  arg2 = (lmrcImageMultiCTFCompensationSolventFlatteningMode)(val2);
  if (arg1) (arg1)->solventMode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_solventMode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  lmrcImageMultiCTFCompensationSolventFlatteningMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","solventMode", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (lmrcImageMultiCTFCompensationSolventFlatteningMode) ((arg1)->solventMode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_definedSTD_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","definedSTD", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","definedSTD", 2, argv[0] ));
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->definedSTD = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_definedSTD_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *arg1 = (struct lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageMultiCTFCompensationInfo *","definedSTD", 1, self )); 
  }
  arg1 = (struct lmrcImageMultiCTFCompensationInfo *)(argp1);
  result = (float) ((arg1)->definedSTD);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageMultiCTFCompensationInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageMultiCTFCompensationInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageMultiCTFCompensationInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageMultiCTFCompensationInfo *)calloc(1, sizeof(struct lmrcImageMultiCTFCompensationInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageMultiCTFCompensationInfo(struct lmrcImageMultiCTFCompensationInfo *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfoInit(int argc, VALUE *argv, VALUE self) {
  lmrcImageMultiCTFCompensationInfo *arg1 = (lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "lmrcImageMultiCTFCompensationInfo *","lmrcImageMultiCTFCompensationInfoInit", 1, argv[0] )); 
  }
  arg1 = (lmrcImageMultiCTFCompensationInfo *)(argp1);
  lmrcImageMultiCTFCompensationInfoInit(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensationInfoSet(int argc, VALUE *argv, VALUE self) {
  lmrcImageMultiCTFCompensationInfo *arg1 = (lmrcImageMultiCTFCompensationInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "lmrcImageMultiCTFCompensationInfo *","lmrcImageMultiCTFCompensationInfoSet", 1, argv[0] )); 
  }
  arg1 = (lmrcImageMultiCTFCompensationInfo *)(argp1);
  lmrcImageMultiCTFCompensationInfoSet(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMultiCTFCompensation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  ctfInfo *arg3 = (ctfInfo *) 0 ;
  long arg4 ;
  lmrcImageMultiCTFCompensationInfo arg5 ;
  long arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageMultiCTFCompensation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageMultiCTFCompensation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImageMultiCTFCompensation", 3, argv[2] )); 
  }
  arg3 = (ctfInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageMultiCTFCompensation", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  {
    res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo,  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "lmrcImageMultiCTFCompensationInfo","lmrcImageMultiCTFCompensation", 5, argv[4] )); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "lmrcImageMultiCTFCompensationInfo","lmrcImageMultiCTFCompensation", 5, argv[4]));
    } else {
      arg5 = *((lmrcImageMultiCTFCompensationInfo *)(argp5));
    }
  }
  ecode6 = SWIG_AsVal_long(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "long","lmrcImageMultiCTFCompensation", 6, argv[5] ));
  } 
  arg6 = (long)(val6);
  lmrcImageMultiCTFCompensation(arg1,arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFObservation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  ctfInfo *arg3 = (ctfInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCTFObservation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCTFObservation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImageCTFObservation", 3, argv[2] )); 
  }
  arg3 = (ctfInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageCTFObservation", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageCTFObservation(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImagesCTFObservation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  ctfInfo *arg3 = (ctfInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagesCTFObservation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagesCTFObservation", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImagesCTFObservation", 3, argv[2] )); 
  }
  arg3 = (ctfInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImagesCTFObservation", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImagesCTFObservation(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFCompensation(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  ctfInfo *arg2 = (ctfInfo *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCTFCompensation", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_ctfInfo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ctfInfo *","lmrcImageCTFCompensation", 2, argv[1] )); 
  }
  arg2 = (ctfInfo *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","lmrcImageCTFCompensation", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  lmrcImageCTFCompensation(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassLmrcImageCTFSNInfo;

SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_mode_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","mode", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_mode_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","mode", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  result = (long) ((arg1)->mode);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_deg1_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","deg1", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","deg1", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->deg1 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_deg1_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","deg1", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  result = (long) ((arg1)->deg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_deg2_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","deg2", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","deg2", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->deg2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_deg2_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","deg2", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  result = (long) ((arg1)->deg2);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_ctf_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  ctfInfo arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","ctf", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_ctfInfo,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ctfInfo","ctf", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ctfInfo","ctf", 2, argv[0]));
    } else {
      arg2 = *((ctfInfo *)(argp2));
    }
  }
  if (arg1) (arg1)->ctf = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_ctf_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *arg1 = (struct lmrcImageCTFSNInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ctfInfo result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageCTFSNInfo *","ctf", 1, self )); 
  }
  arg1 = (struct lmrcImageCTFSNInfo *)(argp1);
  result =  ((arg1)->ctf);
  vresult = SWIG_NewPointerObj((ctfInfo *)memcpy((ctfInfo *)malloc(sizeof(ctfInfo)),&result,sizeof(ctfInfo)), SWIGTYPE_p_ctfInfo, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageCTFSNInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageCTFSNInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageCTFSNInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageCTFSNInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageCTFSNInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageCTFSNInfo *)calloc(1, sizeof(struct lmrcImageCTFSNInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageCTFSNInfo(struct lmrcImageCTFSNInfo *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_lmrcImageCTFSN(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  lmrcImageCTFSNInfo *arg3 = (lmrcImageCTFSNInfo *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageCTFSN", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage const *","lmrcImageCTFSN", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_lmrcImageCTFSNInfo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "lmrcImageCTFSNInfo *","lmrcImageCTFSN", 3, argv[2] )); 
  }
  arg3 = (lmrcImageCTFSNInfo *)(argp3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","lmrcImageCTFSN", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  lmrcImageCTFSN(arg1,(struct mrcImage const *)arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassMrcImageFourierPowerSpectrum;

SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_n_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","n", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","n", 2, argv[0] ));
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->n = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_n_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","n", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  result = (long) ((arg1)->n);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_d_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","d", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","d", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->d = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_d_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","d", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  result = (double) ((arg1)->d);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_h_set(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","h", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","h", 2, argv[0] )); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->h = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_h_get(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *arg1 = (struct mrcImageFourierPowerSpectrum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_mrcImageFourierPowerSpectrum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct mrcImageFourierPowerSpectrum *","h", 1, self )); 
  }
  arg1 = (struct mrcImageFourierPowerSpectrum *)(argp1);
  result = (double *) ((arg1)->h);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_mrcImageFourierPowerSpectrum_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_mrcImageFourierPowerSpectrum_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_mrcImageFourierPowerSpectrum);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_mrcImageFourierPowerSpectrum(int argc, VALUE *argv, VALUE self) {
  struct mrcImageFourierPowerSpectrum *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct mrcImageFourierPowerSpectrum *)calloc(1, sizeof(struct mrcImageFourierPowerSpectrum));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_mrcImageFourierPowerSpectrum(struct mrcImageFourierPowerSpectrum *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassLmrcImageFourierPowerSpectrumInfo;

SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dX_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dX", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","dX", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->dX = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dX_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dX", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  result = (double) ((arg1)->dX);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dY_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dY", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","dY", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->dY = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dY_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dY", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  result = (double) ((arg1)->dY);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dZ_set(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dZ", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","dZ", 2, argv[0] ));
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->dZ = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_dZ_get(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *arg1 = (struct lmrcImageFourierPowerSpectrumInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct lmrcImageFourierPowerSpectrumInfo *","dZ", 1, self )); 
  }
  arg1 = (struct lmrcImageFourierPowerSpectrumInfo *)(argp1);
  result = (double) ((arg1)->dZ);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_lmrcImageFourierPowerSpectrumInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_lmrcImageFourierPowerSpectrumInfo(int argc, VALUE *argv, VALUE self) {
  struct lmrcImageFourierPowerSpectrumInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct lmrcImageFourierPowerSpectrumInfo *)calloc(1, sizeof(struct lmrcImageFourierPowerSpectrumInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_lmrcImageFourierPowerSpectrumInfo(struct lmrcImageFourierPowerSpectrumInfo *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumMakeSpectrum(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  lmrcImageFourierPowerSpectrumInfo *arg2 = (lmrcImageFourierPowerSpectrumInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  mrcImageFourierPowerSpectrum result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage const *","lmrcImageFourierPowerSpectrumMakeSpectrum", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "lmrcImageFourierPowerSpectrumInfo *","lmrcImageFourierPowerSpectrumMakeSpectrum", 2, argv[1] )); 
  }
  arg2 = (lmrcImageFourierPowerSpectrumInfo *)(argp2);
  result = lmrcImageFourierPowerSpectrumMakeSpectrum((struct mrcImage const *)arg1,arg2);
  vresult = SWIG_NewPointerObj((mrcImageFourierPowerSpectrum *)memcpy((mrcImageFourierPowerSpectrum *)malloc(sizeof(mrcImageFourierPowerSpectrum)),&result,sizeof(mrcImageFourierPowerSpectrum)), SWIGTYPE_p_mrcImageFourierPowerSpectrum, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrumDeleteSpectrum(int argc, VALUE *argv, VALUE self) {
  mrcImageFourierPowerSpectrum arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_mrcImageFourierPowerSpectrum,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImageFourierPowerSpectrum","lmrcImageFourierPowerSpectrumDeleteSpectrum", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "mrcImageFourierPowerSpectrum","lmrcImageFourierPowerSpectrumDeleteSpectrum", 1, argv[0]));
    } else {
      arg1 = *((mrcImageFourierPowerSpectrum *)(argp1));
    }
  }
  lmrcImageFourierPowerSpectrumDeleteSpectrum(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageFourierPowerSpectrum(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  lmrcImageFourierPowerSpectrumInfo *arg2 = (lmrcImageFourierPowerSpectrumInfo *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  mrcImageFourierPowerSpectrum result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage const *","lmrcImageFourierPowerSpectrum", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "lmrcImageFourierPowerSpectrumInfo *","lmrcImageFourierPowerSpectrum", 2, argv[1] )); 
  }
  arg2 = (lmrcImageFourierPowerSpectrumInfo *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","lmrcImageFourierPowerSpectrum", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  result = lmrcImageFourierPowerSpectrum((struct mrcImage const *)arg1,arg2,arg3);
  vresult = SWIG_NewPointerObj((mrcImageFourierPowerSpectrum *)memcpy((mrcImageFourierPowerSpectrum *)malloc(sizeof(mrcImageFourierPowerSpectrum)),&result,sizeof(mrcImageFourierPowerSpectrum)), SWIGTYPE_p_mrcImageFourierPowerSpectrum, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DModePrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmrcImageRotation3DModePrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  lmrcImageRotation3DModePrint(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DFollowingEulerAngle(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  char *arg3 = (char *) 0 ;
  mrcImageParaTypeReal arg4 ;
  mrcImageParaTypeReal arg5 ;
  mrcImageParaTypeReal arg6 ;
  mrcPixelDataHowToGet arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingEulerAngle", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingEulerAngle", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","lmrcImageRotation3DFollowingEulerAngle", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle", 5, argv[4] ));
  } 
  arg5 = (mrcImageParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_float(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle", 6, argv[5] ));
  } 
  arg6 = (mrcImageParaTypeReal)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation3DFollowingEulerAngle", 7, argv[6] ));
  } 
  arg7 = (mrcPixelDataHowToGet)(val7);
  ecode8 = SWIG_AsVal_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "int","lmrcImageRotation3DFollowingEulerAngle", 8, argv[7] ));
  } 
  arg8 = (int)(val8);
  lmrcImageRotation3DFollowingEulerAngle(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DFollowingMatrix3D(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  matrix3DParaTypeReal (*arg3)[4] ;
  mrcPixelDataHowToGet arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingMatrix3D", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingMatrix3D", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "float [4][4]","lmrcImageRotation3DFollowingMatrix3D", 3, argv[2] )); 
  } 
  arg3 = (float (*)[4])(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation3DFollowingMatrix3D", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","lmrcImageRotation3DFollowingMatrix3D", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  lmrcImageRotation3DFollowingMatrix3D(arg1,arg2,(float (*)[4])arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DFollowingEulerAngle2(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  char *arg3 = (char *) 0 ;
  mrcImageParaTypeReal arg4 ;
  mrcImageParaTypeReal arg5 ;
  mrcImageParaTypeReal arg6 ;
  mrcPixelDataHowToGet arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingEulerAngle2", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingEulerAngle2", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","lmrcImageRotation3DFollowingEulerAngle2", 3, argv[2] ));
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle2", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle2", 5, argv[4] ));
  } 
  arg5 = (mrcImageParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_float(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DFollowingEulerAngle2", 6, argv[5] ));
  } 
  arg6 = (mrcImageParaTypeReal)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation3DFollowingEulerAngle2", 7, argv[6] ));
  } 
  arg7 = (mrcPixelDataHowToGet)(val7);
  ecode8 = SWIG_AsVal_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "int","lmrcImageRotation3DFollowingEulerAngle2", 8, argv[7] ));
  } 
  arg8 = (int)(val8);
  lmrcImageRotation3DFollowingEulerAngle2(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DFollowingMatrix3D2(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  matrix3DParaTypeReal (*arg3)[4] ;
  mrcPixelDataHowToGet arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingMatrix3D2", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DFollowingMatrix3D2", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "float [4][4]","lmrcImageRotation3DFollowingMatrix3D2", 3, argv[2] )); 
  } 
  arg3 = (float (*)[4])(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation3DFollowingMatrix3D2", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","lmrcImageRotation3DFollowingMatrix3D2", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  lmrcImageRotation3DFollowingMatrix3D2(arg1,arg2,(float (*)[4])arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation3DZXY(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg3 ;
  mrcImageParaTypeReal arg4 ;
  mrcImageParaTypeReal arg5 ;
  mrcPixelDataHowToGet arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DZXY", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation3DZXY", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DZXY", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DZXY", 4, argv[3] ));
  } 
  arg4 = (mrcImageParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","lmrcImageRotation3DZXY", 5, argv[4] ));
  } 
  arg5 = (mrcImageParaTypeReal)(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation3DZXY", 6, argv[5] ));
  } 
  arg6 = (mrcPixelDataHowToGet)(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","lmrcImageRotation3DZXY", 7, argv[6] ));
  } 
  arg7 = (int)(val7);
  lmrcImageRotation3DZXY(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation2D(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  double arg3 ;
  mrcPixelDataHowToGet arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation2D", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation2D", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageRotation2D", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation2D", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  lmrcImageRotation2D(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageRotation2DPeriodicBoundary(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  double arg3 ;
  mrcPixelDataHowToGet arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation2DPeriodicBoundary", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageRotation2DPeriodicBoundary", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","lmrcImageRotation2DPeriodicBoundary", 3, argv[2] ));
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "mrcPixelDataHowToGet","lmrcImageRotation2DPeriodicBoundary", 4, argv[3] ));
  } 
  arg4 = (mrcPixelDataHowToGet)(val4);
  lmrcImageRotation2DPeriodicBoundary(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageSectionGetModeDescription(int argc, VALUE *argv, VALUE self) {
  long arg1 ;
  long val1 ;
  int ecode1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_long(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "long","mrcImageSectionGetModeDescription", 1, argv[0] ));
  } 
  arg1 = (long)(val1);
  result = (char *)mrcImageSectionGetModeDescription(arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageSectionGet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg3 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageSectionGet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcImageSectionGet", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageSectionGet", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageSectionGet", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  mrcImageSectionGet(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_mrcImageSectionSet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  mrcImageParaTypeReal arg3 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","mrcImageSectionSet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","mrcImageSectionSet", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "mrcImageParaTypeReal","mrcImageSectionSet", 3, argv[2] ));
  } 
  arg3 = (mrcImageParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","mrcImageSectionSet", 4, argv[3] ));
  } 
  arg4 = (long)(val4);
  mrcImageSectionSet(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageMaxDataGet(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageMaxDataGet", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","lmrcImageMaxDataGet", 2, argv[1] ));
  } 
  arg2 = (long)(val2);
  result = (double)lmrcImageMaxDataGet(arg1,arg2);
  vresult = SWIG_From_double((double)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageStackAlloc(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int arg3 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStackAlloc", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStackAlloc", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmrcImageStackAlloc", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "int *","lmrcImageStackAlloc", 4, argv[3] )); 
  }
  arg4 = (int *)(argp4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","lmrcImageStackAlloc", 5, argv[4] ));
  } 
  arg5 = (int)(val5);
  lmrcImageStackAlloc(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImageStackPush(int argc, VALUE *argv, VALUE self) {
  mrcImage *arg1 = (mrcImage *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStackPush", 1, argv[0] )); 
  }
  arg1 = (mrcImage *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImageStackPush", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int *","lmrcImageStackPush", 3, argv[2] )); 
  }
  arg3 = (int *)(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmrcImageStackPush", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmrcImageStackPush(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmrcImagePixelValueSort(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  mrcImage *arg2 = (mrcImage *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","lmrcImagePixelValueSort", 1, argv[0] )); 
  }
  arg1 = (double *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_mrcImage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "mrcImage *","lmrcImagePixelValueSort", 2, argv[1] )); 
  }
  arg2 = (mrcImage *)(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmrcImagePixelValueSort", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmrcImagePixelValueSort(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassResidueName;

SWIGINTERN VALUE
_wrap_residueName_residueName3_set(int argc, VALUE *argv, VALUE self) {
  struct residueName *arg1 = (struct residueName *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_residueName, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct residueName *","residueName3", 1, self )); 
  }
  arg1 = (struct residueName *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [4]","residueName3", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->residueName3,arg2,4*sizeof(char));
  else memset(arg1->residueName3,0,4*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_residueName_residueName3_get(int argc, VALUE *argv, VALUE self) {
  struct residueName *arg1 = (struct residueName *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_residueName, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct residueName *","residueName3", 1, self )); 
  }
  arg1 = (struct residueName *)(argp1);
  result = (char *)(char *) ((arg1)->residueName3);
  {
    size_t size = 4;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_residueName_residueName1_set(int argc, VALUE *argv, VALUE self) {
  struct residueName *arg1 = (struct residueName *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[2] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_residueName, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct residueName *","residueName1", 1, self )); 
  }
  arg1 = (struct residueName *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [2]","residueName1", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->residueName1,arg2,2*sizeof(char));
  else memset(arg1->residueName1,0,2*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_residueName_residueName1_get(int argc, VALUE *argv, VALUE self) {
  struct residueName *arg1 = (struct residueName *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_residueName, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct residueName *","residueName1", 1, self )); 
  }
  arg1 = (struct residueName *)(argp1);
  result = (char *)(char *) ((arg1)->residueName1);
  {
    size_t size = 2;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_residueName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_residueName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_residueName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_residueName(int argc, VALUE *argv, VALUE self) {
  struct residueName *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct residueName *)calloc(1, sizeof(struct residueName));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_residueName(struct residueName *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbCoord;

SWIGINTERN VALUE
_wrap_pdbCoord_x_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","x", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","x", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCoord_x_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","x", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->x);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCoord_y_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","y", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","y", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCoord_y_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","y", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->y);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCoord_z_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","z", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","z", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCoord_z_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *arg1 = (struct pdbCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCoord *","z", 1, self )); 
  }
  arg1 = (struct pdbCoord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->z);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbCoord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbCoord(int argc, VALUE *argv, VALUE self) {
  struct pdbCoord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbCoord *)calloc(1, sizeof(struct pdbCoord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbCoord(struct pdbCoord *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbSecondaryStructureHelix;

SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_serNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","serNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->serNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_serNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (int) ((arg1)->serNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_helixID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","helixID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","helixID", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->helixID) free((char*)arg1->helixID);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->helixID = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->helixID = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_helixID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","helixID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char *) ((arg1)->helixID);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","initResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->initResName) free((char*)arg1->initResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->initResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->initResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char *) ((arg1)->initResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char) ((arg1)->initChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","initSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->initSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (int) ((arg1)->initSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_initICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char) ((arg1)->initICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","endResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->endResName) free((char*)arg1->endResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->endResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->endResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char *) ((arg1)->endResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char) ((arg1)->endChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","endSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->endSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (int) ((arg1)->endSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_endICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char) ((arg1)->endICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_helixClass_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  pdbSecondaryStructureHelixClass arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","helixClass", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbSecondaryStructureHelixClass","helixClass", 2, argv[0] ));
  } 
  arg2 = (pdbSecondaryStructureHelixClass)(val2);
  if (arg1) (arg1)->helixClass = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_helixClass_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbSecondaryStructureHelixClass result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","helixClass", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (pdbSecondaryStructureHelixClass) ((arg1)->helixClass);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_comment_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","comment", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->comment) free((char*)arg1->comment);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->comment = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->comment = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_comment_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (char *) ((arg1)->comment);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_length_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","length", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","length", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->length = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_length_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *arg1 = (struct pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureHelix *","length", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureHelix *)(argp1);
  result = (int) ((arg1)->length);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbSecondaryStructureHelix_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbSecondaryStructureHelix_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbSecondaryStructureHelix);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbSecondaryStructureHelix(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureHelix *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbSecondaryStructureHelix *)calloc(1, sizeof(struct pdbSecondaryStructureHelix));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbSecondaryStructureHelix(struct pdbSecondaryStructureHelix *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbSecondaryStructureSheet;

SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_strand_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","strand", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","strand", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->strand = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_strand_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","strand", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->strand);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_sheetID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","sheetID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","sheetID", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->sheetID) free((char*)arg1->sheetID);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->sheetID = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->sheetID = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_sheetID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","sheetID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->sheetID);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_numStrands_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","numStrands", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","numStrands", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numStrands = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_numStrands_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","numStrands", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->numStrands);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","initResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->initResName) free((char*)arg1->initResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->initResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->initResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->initResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->initChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","initSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->initSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->initSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_initICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->initICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","endResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->endResName) free((char*)arg1->endResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->endResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->endResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->endResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->endChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","endSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->endSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->endSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_endICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->endICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_sense_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","sense", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sense", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->sense = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_sense_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","sense", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->sense);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curAtom_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curAtom", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","curAtom", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->curAtom) free((char*)arg1->curAtom);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->curAtom = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->curAtom = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curAtom_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curAtom", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->curAtom);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","curResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->curResName) free((char*)arg1->curResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->curResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->curResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->curResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","curChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->curChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->curChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curResSeq_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curResSeq", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","curResSeq", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->curResSeq = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curResSeq_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curResSeq", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->curResSeq);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","curICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->curICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_curICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","curICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->curICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevAtom_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevAtom", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","prevAtom", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->prevAtom) free((char*)arg1->prevAtom);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->prevAtom = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->prevAtom = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevAtom_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevAtom", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->prevAtom);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","prevResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->prevResName) free((char*)arg1->prevResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->prevResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->prevResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char *) ((arg1)->prevResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","prevChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->prevChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->prevChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevResSeq_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevResSeq", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","prevResSeq", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->prevResSeq = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevResSeq_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevResSeq", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (int) ((arg1)->prevResSeq);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","prevICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->prevICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_prevICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *arg1 = (struct pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureSheet *","prevICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureSheet *)(argp1);
  result = (char) ((arg1)->prevICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSheet_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbSecondaryStructureSheet_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbSecondaryStructureSheet);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbSecondaryStructureSheet(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureSheet *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbSecondaryStructureSheet *)calloc(1, sizeof(struct pdbSecondaryStructureSheet));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbSecondaryStructureSheet(struct pdbSecondaryStructureSheet *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbSecondaryStructureTurn;

SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_serNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","serNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->serNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_serNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (int) ((arg1)->serNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_turnID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","turnID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","turnID", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->turnID) free((char*)arg1->turnID);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->turnID = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->turnID = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_turnID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","turnID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char *) ((arg1)->turnID);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","initResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->initResName) free((char*)arg1->initResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->initResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->initResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char *) ((arg1)->initResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char) ((arg1)->initChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","initSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->initSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (int) ((arg1)->initSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_initICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char) ((arg1)->initICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","endResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->endResName) free((char*)arg1->endResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->endResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->endResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char *) ((arg1)->endResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char) ((arg1)->endChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","endSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->endSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (int) ((arg1)->endSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_endICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char) ((arg1)->endICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_comment_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","comment", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->comment) free((char*)arg1->comment);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->comment = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->comment = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_comment_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *arg1 = (struct pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureTurn *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureTurn *)(argp1);
  result = (char *) ((arg1)->comment);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbSecondaryStructureTurn_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbSecondaryStructureTurn_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbSecondaryStructureTurn);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbSecondaryStructureTurn(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureTurn *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbSecondaryStructureTurn *)calloc(1, sizeof(struct pdbSecondaryStructureTurn));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbSecondaryStructureTurn(struct pdbSecondaryStructureTurn *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbSecondaryStructureNo;

SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_serNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","serNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->serNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_serNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","serNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (int) ((arg1)->serNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_noID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","noID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","noID", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->noID) free((char*)arg1->noID);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->noID = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->noID = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_noID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","noID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char *) ((arg1)->noID);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","initResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->initResName) free((char*)arg1->initResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->initResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->initResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char *) ((arg1)->initResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char) ((arg1)->initChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","initSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->initSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (int) ((arg1)->initSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","initICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->initICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_initICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","initICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char) ((arg1)->initICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endResName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","endResName", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->endResName) free((char*)arg1->endResName);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->endResName = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->endResName = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endResName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endResName", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char *) ((arg1)->endResName);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endChainID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endChainID", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endChainID = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endChainID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endChainID", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char) ((arg1)->endChainID);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endSeqNum_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","endSeqNum", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->endSeqNum = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endSeqNum_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endSeqNum", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (int) ((arg1)->endSeqNum);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endICode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","endICode", 2, argv[0] ));
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->endICode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_endICode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","endICode", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char) ((arg1)->endICode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_comment_set(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","comment", 2, argv[0] ));
  }
  arg2 = (char *)(buf2);
  if (arg1->comment) free((char*)arg1->comment);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->comment = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->comment = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_comment_get(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *arg1 = (struct pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbSecondaryStructureNo *","comment", 1, self )); 
  }
  arg1 = (struct pdbSecondaryStructureNo *)(argp1);
  result = (char *) ((arg1)->comment);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbSecondaryStructureNo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbSecondaryStructureNo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbSecondaryStructureNo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbSecondaryStructureNo(int argc, VALUE *argv, VALUE self) {
  struct pdbSecondaryStructureNo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbSecondaryStructureNo *)calloc(1, sizeof(struct pdbSecondaryStructureNo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbSecondaryStructureNo(struct pdbSecondaryStructureNo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbFileSecondaryStructureRecord;

SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_mode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbFileSecondaryStructureMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","mode", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureMode","mode", 2, argv[0] ));
  } 
  arg2 = (pdbFileSecondaryStructureMode)(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_mode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructureMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","mode", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbFileSecondaryStructureMode) ((arg1)->mode);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_helix_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbSecondaryStructureHelix *arg2 = (pdbSecondaryStructureHelix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","helix", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbSecondaryStructureHelix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbSecondaryStructureHelix *","helix", 2, argv[0] )); 
  }
  arg2 = (pdbSecondaryStructureHelix *)(argp2);
  if (arg1) (arg1)->helix = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_helix_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbSecondaryStructureHelix *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","helix", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbSecondaryStructureHelix *) ((arg1)->helix);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbSecondaryStructureHelix, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_sheet_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbSecondaryStructureSheet *arg2 = (pdbSecondaryStructureSheet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","sheet", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbSecondaryStructureSheet, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbSecondaryStructureSheet *","sheet", 2, argv[0] )); 
  }
  arg2 = (pdbSecondaryStructureSheet *)(argp2);
  if (arg1) (arg1)->sheet = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_sheet_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbSecondaryStructureSheet *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","sheet", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbSecondaryStructureSheet *) ((arg1)->sheet);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbSecondaryStructureSheet, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_turn_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbSecondaryStructureTurn *arg2 = (pdbSecondaryStructureTurn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","turn", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbSecondaryStructureTurn, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbSecondaryStructureTurn *","turn", 2, argv[0] )); 
  }
  arg2 = (pdbSecondaryStructureTurn *)(argp2);
  if (arg1) (arg1)->turn = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_turn_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbSecondaryStructureTurn *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","turn", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbSecondaryStructureTurn *) ((arg1)->turn);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbSecondaryStructureTurn, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_no_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbSecondaryStructureNo *arg2 = (pdbSecondaryStructureNo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","no", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbSecondaryStructureNo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbSecondaryStructureNo *","no", 2, argv[0] )); 
  }
  arg2 = (pdbSecondaryStructureNo *)(argp2);
  if (arg1) (arg1)->no = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_no_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbSecondaryStructureNo *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","no", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbSecondaryStructureNo *) ((arg1)->no);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbSecondaryStructureNo, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_prev_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbFileSecondaryStructureRecord *arg2 = (pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","prev", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbFileSecondaryStructureRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureRecord *","prev", 2, argv[0] )); 
  }
  arg2 = (pdbFileSecondaryStructureRecord *)(argp2);
  if (arg1) (arg1)->prev = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_prev_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructureRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","prev", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbFileSecondaryStructureRecord *) ((arg1)->prev);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_next_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  pdbFileSecondaryStructureRecord *arg2 = (pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","next", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbFileSecondaryStructureRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureRecord *","next", 2, argv[0] )); 
  }
  arg2 = (pdbFileSecondaryStructureRecord *)(argp2);
  if (arg1) (arg1)->next = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_next_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *arg1 = (struct pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructureRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructureRecord *","next", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructureRecord *)(argp1);
  result = (pdbFileSecondaryStructureRecord *) ((arg1)->next);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbFileSecondaryStructureRecord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbFileSecondaryStructureRecord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbFileSecondaryStructureRecord(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructureRecord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbFileSecondaryStructureRecord *)calloc(1, sizeof(struct pdbFileSecondaryStructureRecord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbFileSecondaryStructureRecord(struct pdbFileSecondaryStructureRecord *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbFileSecondaryStructure;

SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_nSecondaryStructure_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","nSecondaryStructure", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","nSecondaryStructure", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nSecondaryStructure = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_nSecondaryStructure_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","nSecondaryStructure", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  result = (int) ((arg1)->nSecondaryStructure);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_top_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  pdbFileSecondaryStructureRecord *arg2 = (pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","top", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbFileSecondaryStructureRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureRecord *","top", 2, argv[0] )); 
  }
  arg2 = (pdbFileSecondaryStructureRecord *)(argp2);
  if (arg1) (arg1)->top = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_top_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructureRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","top", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  result = (pdbFileSecondaryStructureRecord *) ((arg1)->top);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_SecondaryStructure_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  pdbFileSecondaryStructureRecord *arg2 = (pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","SecondaryStructure", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbFileSecondaryStructureRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureRecord *","SecondaryStructure", 2, argv[0] )); 
  }
  arg2 = (pdbFileSecondaryStructureRecord *)(argp2);
  if (arg1) (arg1)->SecondaryStructure = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_SecondaryStructure_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *arg1 = (struct pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructureRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFileSecondaryStructure *","SecondaryStructure", 1, self )); 
  }
  arg1 = (struct pdbFileSecondaryStructure *)(argp1);
  result = (pdbFileSecondaryStructureRecord *) ((arg1)->SecondaryStructure);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructure_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbFileSecondaryStructure_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbFileSecondaryStructure);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbFileSecondaryStructure(int argc, VALUE *argv, VALUE self) {
  struct pdbFileSecondaryStructure *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbFileSecondaryStructure *)calloc(1, sizeof(struct pdbFileSecondaryStructure));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbFileSecondaryStructure(struct pdbFileSecondaryStructure *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbRecord;

SWIGINTERN VALUE
_wrap_pdbRecord_FullRecord_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(80) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","FullRecord", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (80) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(80) +1]","FullRecord", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->FullRecord,arg2,(80) +1*sizeof(char));
  else memset(arg1->FullRecord,0,(80) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_FullRecord_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","FullRecord", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->FullRecord);
  {
    size_t size = (80) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Record_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(6) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Record", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (6) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(6) +1]","Record", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->Record,arg2,(6) +1*sizeof(char));
  else memset(arg1->Record,0,(6) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Record_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Record", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->Record);
  {
    size_t size = (6) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_AtomSerialNumber_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","AtomSerialNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeInteger","AtomSerialNumber", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeInteger)(val2);
  if (arg1) (arg1)->AtomSerialNumber = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_AtomSerialNumber_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","AtomSerialNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeInteger) ((arg1)->AtomSerialNumber);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_AtomName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(4) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","AtomName", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (4) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(4) +1]","AtomName", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->AtomName,arg2,(4) +1*sizeof(char));
  else memset(arg1->AtomName,0,(4) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_AtomName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","AtomName", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->AtomName);
  {
    size_t size = (4) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_LocationIndicator_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","LocationIndicator", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeCharacter","LocationIndicator", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeCharacter)(val2);
  if (arg1) (arg1)->LocationIndicator = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_LocationIndicator_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","LocationIndicator", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter) ((arg1)->LocationIndicator);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ResidueName_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(3) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ResidueName", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (3) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(3) +1]","ResidueName", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->ResidueName,arg2,(3) +1*sizeof(char));
  else memset(arg1->ResidueName,0,(3) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ResidueName_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ResidueName", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->ResidueName);
  {
    size_t size = (3) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ChainIdentifier_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ChainIdentifier", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeCharacter","ChainIdentifier", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeCharacter)(val2);
  if (arg1) (arg1)->ChainIdentifier = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ChainIdentifier_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ChainIdentifier", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter) ((arg1)->ChainIdentifier);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ResidueSequenceNumber_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ResidueSequenceNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeInteger","ResidueSequenceNumber", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeInteger)(val2);
  if (arg1) (arg1)->ResidueSequenceNumber = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_ResidueSequenceNumber_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","ResidueSequenceNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeInteger) ((arg1)->ResidueSequenceNumber);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_InsertionCode_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","InsertionCode", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeCharacter","InsertionCode", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeCharacter)(val2);
  if (arg1) (arg1)->InsertionCode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_InsertionCode_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","InsertionCode", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter) ((arg1)->InsertionCode);
  vresult = SWIG_From_char((char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Coord_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbCoord *arg2 = (pdbCoord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Coord", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbCoord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbCoord *","Coord", 2, argv[0] )); 
  }
  arg2 = (pdbCoord *)(argp2);
  if (arg1) (arg1)->Coord = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Coord_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbCoord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Coord", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbCoord *)& ((arg1)->Coord);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Occupancy_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Occupancy", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","Occupancy", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->Occupancy = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Occupancy_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Occupancy", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->Occupancy);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_TemperatureFactor_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","TemperatureFactor", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","TemperatureFactor", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->TemperatureFactor = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_TemperatureFactor_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","TemperatureFactor", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->TemperatureFactor);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_FootnoteNumber_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","FootnoteNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeInteger","FootnoteNumber", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeInteger)(val2);
  if (arg1) (arg1)->FootnoteNumber = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_FootnoteNumber_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","FootnoteNumber", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeInteger) ((arg1)->FootnoteNumber);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Footnote_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(10) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Footnote", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (10) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(10) +1]","Footnote", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->Footnote,arg2,(10) +1*sizeof(char));
  else memset(arg1->Footnote,0,(10) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Footnote_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Footnote", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->Footnote);
  {
    size_t size = (10) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_SegID_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(4) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","SegID", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (4) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(4) +1]","SegID", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->SegID,arg2,(4) +1*sizeof(char));
  else memset(arg1->SegID,0,(4) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_SegID_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","SegID", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->SegID);
  {
    size_t size = (4) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Element_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(2) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Element", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (2) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(2) +1]","Element", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->Element,arg2,(2) +1*sizeof(char));
  else memset(arg1->Element,0,(2) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Element_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Element", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->Element);
  {
    size_t size = (2) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Charge_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeCharacter *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[(2) +1] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Charge", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, (2) +1);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [(2) +1]","Charge", 2, argv[0] ));
  }
  arg2 = (char *)(temp2);
  if (arg2) memcpy(arg1->Charge,arg2,(2) +1*sizeof(char));
  else memset(arg1->Charge,0,(2) +1*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_Charge_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeCharacter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","Charge", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeCharacter *)(pdbFileParaTypeCharacter *) ((arg1)->Charge);
  {
    size_t size = (2) +1;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_flagANISOU_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","flagANISOU", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","flagANISOU", 2, argv[0] ));
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flagANISOU = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_flagANISOU_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","flagANISOU", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (int) ((arg1)->flagANISOU);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_pAtomforANISOU_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbRecord *arg2 = (pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","pAtomforANISOU", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord *","pAtomforANISOU", 2, argv[0] )); 
  }
  arg2 = (pdbRecord *)(argp2);
  if (arg1) (arg1)->pAtomforANISOU = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_pAtomforANISOU_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","pAtomforANISOU", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbRecord *) ((arg1)->pAtomforANISOU);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U11_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U11", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U11", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U11 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U11_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U11", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U11);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U22_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U22", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U22", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U22 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U22_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U22", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U22);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U33_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U33", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U33", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U33 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U33_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U33", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U33);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U12_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U12", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U12", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U12 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U12_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U12", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U12);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U13_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U13", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U13", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U13 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U13_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U13", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U13);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U23_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbFileParaTypeReal arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U23", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","U23", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  if (arg1) (arg1)->U23 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_U23_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","U23", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbFileParaTypeReal) ((arg1)->U23);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_prev_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbRecord *arg2 = (pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","prev", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord *","prev", 2, argv[0] )); 
  }
  arg2 = (pdbRecord *)(argp2);
  if (arg1) (arg1)->prev = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_prev_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","prev", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbRecord *) ((arg1)->prev);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_next_set(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  pdbRecord *arg2 = (pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","next", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord *","next", 2, argv[0] )); 
  }
  arg2 = (pdbRecord *)(argp2);
  if (arg1) (arg1)->next = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecord_next_get(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *arg1 = (struct pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbRecord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbRecord *","next", 1, self )); 
  }
  arg1 = (struct pdbRecord *)(argp1);
  result = (pdbRecord *) ((arg1)->next);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbRecord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbRecord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbRecord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbRecord(int argc, VALUE *argv, VALUE self) {
  struct pdbRecord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbRecord *)calloc(1, sizeof(struct pdbRecord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbRecord(struct pdbRecord *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassPdbFile;

SWIGINTERN VALUE
_wrap_pdbFile_top_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  pdbRecord *arg2 = (pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","top", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord *","top", 2, argv[0] )); 
  }
  arg2 = (pdbRecord *)(argp2);
  if (arg1) (arg1)->top = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_top_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","top", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  result = (pdbRecord *) ((arg1)->top);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_PDB_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  pdbRecord *arg2 = (pdbRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","PDB", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbRecord, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord *","PDB", 2, argv[0] )); 
  }
  arg2 = (pdbRecord *)(argp2);
  if (arg1) (arg1)->PDB = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_PDB_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","PDB", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  result = (pdbRecord *) ((arg1)->PDB);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_nAtom_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  pdbFileParaTypeInteger arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","nAtom", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeInteger","nAtom", 2, argv[0] ));
  } 
  arg2 = (pdbFileParaTypeInteger)(val2);
  if (arg1) (arg1)->nAtom = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_nAtom_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","nAtom", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  result = (pdbFileParaTypeInteger) ((arg1)->nAtom);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_second_set(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  pdbFileSecondaryStructure *arg2 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","second", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","second", 2, argv[0] )); 
  }
  arg2 = (pdbFileSecondaryStructure *)(argp2);
  if (arg1) (arg1)->second = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFile_second_get(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *arg1 = (struct pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileSecondaryStructure *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbFile *","second", 1, self )); 
  }
  arg1 = (struct pdbFile *)(argp1);
  result = (pdbFileSecondaryStructure *)& ((arg1)->second);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbFile_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbFile_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbFile);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbFile(int argc, VALUE *argv, VALUE self) {
  struct pdbFile *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbFile *)calloc(1, sizeof(struct pdbFile));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbFile(struct pdbFile *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_pdbFileRead(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileRead", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileRead", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileRead(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileWrite(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileWrite", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileWrite", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileWrite(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileWriteCoord(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileWriteCoord", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileWriteCoord", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileWriteCoord(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileTableWrite(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileTableWrite", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileTableWrite", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileTableWrite(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileWriteSecondaryStructure(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFileSecondaryStructure *arg2 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileWriteSecondaryStructure", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","pdbFileWriteSecondaryStructure", 2, argv[1] )); 
  }
  arg2 = (pdbFileSecondaryStructure *)(argp2);
  pdbFileWriteSecondaryStructure(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbMatrixFileFormat(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbMatrixFileFormat", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  pdbMatrixFileFormat(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbMatrixFileRead(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbMatrixFileRead", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","pdbMatrixFileRead", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  pdbMatrixFileRead(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbMatrixFileWrite(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbMatrixFileWrite", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","pdbMatrixFileWrite", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  pdbMatrixFileWrite(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbTrans(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  matrix3DParaTypeReal (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbTrans", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "float [4][4]","pdbTrans", 2, argv[1] )); 
  } 
  arg2 = (float (*)[4])(argp2);
  pdbTrans(arg1,(float (*)[4])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbTransCuda(int argc, VALUE *argv, VALUE self) {
  float *arg1 = (float *) 0 ;
  int arg2 ;
  matrix3DParaTypeReal (*arg3)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "float *","pdbTransCuda", 1, argv[0] )); 
  }
  arg1 = (float *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","pdbTransCuda", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_a_4__float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "float [4][4]","pdbTransCuda", 3, argv[2] )); 
  } 
  arg3 = (float (*)[4])(argp3);
  pdbTransCuda(arg1,arg2,(float (*)[4])arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileResidueSequenceNumberIncrementAll(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileResidueSequenceNumberIncrementAll", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","pdbFileResidueSequenceNumberIncrementAll", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  pdbFileResidueSequenceNumberIncrementAll(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileResidueSequenceNumberIncrement(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileResidueSequenceNumberIncrement", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","pdbFileResidueSequenceNumberIncrement", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  pdbFileResidueSequenceNumberIncrement(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileChainIdentifierSetAll(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileChainIdentifierSetAll", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned char","pdbFileChainIdentifierSetAll", 2, argv[1] ));
  } 
  arg2 = (unsigned char)(val2);
  pdbFileChainIdentifierSetAll(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileChainIdentifierSet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileChainIdentifierSet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned char","pdbFileChainIdentifierSet", 2, argv[1] ));
  } 
  arg2 = (unsigned char)(val2);
  pdbFileChainIdentifierSet(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileChainIdentifierGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileChainIdentifierGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (unsigned char)pdbFileChainIdentifierGet(arg1);
  vresult = SWIG_From_unsigned_SS_char((unsigned char)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileTemperatureFactorGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileTemperatureFactorGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbFileParaTypeReal)pdbFileTemperatureFactorGet(arg1);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileTemperatureFactorSet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileTemperatureFactorSet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","pdbFileTemperatureFactorSet", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  pdbFileTemperatureFactorSet(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileOccupancyGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeReal result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOccupancyGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbFileParaTypeReal)pdbFileOccupancyGet(arg1);
  vresult = SWIG_From_float((float)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileOccupancySet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOccupancySet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","pdbFileOccupancySet", 2, argv[1] ));
  } 
  arg2 = (double)(val2);
  pdbFileOccupancySet(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileCoordSet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCoordSet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbFileCoordSet", 2, argv[1] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbFileCoordSet", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbFileCoordSet", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  result = (long)pdbFileCoordSet(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileCoordGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal *arg2 = (pdbFileParaTypeReal *) 0 ;
  pdbFileParaTypeReal *arg3 = (pdbFileParaTypeReal *) 0 ;
  pdbFileParaTypeReal *arg4 = (pdbFileParaTypeReal *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCoordGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal *","pdbFileCoordGet", 2, argv[1] )); 
  }
  arg2 = (pdbFileParaTypeReal *)(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal *","pdbFileCoordGet", 3, argv[2] )); 
  }
  arg3 = (pdbFileParaTypeReal *)(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal *","pdbFileCoordGet", 4, argv[3] )); 
  }
  arg4 = (pdbFileParaTypeReal *)(argp4);
  result = (long)pdbFileCoordGet(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileResidueSequenceNumberGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileResidueSequenceNumberGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileResidueSequenceNumberGet(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileResidueNameGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileResidueNameGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","pdbFileResidueNameGet", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  result = (char *)pdbFileResidueNameGet(arg1,arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileTop(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileTop", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileTop(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileTopPointer(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileTopPointer", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileTopPointer(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileNext(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileNext", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileNext(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileNextAtom(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileNextAtom", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileNextAtom(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileNextCA(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileNextCA", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileNextCA(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFilePrev(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFilePrev", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFilePrev(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFilePrevAtom(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFilePrevAtom", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFilePrevAtom(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFilePrevCA(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFilePrevCA", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFilePrevCA(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileEnd(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileEnd", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileEnd(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileGoToEnd(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileGoToEnd", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileGoToEnd(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsEndLine(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsEndLine", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsEndLine(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsAtom(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsAtom", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsAtom(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsANISOU(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsANISOU", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsANISOU(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRecordIsNearby(int argc, VALUE *argv, VALUE self) {
  pdbRecord arg1 ;
  pdbRecord arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_pdbRecord,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbRecord","pdbRecordIsNearby", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "pdbRecord","pdbRecordIsNearby", 1, argv[0]));
    } else {
      arg1 = *((pdbRecord *)(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_pdbRecord,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbRecord","pdbRecordIsNearby", 2, argv[1] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "pdbRecord","pdbRecordIsNearby", 2, argv[1]));
    } else {
      arg2 = *((pdbRecord *)(argp2));
    }
  }
  result = (long)pdbRecordIsNearby(arg1,arg2);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsCA(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsCA", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsCA(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsNegative(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsNegative", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsNegative(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsPositive(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsPositive", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsPositive(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsCharge(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsCharge", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsCharge(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsSecondaryStructure(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsSecondaryStructure", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsSecondaryStructure(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsHelix(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsHelix", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsHelix(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsSheet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsSheet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsSheet(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileIsTurn(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileIsTurn", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (long)pdbFileIsTurn(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileNew(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileNew", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileNew(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileAppend(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileAppend", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileAppend(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileFree(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileFree", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbRecord *)pdbFileFree(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileRecordPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileRecordPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileRecordPrint", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  result = (pdbRecord *)pdbFileRecordPrint(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbZValueGet(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbFileParaTypeInteger result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbZValueGet", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  result = (pdbFileParaTypeInteger)pdbZValueGet(arg1);
  vresult = SWIG_From_long((long)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileRecordTablePrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileRecordTablePrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileRecordTablePrint", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  result = (pdbRecord *)pdbFileRecordTablePrint(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileSecondaryStructureRecordPrint(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  pdbFileSecondaryStructureRecord *arg2 = (pdbFileSecondaryStructureRecord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbFileSecondaryStructureRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","pdbFileSecondaryStructureRecordPrint", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructureRecord *","pdbFileSecondaryStructureRecordPrint", 2, argv[1] )); 
  }
  arg2 = (pdbFileSecondaryStructureRecord *)(argp2);
  result = (pdbFileSecondaryStructureRecord *)pdbFileSecondaryStructureRecordPrint(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFileSecondaryStructureRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileCAOnlyCopy(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCAOnlyCopy", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCAOnlyCopy", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  result = (pdbRecord *)pdbFileCAOnlyCopy(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileCAOnlyCopyAll(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCAOnlyCopyAll", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCAOnlyCopyAll", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileCAOnlyCopyAll(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileCopyAll(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCopyAll", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileCopyAll", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileCopyAll(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileAppendAll(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileAppendAll", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileAppendAll", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  pdbFileAppendAll(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileOneRecordCopy(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbRecord *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOneRecordCopy", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOneRecordCopy", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  result = (pdbRecord *)pdbFileOneRecordCopy(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbRecord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileOneProteinCopy(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFile *arg2 = (pdbFile *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOneProteinCopy", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFile *","pdbFileOneProteinCopy", 2, argv[1] )); 
  }
  arg2 = (pdbFile *)(argp2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","pdbFileOneProteinCopy", 3, argv[2] ));
  } 
  arg3 = (long)(val3);
  pdbFileOneProteinCopy(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationFollowingEulerAngle(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  char *arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  pdbFileParaTypeReal arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationFollowingEulerAngle", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_AsCharArray(argv[1], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [4]","pdbRotationFollowingEulerAngle", 2, argv[1] ));
  }
  arg2 = (char *)(temp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngle", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngle", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngle", 5, argv[4] ));
  } 
  arg5 = (pdbFileParaTypeReal)(val5);
  pdbRotationFollowingEulerAngle(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationFollowingEulerAngleInverse(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  char *arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  pdbFileParaTypeReal arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[4] ;
  int res2 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationFollowingEulerAngleInverse", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_AsCharArray(argv[1], temp2, 4);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [4]","pdbRotationFollowingEulerAngleInverse", 2, argv[1] ));
  }
  arg2 = (char *)(temp2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngleInverse", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngleInverse", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  ecode5 = SWIG_AsVal_float(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationFollowingEulerAngleInverse", 5, argv[4] ));
  } 
  arg5 = (pdbFileParaTypeReal)(val5);
  pdbRotationFollowingEulerAngleInverse(arg1,arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationXYZ(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationXYZ", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationXYZ", 2, argv[1] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationXYZ", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationXYZ", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  pdbRotationXYZ(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationZYX(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationZYX", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZYX", 2, argv[1] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZYX", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZYX", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  pdbRotationZYX(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationZXY(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationZXY", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZXY", 2, argv[1] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZXY", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationZXY", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  pdbRotationZXY(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbRotationYXZ(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileParaTypeReal arg2 ;
  pdbFileParaTypeReal arg3 ;
  pdbFileParaTypeReal arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbRotationYXZ", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationYXZ", 2, argv[1] ));
  } 
  arg2 = (pdbFileParaTypeReal)(val2);
  ecode3 = SWIG_AsVal_float(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationYXZ", 3, argv[2] ));
  } 
  arg3 = (pdbFileParaTypeReal)(val3);
  ecode4 = SWIG_AsVal_float(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "pdbFileParaTypeReal","pdbRotationYXZ", 4, argv[3] ));
  } 
  arg4 = (pdbFileParaTypeReal)(val4);
  pdbRotationYXZ(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureSetFromPDB(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileSecondaryStructure *arg2 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbSecondaryStructureSetFromPDB", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","pdbSecondaryStructureSetFromPDB", 2, argv[1] )); 
  }
  arg2 = (pdbFileSecondaryStructure *)(argp2);
  result = (int)pdbSecondaryStructureSetFromPDB(arg1,arg2);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbNoSecondaryStructureSetFromPDB(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileSecondaryStructure *arg2 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbNoSecondaryStructureSetFromPDB", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","pdbNoSecondaryStructureSetFromPDB", 2, argv[1] )); 
  }
  arg2 = (pdbFileSecondaryStructure *)(argp2);
  result = (int)pdbNoSecondaryStructureSetFromPDB(arg1,arg2);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbSecondaryStructureAppend(int argc, VALUE *argv, VALUE self) {
  pdbFileSecondaryStructure *arg1 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","pdbSecondaryStructureAppend", 1, argv[0] )); 
  }
  arg1 = (pdbFileSecondaryStructure *)(argp1);
  result = (int)pdbSecondaryStructureAppend(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbFileWithSecondaryStructure(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  pdbFileSecondaryStructure *arg2 = (pdbFileSecondaryStructure *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  pdbFileSecondaryStructureMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","pdbFileWithSecondaryStructure", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_pdbFileSecondaryStructure, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbFileSecondaryStructure *","pdbFileWithSecondaryStructure", 2, argv[1] )); 
  }
  arg2 = (pdbFileSecondaryStructure *)(argp2);
  result = (pdbFileSecondaryStructureMode)pdbFileWithSecondaryStructure(arg1,arg2);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassCameraInfo;

SWIGINTERN VALUE
_wrap_cameraInfo_Fovy_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Fovy", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble","Fovy", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","Fovy", 2, argv[0]));
    } else {
      arg2 = *((GLdouble *)(argp2));
    }
  }
  if (arg1) (arg1)->Fovy = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Fovy_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Fovy", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result =  ((arg1)->Fovy);
  vresult = SWIG_NewPointerObj((GLdouble *)memcpy((GLdouble *)malloc(sizeof(GLdouble)),&result,sizeof(GLdouble)), SWIGTYPE_p_GLdouble, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Aspect_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Aspect", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble","Aspect", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","Aspect", 2, argv[0]));
    } else {
      arg2 = *((GLdouble *)(argp2));
    }
  }
  if (arg1) (arg1)->Aspect = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Aspect_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Aspect", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result =  ((arg1)->Aspect);
  vresult = SWIG_NewPointerObj((GLdouble *)memcpy((GLdouble *)malloc(sizeof(GLdouble)),&result,sizeof(GLdouble)), SWIGTYPE_p_GLdouble, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_ClipNear_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","ClipNear", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble","ClipNear", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","ClipNear", 2, argv[0]));
    } else {
      arg2 = *((GLdouble *)(argp2));
    }
  }
  if (arg1) (arg1)->ClipNear = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_ClipNear_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","ClipNear", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result =  ((arg1)->ClipNear);
  vresult = SWIG_NewPointerObj((GLdouble *)memcpy((GLdouble *)malloc(sizeof(GLdouble)),&result,sizeof(GLdouble)), SWIGTYPE_p_GLdouble, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_ClipFar_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","ClipFar", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble","ClipFar", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","ClipFar", 2, argv[0]));
    } else {
      arg2 = *((GLdouble *)(argp2));
    }
  }
  if (arg1) (arg1)->ClipFar = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_ClipFar_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","ClipFar", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result =  ((arg1)->ClipFar);
  vresult = SWIG_NewPointerObj((GLdouble *)memcpy((GLdouble *)malloc(sizeof(GLdouble)),&result,sizeof(GLdouble)), SWIGTYPE_p_GLdouble, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Eye_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Eye", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GLdouble, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble [3]","Eye", 2, argv[0] )); 
  } 
  arg2 = (GLdouble *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->Eye[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Eye""' of type '""GLdouble [3]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Eye_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Eye", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result = (GLdouble *)(GLdouble *) ((arg1)->Eye);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GLdouble, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Centre_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Centre", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GLdouble, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble [3]","Centre", 2, argv[0] )); 
  } 
  arg2 = (GLdouble *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->Centre[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Centre""' of type '""GLdouble [3]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Centre_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Centre", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result = (GLdouble *)(GLdouble *) ((arg1)->Centre);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GLdouble, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Up_set(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  GLdouble *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Up", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_GLdouble, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLdouble [3]","Up", 2, argv[0] )); 
  } 
  arg2 = (GLdouble *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->Up[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Up""' of type '""GLdouble [3]""'");
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cameraInfo_Up_get(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *arg1 = (struct cameraInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLdouble *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_cameraInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct cameraInfo *","Up", 1, self )); 
  }
  arg1 = (struct cameraInfo *)(argp1);
  result = (GLdouble *)(GLdouble *) ((arg1)->Up);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GLdouble, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_cameraInfo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_cameraInfo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_cameraInfo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_cameraInfo(int argc, VALUE *argv, VALUE self) {
  struct cameraInfo *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct cameraInfo *)calloc(1, sizeof(struct cameraInfo));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_cameraInfo(struct cameraInfo *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassCoord;

SWIGINTERN VALUE
_wrap_Coord_x_set(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","x", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","x", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","x", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Coord_x_get(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","x", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  result =  ((arg1)->x);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Coord_y_set(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","y", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","y", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","y", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Coord_y_get(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","y", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  result =  ((arg1)->y);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Coord_z_set(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","z", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","z", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","z", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Coord_z_get(int argc, VALUE *argv, VALUE self) {
  struct Coord *arg1 = (struct Coord *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Coord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct Coord *","z", 1, self )); 
  }
  arg1 = (struct Coord *)(argp1);
  result =  ((arg1)->z);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Coord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Coord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Coord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Coord(int argc, VALUE *argv, VALUE self) {
  struct Coord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct Coord *)calloc(1, sizeof(struct Coord));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Coord(struct Coord *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_lmolviePDBread(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","lmolviePDBread", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  lmolviePDBread(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_get_pdb(int argc, VALUE *argv, VALUE self) {
  pdbFile *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (pdbFile *)get_pdb();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbFile, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieInitNormal(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieInitNormal();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieIdleTest(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieIdleTest();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieIdleNormal(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieIdleNormal();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieDisplayTest(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieDisplayTest();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieDisplayNormal(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieDisplayNormal();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieReshapeNormal(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieReshapeNormal", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieReshapeNormal", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieReshapeNormal(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraRotateY(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraRotateY", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraRotateY", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraRotateY(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouse(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouse", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouse", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMouse", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieMouse", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieMouse(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMouseMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMousePassiveMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMousePassiveMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseDrive(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseDrive", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseDrive", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMouseDrive", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieMouseDrive", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieMouseDrive(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseMotionDrive(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionDrive", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionDrive", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMouseMotionDrive(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMousePassiveMotionDrive(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionDrive", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionDrive", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMousePassiveMotionDrive(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseParallel(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseParallel", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseParallel", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMouseParallel", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieMouseParallel", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieMouseParallel(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseMotionParallel(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionParallel", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionParallel", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMouseMotionParallel(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMousePassiveMotionParallel(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionParallel", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionParallel", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMousePassiveMotionParallel(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseMulti(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseMulti", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseMulti", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMouseMulti", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieMouseMulti", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieMouseMulti(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMouseMotionMulti(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionMulti", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMouseMotionMulti", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMouseMotionMulti(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMousePassiveMotionMulti(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionMulti", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMousePassiveMotionMulti", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMousePassiveMotionMulti(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieKeyboardNormal(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieKeyboardNormal", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieKeyboardNormal", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieKeyboardNormal", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieKeyboardNormal(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieKeyboardDrive(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieKeyboardDrive", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieKeyboardDrive", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieKeyboardDrive", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieKeyboardDrive(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieKeyboardParallel(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieKeyboardParallel", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieKeyboardParallel", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieKeyboardParallel", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieKeyboardParallel(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieKeyboardSurface(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieKeyboardSurface", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieKeyboardSurface", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieKeyboardSurface", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieKeyboardSurface(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieInitParallel(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieInitParallel();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieDisplayParallel(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieDisplayParallel();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieReshapeParallel(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieReshapeParallel", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieReshapeParallel", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieReshapeParallel(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_operationModeGet(int argc, VALUE *argv, VALUE self) {
  operationMode result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (operationMode)operationModeGet();
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_operationModeSet(int argc, VALUE *argv, VALUE self) {
  operationMode arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "operationMode","operationModeSet", 1, argv[0] ));
  } 
  arg1 = (operationMode)(val1);
  operationModeSet(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraRotateX(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraRotateX", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraRotateX", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraRotateX(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraRotateZ(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraRotateZ", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraRotateZ", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraRotateZ(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraEyeRotateX(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraEyeRotateX", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraEyeRotateX", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraEyeRotateX(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraEyeRotateY(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraEyeRotateY", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraEyeRotateY", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraEyeRotateY(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraTranslateX(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraTranslateX", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraTranslateX", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraTranslateX(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraTranslateY(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraTranslateY", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraTranslateY", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraTranslateY(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myCameraTranslateZ(int argc, VALUE *argv, VALUE self) {
  GLdouble arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLdouble,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLdouble","myCameraTranslateZ", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLdouble","myCameraTranslateZ", 1, argv[0]));
    } else {
      arg1 = *((GLdouble *)(argp1));
    }
  }
  myCameraTranslateZ(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_resetMyCamera(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  resetMyCamera();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getMyCamera(int argc, VALUE *argv, VALUE self) {
  cameraInfo *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (cameraInfo *)getMyCamera();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cameraInfo, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_upCalc(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  upCalc();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_moveMyCamera(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","moveMyCamera", 1, argv[0] ));
  } 
  arg1 = (double)(val1);
  moveMyCamera(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieLightSet(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieLightSet();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_get_LightPos(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  GLfloat *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","get_LightPos", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (GLfloat *)get_LightPos(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GLfloat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_monoSound(int argc, VALUE *argv, VALUE self) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_float(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "float","monoSound", 1, argv[0] ));
  } 
  arg1 = (float)(val1);
  ecode2 = SWIG_AsVal_float(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "float","monoSound", 2, argv[1] ));
  } 
  arg2 = (float)(val2);
  monoSound(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieVoice(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieVoice();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawContour(int argc, VALUE *argv, VALUE self) {
  contourLinesSet *arg1 = (contourLinesSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_contourLinesSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "contourLinesSet *","drawContour", 1, argv[0] )); 
  }
  arg1 = (contourLinesSet *)(argp1);
  drawContour(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_scaleBarSwitch(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  scaleBarSwitch();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerIdle(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieViewerIdle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieViewerKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieViewerKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieViewerKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieViewerKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerSpecial(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieViewerSpecial", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieViewerSpecial", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieViewerSpecial", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieViewerSpecial(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerMouse(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieViewerMouse", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieViewerMouse", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieViewerMouse", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieViewerMouse", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieViewerMouse(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerMouseMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieViewerMouseMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieViewerMouseMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieViewerMouseMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerMousePassiveMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieViewerMousePassiveMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieViewerMousePassiveMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieViewerMousePassiveMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieViewerDisplay(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieViewerDisplay();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMrcViewerKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieMrcViewerKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieMrcViewerKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMrcViewerMouse(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouse", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouse", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouse", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouse", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieMrcViewerMouse(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMrcViewerMouseMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouseMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMouseMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMrcViewerMouseMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMrcViewerMousePassiveMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMousePassiveMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieMrcViewerMousePassiveMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieMrcViewerMousePassiveMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieMrcViewerDisplay(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieMrcViewerDisplay();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieProjectionKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieProjectionKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieProjectionKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieProjectionKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieProjectionKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieProjectionMouse(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouse", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouse", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouse", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouse", 4, argv[3] ));
  } 
  arg4 = (int)(val4);
  lmolvieProjectionMouse(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieProjectionMouseMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouseMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieProjectionMouseMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieProjectionMouseMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieProjectionMousePassiveMotion(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","lmolvieProjectionMousePassiveMotion", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieProjectionMousePassiveMotion", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  lmolvieProjectionMousePassiveMotion(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieDockKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieDockKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieDockKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieDockKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieDockKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_displayMultiPDB1(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  displayMultiPDB1();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieDockDisplay(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieDockDisplay();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieFlightKeyboard(int argc, VALUE *argv, VALUE self) {
  unsigned char arg1 ;
  int arg2 ;
  int arg3 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned char","lmolvieFlightKeyboard", 1, argv[0] ));
  } 
  arg1 = (unsigned char)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","lmolvieFlightKeyboard", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","lmolvieFlightKeyboard", 3, argv[2] ));
  } 
  arg3 = (int)(val3);
  lmolvieFlightKeyboard(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieFlightDisplay(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieFlightDisplay();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieFlightIdle(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieFlightIdle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_lmolvieTest(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  lmolvieTest();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_myDisplayListMakeAtom(int argc, VALUE *argv, VALUE self) {
  GLboolean result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = myDisplayListMakeAtom();
  vresult = SWIG_NewPointerObj((GLboolean *)memcpy((GLboolean *)malloc(sizeof(GLboolean)),&result,sizeof(GLboolean)), SWIGTYPE_p_GLboolean, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_setDriveMyCamera(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  setDriveMyCamera();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_resetDriveMyCamera(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  resetDriveMyCamera();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_setCameraCentreTag(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","setCameraCentreTag", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  setCameraCentreTag(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomc_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomc), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomc_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomc""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomc""' of type '""GLuint""'");
    } else {
      drawatomc = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomca_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomca), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomca_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomca""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomca""' of type '""GLuint""'");
    } else {
      drawatomca = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomo_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomo), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomo_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomo""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomo""' of type '""GLuint""'");
    } else {
      drawatomo = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomn_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomn), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomn_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomn""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomn""' of type '""GLuint""'");
    } else {
      drawatomn = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatoms_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatoms), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatoms_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatoms""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatoms""' of type '""GLuint""'");
    } else {
      drawatoms = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomp_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomp), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomp_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomp""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomp""' of type '""GLuint""'");
    } else {
      drawatomp = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomh_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomh), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomh_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomh""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomh""' of type '""GLuint""'");
    } else {
      drawatomh = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomfe_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomfe), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomfe_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomfe""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomfe""' of type '""GLuint""'");
    } else {
      drawatomfe = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawstick_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawstick), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawstick_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawstick""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawstick""' of type '""GLuint""'");
    } else {
      drawstick = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawatomserial_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawatomserial), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawatomserial_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawatomserial""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawatomserial""' of type '""GLuint""'");
    } else {
      drawatomserial = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawresidue_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawresidue), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawresidue_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawresidue""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawresidue""' of type '""GLuint""'");
    } else {
      drawresidue = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawtemp_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawtemp), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawtemp_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawtemp""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawtemp""' of type '""GLuint""'");
    } else {
      drawtemp = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawsticktemp_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawsticktemp), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawsticktemp_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawsticktemp""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawsticktemp""' of type '""GLuint""'");
    } else {
      drawsticktemp = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawstickresidue_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawstickresidue), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawstickresidue_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawstickresidue""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawstickresidue""' of type '""GLuint""'");
    } else {
      drawstickresidue = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawsurface_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawsurface), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawsurface_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawsurface""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawsurface""' of type '""GLuint""'");
    } else {
      drawsurface = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawdistancefromtarget_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawdistancefromtarget), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawdistancefromtarget_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawdistancefromtarget""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawdistancefromtarget""' of type '""GLuint""'");
    } else {
      drawdistancefromtarget = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawwireframe_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawwireframe), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawwireframe_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawwireframe""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawwireframe""' of type '""GLuint""'");
    } else {
      drawwireframe = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_drawchain_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&drawchain), SWIGTYPE_p_GLuint,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_drawchain_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_GLuint,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""drawchain""' of type '""GLuint""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""drawchain""' of type '""GLuint""'");
    } else {
      drawchain = *((GLuint *)(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


static swig_class SwigClassPdbCenter;

SWIGINTERN VALUE
_wrap_pdbCenter_xCenter_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","xCenter", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","xCenter", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->xCenter = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xCenter_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->xCenter);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yCenter_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","yCenter", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","yCenter", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->yCenter = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yCenter_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->yCenter);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zCenter_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","zCenter", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","zCenter", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->zCenter = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zCenter_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zCenter", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->zCenter);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xMax_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","xMax", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","xMax", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->xMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xMax_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->xMax);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xMin_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","xMin", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","xMin", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->xMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xMin_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->xMin);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xWidth_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","xWidth", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","xWidth", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->xWidth = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_xWidth_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","xWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->xWidth);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yMax_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","yMax", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","yMax", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->yMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yMax_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->yMax);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yMin_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","yMin", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","yMin", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->yMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yMin_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->yMin);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yWidth_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","yWidth", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","yWidth", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->yWidth = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_yWidth_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","yWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->yWidth);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zMax_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","zMax", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","zMax", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->zMax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zMax_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zMax", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->zMax);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zMin_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","zMin", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","zMin", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->zMin = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zMin_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zMin", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->zMin);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zWidth_set(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","zWidth", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","zWidth", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->zWidth = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pdbCenter_zWidth_get(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *arg1 = (struct pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct pdbCenter *","zWidth", 1, self )); 
  }
  arg1 = (struct pdbCenter *)(argp1);
  result =  ((arg1)->zWidth);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pdbCenter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pdbCenter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_pdbCenter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pdbCenter(int argc, VALUE *argv, VALUE self) {
  struct pdbCenter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct pdbCenter *)calloc(1, sizeof(struct pdbCenter));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_pdbCenter(struct pdbCenter *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassElementSwitch;

SWIGINTERN VALUE
_wrap_elementSwitch_elementC_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementC", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementC", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementC", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementC = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementC_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementC", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementC);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementO_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementO", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementO", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementO", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementO = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementO_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementO", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementO);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementN_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementN", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementN", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementN", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementN = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementN_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementN", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementN);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementS_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementS", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementS", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementS", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementS = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementS_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementS", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementS);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementP_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementP", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementP", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementP", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementP = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementP_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementP", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementP);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementH_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementH", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementH", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementH", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementH = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementH_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementH", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementH);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementFE_set(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementFE", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","elementFE", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","elementFE", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->elementFE = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_elementSwitch_elementFE_get(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *arg1 = (struct elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct elementSwitch *","elementFE", 1, self )); 
  }
  arg1 = (struct elementSwitch *)(argp1);
  result =  ((arg1)->elementFE);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_elementSwitch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_elementSwitch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_elementSwitch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_elementSwitch(int argc, VALUE *argv, VALUE self) {
  struct elementSwitch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct elementSwitch *)calloc(1, sizeof(struct elementSwitch));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_elementSwitch(struct elementSwitch *arg1) {
    free((char *) arg1);
}

static swig_class SwigClassProteinStatus;

SWIGINTERN VALUE
_wrap_ProteinStatus___pdbCenter_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  pdbCenter *arg2 = (pdbCenter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","__pdbCenter", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_pdbCenter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "pdbCenter *","__pdbCenter", 2, argv[0] )); 
  }
  arg2 = (pdbCenter *)(argp2);
  if (arg1) (arg1)->__pdbCenter = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus___pdbCenter_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  pdbCenter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","__pdbCenter", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result = (pdbCenter *)& ((arg1)->__pdbCenter);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdbCenter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus___elementSwitch_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  elementSwitch *arg2 = (elementSwitch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","__elementSwitch", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_elementSwitch, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "elementSwitch *","__elementSwitch", 2, argv[0] )); 
  }
  arg2 = (elementSwitch *)(argp2);
  if (arg1) (arg1)->__elementSwitch = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus___elementSwitch_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  elementSwitch *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","__elementSwitch", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result = (elementSwitch *)& ((arg1)->__elementSwitch);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_elementSwitch, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_x_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_x", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","spin_x", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","spin_x", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->spin_x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_x_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_x", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result =  ((arg1)->spin_x);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_y_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_y", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","spin_y", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","spin_y", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->spin_y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_y_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_y", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result =  ((arg1)->spin_y);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_z_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  GLint arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_z", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLint","spin_z", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","spin_z", 2, argv[0]));
    } else {
      arg2 = *((GLint *)(argp2));
    }
  }
  if (arg1) (arg1)->spin_z = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_spin_z_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLint result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","spin_z", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result =  ((arg1)->spin_z);
  vresult = SWIG_NewPointerObj((GLint *)memcpy((GLint *)malloc(sizeof(GLint)),&result,sizeof(GLint)), SWIGTYPE_p_GLint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_move_x_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","move_x", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","move_x", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","move_x", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->move_x = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_move_x_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","move_x", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result =  ((arg1)->move_x);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_move_y_set(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  GLfloat arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","move_y", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_GLfloat,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "GLfloat","move_y", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLfloat","move_y", 2, argv[0]));
    } else {
      arg2 = *((GLfloat *)(argp2));
    }
  }
  if (arg1) (arg1)->move_y = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ProteinStatus_move_y_get(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *arg1 = (struct ProteinStatus *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GLfloat result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ProteinStatus, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "struct ProteinStatus *","move_y", 1, self )); 
  }
  arg1 = (struct ProteinStatus *)(argp1);
  result =  ((arg1)->move_y);
  vresult = SWIG_NewPointerObj((GLfloat *)memcpy((GLfloat *)malloc(sizeof(GLfloat)),&result,sizeof(GLfloat)), SWIGTYPE_p_GLfloat, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ProteinStatus_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ProteinStatus_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ProteinStatus);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ProteinStatus(int argc, VALUE *argv, VALUE self) {
  struct ProteinStatus *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (struct ProteinStatus *)calloc(1, sizeof(struct ProteinStatus));
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ProteinStatus(struct ProteinStatus *arg1) {
    free((char *) arg1);
}

SWIGINTERN VALUE
_wrap_getpdbCenter(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  pdbCenter result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getpdbCenter", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = getpdbCenter(arg1);
  vresult = SWIG_NewPointerObj((pdbCenter *)memcpy((pdbCenter *)malloc(sizeof(pdbCenter)),&result,sizeof(pdbCenter)), SWIGTYPE_p_pdbCenter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_putpdbCenter(int argc, VALUE *argv, VALUE self) {
  pdbFile *arg1 = (pdbFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_pdbFile, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "pdbFile *","putpdbCenter", 1, argv[0] )); 
  }
  arg1 = (pdbFile *)(argp1);
  putpdbCenter(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_proteinInit(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  proteinInit();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_get_elementSwitch(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  elementSwitch result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","get_elementSwitch", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = get_elementSwitch(arg1);
  vresult = SWIG_NewPointerObj((elementSwitch *)memcpy((elementSwitch *)malloc(sizeof(elementSwitch)),&result,sizeof(elementSwitch)), SWIGTYPE_p_elementSwitch, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_put_elementSwitch(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","put_elementSwitch", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","put_elementSwitch", 2, argv[1] ));
  } 
  arg2 = (char)(val2);
  put_elementSwitch(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getSpin_x(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getSpin_x", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (int)getSpin_x(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getSpin_y(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getSpin_y", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (int)getSpin_y(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getSpin_z(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getSpin_z", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (int)getSpin_z(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_proteinRotateX(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","proteinRotateX", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","proteinRotateX", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  proteinRotateX(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_proteinRotateY(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","proteinRotateY", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","proteinRotateY", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  proteinRotateY(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_proteinRotateZ(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","proteinRotateZ", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","proteinRotateZ", 2, argv[1] ));
  } 
  arg2 = (int)(val2);
  proteinRotateZ(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getMultiMoveX(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getMultiMoveX", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (int)getMultiMoveX(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getMultiMoveY(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","getMultiMoveY", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  result = (int)getMultiMoveY(arg1);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MultiMoveX(int argc, VALUE *argv, VALUE self) {
  GLint arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLint","MultiMoveX", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","MultiMoveX", 1, argv[0]));
    } else {
      arg1 = *((GLint *)(argp1));
    }
  }
  MultiMoveX(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MultiMoveY(int argc, VALUE *argv, VALUE self) {
  GLint arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_GLint,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "GLint","MultiMoveY", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "GLint","MultiMoveY", 1, argv[0]));
    } else {
      arg1 = *((GLint *)(argp1));
    }
  }
  MultiMoveY(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_saveproteinStatus(int argc, VALUE *argv, VALUE self) {
  ProteinStatus arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ProteinStatus,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ProteinStatus","saveproteinStatus", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ProteinStatus","saveproteinStatus", 1, argv[0]));
    } else {
      arg1 = *((ProteinStatus *)(argp1));
    }
  }
  saveproteinStatus(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_texture(int argc, VALUE *argv, VALUE self) {
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  texture();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_main(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char **arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","main", 1, argv[0] ));
  } 
  arg1 = (int)(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *[]","main", 2, argv[1] )); 
  } 
  arg2 = (char **)(argp2);
  result = (int)main(arg1,arg2);
  vresult = SWIG_From_int((int)(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_fopen(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  FILE *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","fopen", 1, argv[0] ));
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","fopen", 2, argv[1] ));
  }
  arg2 = (char *)(buf2);
  result = (FILE *)fopen(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FILE, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return Qnil;
}


SWIGINTERN VALUE
_wrap_fclose(int argc, VALUE *argv, VALUE self) {
  FILE *arg1 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FILE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FILE *","fclose", 1, argv[0] )); 
  }
  arg1 = (FILE *)(argp1);
  fclose(arg1);
  return Qnil;
fail:
  return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Array = {"_p_Array", "Array *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Coord = {"_p_Coord", "struct Coord *|Coord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EulerAngleInfo = {"_p_EulerAngleInfo", "struct EulerAngleInfo *|EulerAngleInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FEIextendedHeader = {"_p_FEIextendedHeader", "union FEIextendedHeader *|FEIextendedHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FILE = {"_p_FILE", "FILE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLboolean = {"_p_GLboolean", "GLboolean *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLdouble = {"_p_GLdouble", "GLdouble *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLfloat = {"_p_GLfloat", "GLfloat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLint = {"_p_GLint", "GLint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLuint = {"_p_GLuint", "GLuint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MRC_Status_t = {"_p_MRC_Status_t", "union MRC_Status_t *|MRC_Status_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MRC_Status_t_status = {"_p_MRC_Status_t_status", "MRC_Status_t_status *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ProteinStatus = {"_p_ProteinStatus", "struct ProteinStatus *|ProteinStatus *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Quat = {"_p_Quat", "Quat *|EulerAngles *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__FEIextendedHeader = {"_p__FEIextendedHeader", "struct _FEIextendedHeader *|_FEIextendedHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__mrcImageHeader = {"_p__mrcImageHeader", "struct _mrcImageHeader *|_mrcImageHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__mrcImageHeaderCCP4 = {"_p__mrcImageHeaderCCP4", "struct _mrcImageHeaderCCP4 *|_mrcImageHeaderCCP4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__mrcImageHeaderIMOD = {"_p__mrcImageHeaderIMOD", "struct _mrcImageHeaderIMOD *|_mrcImageHeaderIMOD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__mrcImageTailer = {"_p__mrcImageTailer", "struct _mrcImageTailer *|_mrcImageTailer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__a_4__float = {"_p_a_4__a_4__float", "Matrix3D *|HMatrix3D *|float (*)[4][4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__float = {"_p_a_4__float", "float (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a__80___char = {"_p_a__80___char", "char (*)[(80)]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cameraInfo = {"_p_cameraInfo", "struct cameraInfo *|cameraInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *|mrcImageSymmetryOperator *|pdbFileParaTypeCharacter *|matrix3DEulerAngleMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_contourLinesSet = {"_p_contourLinesSet", "contourLinesSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ctfInfo = {"_p_ctfInfo", "ctfInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_displayMode = {"_p_displayMode", "enum displayMode *|displayMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_elementSwitch = {"_p_elementSwitch", "struct elementSwitch *|elementSwitch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "matrix3DParaTypeReal *|mrcImageParaTypeReal *|pdbFileParaTypeReal *|float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_floatVector = {"_p_floatVector", "floatVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|mrcImageMode *|mrcImageParaTypeInteger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageBandPassFilterInfo = {"_p_lmrcImageBandPassFilterInfo", "struct lmrcImageBandPassFilterInfo *|lmrcImageBandPassFilterInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageCTFSNInfo = {"_p_lmrcImageCTFSNInfo", "struct lmrcImageCTFSNInfo *|lmrcImageCTFSNInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageCVEInfo = {"_p_lmrcImageCVEInfo", "struct lmrcImageCVEInfo *|lmrcImageCVEInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageFourierPowerSpectrumInfo = {"_p_lmrcImageFourierPowerSpectrumInfo", "struct lmrcImageFourierPowerSpectrumInfo *|lmrcImageFourierPowerSpectrumInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageHighPassFilterInfo = {"_p_lmrcImageHighPassFilterInfo", "struct lmrcImageHighPassFilterInfo *|lmrcImageHighPassFilterInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageHighlightInfo = {"_p_lmrcImageHighlightInfo", "struct lmrcImageHighlightInfo *|lmrcImageHighlightInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageLowPassFilterInfo = {"_p_lmrcImageLowPassFilterInfo", "struct lmrcImageLowPassFilterInfo *|lmrcImageLowPassFilterInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageMultiCTFCompensationInfo = {"_p_lmrcImageMultiCTFCompensationInfo", "struct lmrcImageMultiCTFCompensationInfo *|lmrcImageMultiCTFCompensationInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageMultiCTFCompensationSolventFlatteningMode = {"_p_lmrcImageMultiCTFCompensationSolventFlatteningMode", "lmrcImageMultiCTFCompensationSolventFlatteningMode *|enum lmrcImageMultiCTFCompensationSolventFlatteningMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageSmoothingInfo = {"_p_lmrcImageSmoothingInfo", "struct lmrcImageSmoothingInfo *|lmrcImageSmoothingInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_lmrcImageTfunctionInfo = {"_p_lmrcImageTfunctionInfo", "struct lmrcImageTfunctionInfo *|lmrcImageTfunctionInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *|pdbFileParaTypeInteger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImage = {"_p_mrcImage", "struct mrcImage *|mrcImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageDataSetMode = {"_p_mrcImageDataSetMode", "enum mrcImageDataSetMode *|mrcImageDataSetMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageFourierPowerSpectrum = {"_p_mrcImageFourierPowerSpectrum", "struct mrcImageFourierPowerSpectrum *|mrcImageFourierPowerSpectrum *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageHeader = {"_p_mrcImageHeader", "union mrcImageHeader *|mrcImageHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageInformation = {"_p_mrcImageInformation", "struct mrcImageInformation *|mrcImageInformation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageInformationMode = {"_p_mrcImageInformationMode", "enum mrcImageInformationMode *|mrcImageInformationMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageParaTypeIntegerCoord = {"_p_mrcImageParaTypeIntegerCoord", "struct mrcImageParaTypeIntegerCoord *|mrcImageParaTypeIntegerCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageParaTypeRealCoord = {"_p_mrcImageParaTypeRealCoord", "struct mrcImageParaTypeRealCoord *|mrcImageParaTypeRealCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImagePyramid = {"_p_mrcImagePyramid", "struct mrcImagePyramid *|mrcImagePyramid *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImagePyramidList = {"_p_mrcImagePyramidList", "struct mrcImagePyramidList *|mrcImagePyramidList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcImageTailer = {"_p_mrcImageTailer", "union mrcImageTailer *|mrcImageTailer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcPixelDataHowToGet = {"_p_mrcPixelDataHowToGet", "enum mrcPixelDataHowToGet *|mrcPixelDataHowToGet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mrcPixelDataType = {"_p_mrcPixelDataType", "enum mrcPixelDataType *|mrcPixelDataType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_operationMode = {"_p_operationMode", "enum operationMode *|operationMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_floatVector = {"_p_p_floatVector", "floatVector **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbCenter = {"_p_pdbCenter", "struct pdbCenter *|pdbCenter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbCoord = {"_p_pdbCoord", "struct pdbCoord *|pdbCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbFile = {"_p_pdbFile", "struct pdbFile *|pdbFile *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbFileSecondaryStructure = {"_p_pdbFileSecondaryStructure", "struct pdbFileSecondaryStructure *|pdbFileSecondaryStructure *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbFileSecondaryStructureMode = {"_p_pdbFileSecondaryStructureMode", "enum pdbFileSecondaryStructureMode *|pdbFileSecondaryStructureMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbFileSecondaryStructureRecord = {"_p_pdbFileSecondaryStructureRecord", "struct pdbFileSecondaryStructureRecord *|pdbFileSecondaryStructureRecord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbRecord = {"_p_pdbRecord", "struct pdbRecord *|pdbRecord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbSecondaryStructureHelix = {"_p_pdbSecondaryStructureHelix", "struct pdbSecondaryStructureHelix *|pdbSecondaryStructureHelix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbSecondaryStructureHelixClass = {"_p_pdbSecondaryStructureHelixClass", "enum pdbSecondaryStructureHelixClass *|pdbSecondaryStructureHelixClass *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbSecondaryStructureNo = {"_p_pdbSecondaryStructureNo", "struct pdbSecondaryStructureNo *|pdbSecondaryStructureNo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbSecondaryStructureSheet = {"_p_pdbSecondaryStructureSheet", "struct pdbSecondaryStructureSheet *|pdbSecondaryStructureSheet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdbSecondaryStructureTurn = {"_p_pdbSecondaryStructureTurn", "struct pdbSecondaryStructureTurn *|pdbSecondaryStructureTurn *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_residueName = {"_p_residueName", "struct residueName *|residueName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|mrcImageParaTypeCharacter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "mrcStatusType *|unsigned int *|mrcStatusMask *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Array,
  &_swigt__p_Coord,
  &_swigt__p_EulerAngleInfo,
  &_swigt__p_FEIextendedHeader,
  &_swigt__p_FILE,
  &_swigt__p_GLboolean,
  &_swigt__p_GLdouble,
  &_swigt__p_GLfloat,
  &_swigt__p_GLint,
  &_swigt__p_GLuint,
  &_swigt__p_MRC_Status_t,
  &_swigt__p_MRC_Status_t_status,
  &_swigt__p_ProteinStatus,
  &_swigt__p_Quat,
  &_swigt__p__FEIextendedHeader,
  &_swigt__p__mrcImageHeader,
  &_swigt__p__mrcImageHeaderCCP4,
  &_swigt__p__mrcImageHeaderIMOD,
  &_swigt__p__mrcImageTailer,
  &_swigt__p_a_4__a_4__float,
  &_swigt__p_a_4__float,
  &_swigt__p_a__80___char,
  &_swigt__p_cameraInfo,
  &_swigt__p_char,
  &_swigt__p_contourLinesSet,
  &_swigt__p_ctfInfo,
  &_swigt__p_displayMode,
  &_swigt__p_double,
  &_swigt__p_elementSwitch,
  &_swigt__p_float,
  &_swigt__p_floatVector,
  &_swigt__p_int,
  &_swigt__p_lmrcImageBandPassFilterInfo,
  &_swigt__p_lmrcImageCTFSNInfo,
  &_swigt__p_lmrcImageCVEInfo,
  &_swigt__p_lmrcImageFourierPowerSpectrumInfo,
  &_swigt__p_lmrcImageHighPassFilterInfo,
  &_swigt__p_lmrcImageHighlightInfo,
  &_swigt__p_lmrcImageLowPassFilterInfo,
  &_swigt__p_lmrcImageMultiCTFCompensationInfo,
  &_swigt__p_lmrcImageMultiCTFCompensationSolventFlatteningMode,
  &_swigt__p_lmrcImageSmoothingInfo,
  &_swigt__p_lmrcImageTfunctionInfo,
  &_swigt__p_long,
  &_swigt__p_mrcImage,
  &_swigt__p_mrcImageDataSetMode,
  &_swigt__p_mrcImageFourierPowerSpectrum,
  &_swigt__p_mrcImageHeader,
  &_swigt__p_mrcImageInformation,
  &_swigt__p_mrcImageInformationMode,
  &_swigt__p_mrcImageParaTypeIntegerCoord,
  &_swigt__p_mrcImageParaTypeRealCoord,
  &_swigt__p_mrcImagePyramid,
  &_swigt__p_mrcImagePyramidList,
  &_swigt__p_mrcImageTailer,
  &_swigt__p_mrcPixelDataHowToGet,
  &_swigt__p_mrcPixelDataType,
  &_swigt__p_operationMode,
  &_swigt__p_p_char,
  &_swigt__p_p_double,
  &_swigt__p_p_floatVector,
  &_swigt__p_pdbCenter,
  &_swigt__p_pdbCoord,
  &_swigt__p_pdbFile,
  &_swigt__p_pdbFileSecondaryStructure,
  &_swigt__p_pdbFileSecondaryStructureMode,
  &_swigt__p_pdbFileSecondaryStructureRecord,
  &_swigt__p_pdbRecord,
  &_swigt__p_pdbSecondaryStructureHelix,
  &_swigt__p_pdbSecondaryStructureHelixClass,
  &_swigt__p_pdbSecondaryStructureNo,
  &_swigt__p_pdbSecondaryStructureSheet,
  &_swigt__p_pdbSecondaryStructureTurn,
  &_swigt__p_residueName,
  &_swigt__p_short,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_short,
};

static swig_cast_info _swigc__p_Array[] = {  {&_swigt__p_Array, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Coord[] = {  {&_swigt__p_Coord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EulerAngleInfo[] = {  {&_swigt__p_EulerAngleInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FEIextendedHeader[] = {  {&_swigt__p_FEIextendedHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FILE[] = {  {&_swigt__p_FILE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLboolean[] = {  {&_swigt__p_GLboolean, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLdouble[] = {  {&_swigt__p_GLdouble, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLfloat[] = {  {&_swigt__p_GLfloat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLint[] = {  {&_swigt__p_GLint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLuint[] = {  {&_swigt__p_GLuint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MRC_Status_t[] = {  {&_swigt__p_MRC_Status_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MRC_Status_t_status[] = {  {&_swigt__p_MRC_Status_t_status, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ProteinStatus[] = {  {&_swigt__p_ProteinStatus, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Quat[] = {  {&_swigt__p_Quat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__FEIextendedHeader[] = {  {&_swigt__p__FEIextendedHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__mrcImageHeader[] = {  {&_swigt__p__mrcImageHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__mrcImageHeaderCCP4[] = {  {&_swigt__p__mrcImageHeaderCCP4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__mrcImageHeaderIMOD[] = {  {&_swigt__p__mrcImageHeaderIMOD, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__mrcImageTailer[] = {  {&_swigt__p__mrcImageTailer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__a_4__float[] = {  {&_swigt__p_a_4__a_4__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__float[] = {  {&_swigt__p_a_4__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a__80___char[] = {  {&_swigt__p_a__80___char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cameraInfo[] = {  {&_swigt__p_cameraInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_contourLinesSet[] = {  {&_swigt__p_contourLinesSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ctfInfo[] = {  {&_swigt__p_ctfInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_displayMode[] = {  {&_swigt__p_displayMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_elementSwitch[] = {  {&_swigt__p_elementSwitch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_floatVector[] = {  {&_swigt__p_floatVector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageBandPassFilterInfo[] = {  {&_swigt__p_lmrcImageBandPassFilterInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageCTFSNInfo[] = {  {&_swigt__p_lmrcImageCTFSNInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageCVEInfo[] = {  {&_swigt__p_lmrcImageCVEInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageFourierPowerSpectrumInfo[] = {  {&_swigt__p_lmrcImageFourierPowerSpectrumInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageHighPassFilterInfo[] = {  {&_swigt__p_lmrcImageHighPassFilterInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageHighlightInfo[] = {  {&_swigt__p_lmrcImageHighlightInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageLowPassFilterInfo[] = {  {&_swigt__p_lmrcImageLowPassFilterInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageMultiCTFCompensationInfo[] = {  {&_swigt__p_lmrcImageMultiCTFCompensationInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageMultiCTFCompensationSolventFlatteningMode[] = {  {&_swigt__p_lmrcImageMultiCTFCompensationSolventFlatteningMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageSmoothingInfo[] = {  {&_swigt__p_lmrcImageSmoothingInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lmrcImageTfunctionInfo[] = {  {&_swigt__p_lmrcImageTfunctionInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImage[] = {  {&_swigt__p_mrcImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageDataSetMode[] = {  {&_swigt__p_mrcImageDataSetMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageFourierPowerSpectrum[] = {  {&_swigt__p_mrcImageFourierPowerSpectrum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageHeader[] = {  {&_swigt__p_mrcImageHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageInformation[] = {  {&_swigt__p_mrcImageInformation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageInformationMode[] = {  {&_swigt__p_mrcImageInformationMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageParaTypeIntegerCoord[] = {  {&_swigt__p_mrcImageParaTypeIntegerCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageParaTypeRealCoord[] = {  {&_swigt__p_mrcImageParaTypeRealCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImagePyramid[] = {  {&_swigt__p_mrcImagePyramid, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImagePyramidList[] = {  {&_swigt__p_mrcImagePyramidList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcImageTailer[] = {  {&_swigt__p_mrcImageTailer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcPixelDataHowToGet[] = {  {&_swigt__p_mrcPixelDataHowToGet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mrcPixelDataType[] = {  {&_swigt__p_mrcPixelDataType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_operationMode[] = {  {&_swigt__p_operationMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_floatVector[] = {  {&_swigt__p_p_floatVector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbCenter[] = {  {&_swigt__p_pdbCenter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbCoord[] = {  {&_swigt__p_pdbCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbFile[] = {  {&_swigt__p_pdbFile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbFileSecondaryStructure[] = {  {&_swigt__p_pdbFileSecondaryStructure, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbFileSecondaryStructureMode[] = {  {&_swigt__p_pdbFileSecondaryStructureMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbFileSecondaryStructureRecord[] = {  {&_swigt__p_pdbFileSecondaryStructureRecord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbRecord[] = {  {&_swigt__p_pdbRecord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbSecondaryStructureHelix[] = {  {&_swigt__p_pdbSecondaryStructureHelix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbSecondaryStructureHelixClass[] = {  {&_swigt__p_pdbSecondaryStructureHelixClass, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbSecondaryStructureNo[] = {  {&_swigt__p_pdbSecondaryStructureNo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbSecondaryStructureSheet[] = {  {&_swigt__p_pdbSecondaryStructureSheet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdbSecondaryStructureTurn[] = {  {&_swigt__p_pdbSecondaryStructureTurn, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_residueName[] = {  {&_swigt__p_residueName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Array,
  _swigc__p_Coord,
  _swigc__p_EulerAngleInfo,
  _swigc__p_FEIextendedHeader,
  _swigc__p_FILE,
  _swigc__p_GLboolean,
  _swigc__p_GLdouble,
  _swigc__p_GLfloat,
  _swigc__p_GLint,
  _swigc__p_GLuint,
  _swigc__p_MRC_Status_t,
  _swigc__p_MRC_Status_t_status,
  _swigc__p_ProteinStatus,
  _swigc__p_Quat,
  _swigc__p__FEIextendedHeader,
  _swigc__p__mrcImageHeader,
  _swigc__p__mrcImageHeaderCCP4,
  _swigc__p__mrcImageHeaderIMOD,
  _swigc__p__mrcImageTailer,
  _swigc__p_a_4__a_4__float,
  _swigc__p_a_4__float,
  _swigc__p_a__80___char,
  _swigc__p_cameraInfo,
  _swigc__p_char,
  _swigc__p_contourLinesSet,
  _swigc__p_ctfInfo,
  _swigc__p_displayMode,
  _swigc__p_double,
  _swigc__p_elementSwitch,
  _swigc__p_float,
  _swigc__p_floatVector,
  _swigc__p_int,
  _swigc__p_lmrcImageBandPassFilterInfo,
  _swigc__p_lmrcImageCTFSNInfo,
  _swigc__p_lmrcImageCVEInfo,
  _swigc__p_lmrcImageFourierPowerSpectrumInfo,
  _swigc__p_lmrcImageHighPassFilterInfo,
  _swigc__p_lmrcImageHighlightInfo,
  _swigc__p_lmrcImageLowPassFilterInfo,
  _swigc__p_lmrcImageMultiCTFCompensationInfo,
  _swigc__p_lmrcImageMultiCTFCompensationSolventFlatteningMode,
  _swigc__p_lmrcImageSmoothingInfo,
  _swigc__p_lmrcImageTfunctionInfo,
  _swigc__p_long,
  _swigc__p_mrcImage,
  _swigc__p_mrcImageDataSetMode,
  _swigc__p_mrcImageFourierPowerSpectrum,
  _swigc__p_mrcImageHeader,
  _swigc__p_mrcImageInformation,
  _swigc__p_mrcImageInformationMode,
  _swigc__p_mrcImageParaTypeIntegerCoord,
  _swigc__p_mrcImageParaTypeRealCoord,
  _swigc__p_mrcImagePyramid,
  _swigc__p_mrcImagePyramidList,
  _swigc__p_mrcImageTailer,
  _swigc__p_mrcPixelDataHowToGet,
  _swigc__p_mrcPixelDataType,
  _swigc__p_operationMode,
  _swigc__p_p_char,
  _swigc__p_p_double,
  _swigc__p_p_floatVector,
  _swigc__p_pdbCenter,
  _swigc__p_pdbCoord,
  _swigc__p_pdbFile,
  _swigc__p_pdbFileSecondaryStructure,
  _swigc__p_pdbFileSecondaryStructureMode,
  _swigc__p_pdbFileSecondaryStructureRecord,
  _swigc__p_pdbRecord,
  _swigc__p_pdbSecondaryStructureHelix,
  _swigc__p_pdbSecondaryStructureHelixClass,
  _swigc__p_pdbSecondaryStructureNo,
  _swigc__p_pdbSecondaryStructureSheet,
  _swigc__p_pdbSecondaryStructureTurn,
  _swigc__p_residueName,
  _swigc__p_short,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_short,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_molvieRuby(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mMolvieRuby = rb_define_module("MolvieRuby");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  rb_define_const(mMolvieRuby, "MATRIX_3D_WIDTH", SWIG_From_int((int)(4)));
  rb_define_const(mMolvieRuby, "MATRIX_3D_HEIGHT", SWIG_From_int((int)(4)));
  rb_define_const(mMolvieRuby, "MATRIX_3D_MODE_NOT_INITIALIZE", SWIG_From_int((int)(0)));
  rb_define_const(mMolvieRuby, "MATRIX_3D_MODE_INITIALIZE", SWIG_From_int((int)(1)));
  rb_define_const(mMolvieRuby, "MATRIX_3D_NEGLECT_VALUE", SWIG_From_double((double)(1e-6)));
  
  SwigClassEulerAngleInfo.klass = rb_define_class_under(mMolvieRuby, "EulerAngleInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_EulerAngleInfo, (void *) &SwigClassEulerAngleInfo);
  rb_define_alloc_func(SwigClassEulerAngleInfo.klass, _wrap_EulerAngleInfo_allocate);
  rb_define_method(SwigClassEulerAngleInfo.klass, "initialize", _wrap_new_EulerAngleInfo, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "EAMode=", _wrap_EulerAngleInfo_EAMode_set, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "EAMode", _wrap_EulerAngleInfo_EAMode_get, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot1=", _wrap_EulerAngleInfo_Rot1_set, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot1", _wrap_EulerAngleInfo_Rot1_get, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot2=", _wrap_EulerAngleInfo_Rot2_set, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot2", _wrap_EulerAngleInfo_Rot2_get, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot3=", _wrap_EulerAngleInfo_Rot3_set, -1);
  rb_define_method(SwigClassEulerAngleInfo.klass, "Rot3", _wrap_EulerAngleInfo_Rot3_get, -1);
  SwigClassEulerAngleInfo.mark = 0;
  SwigClassEulerAngleInfo.destroy = (void (*)(void *)) free_EulerAngleInfo;
  SwigClassEulerAngleInfo.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "matrix3DInit", _wrap_matrix3DInit, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DCopy", _wrap_matrix3DCopy, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DFromRotationMatrix", _wrap_matrix3DFromRotationMatrix, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DInverse", _wrap_matrix3DInverse, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DMultiply", _wrap_matrix3DMultiply, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DMultiplyInv", _wrap_matrix3DMultiplyInv, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DMultiplyVector", _wrap_matrix3DMultiplyVector, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DMultiplyVectors", _wrap_matrix3DMultiplyVectors, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DFileFormat", _wrap_matrix3DFileFormat, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DFileRead", _wrap_matrix3DFileRead, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DFileWrite", _wrap_matrix3DFileWrite, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSet", _wrap_matrix3DRotationSet, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DTranslationSet", _wrap_matrix3DTranslationSet, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSetXYZ", _wrap_matrix3DRotationSetXYZ, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSetZYX", _wrap_matrix3DRotationSetZYX, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSetZXY", _wrap_matrix3DRotationSetZXY, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSetYXZ", _wrap_matrix3DRotationSetYXZ, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationSetFollowingEulerAngle", _wrap_matrix3DRotationSetFollowingEulerAngle, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DRotationAntiSetFollowingEulerAngle", _wrap_matrix3DRotationAntiSetFollowingEulerAngle, -1);
  rb_define_module_function(mMolvieRuby, "matrix3DEulerAngleGetFromMatrix3D", _wrap_matrix3DEulerAngleGetFromMatrix3D, -1);
  
  SwigClassQuat.klass = rb_define_class_under(mMolvieRuby, "Quat", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_Quat, (void *) &SwigClassQuat);
  rb_define_alloc_func(SwigClassQuat.klass, _wrap_Quat_allocate);
  rb_define_method(SwigClassQuat.klass, "initialize", _wrap_new_Quat, -1);
  rb_define_method(SwigClassQuat.klass, "x=", _wrap_Quat_x_set, -1);
  rb_define_method(SwigClassQuat.klass, "x", _wrap_Quat_x_get, -1);
  rb_define_method(SwigClassQuat.klass, "y=", _wrap_Quat_y_set, -1);
  rb_define_method(SwigClassQuat.klass, "y", _wrap_Quat_y_get, -1);
  rb_define_method(SwigClassQuat.klass, "z=", _wrap_Quat_z_set, -1);
  rb_define_method(SwigClassQuat.klass, "z", _wrap_Quat_z_get, -1);
  rb_define_method(SwigClassQuat.klass, "w=", _wrap_Quat_w_set, -1);
  rb_define_method(SwigClassQuat.klass, "w", _wrap_Quat_w_get, -1);
  SwigClassQuat.mark = 0;
  SwigClassQuat.destroy = (void (*)(void *)) free_Quat;
  SwigClassQuat.trackObjects = 0;
  rb_define_const(mMolvieRuby, "X", SWIG_From_int((int)(X)));
  rb_define_const(mMolvieRuby, "Y", SWIG_From_int((int)(Y)));
  rb_define_const(mMolvieRuby, "Z", SWIG_From_int((int)(Z)));
  rb_define_const(mMolvieRuby, "W", SWIG_From_int((int)(W)));
  rb_define_const(mMolvieRuby, "EulFrmS", SWIG_From_int((int)(0)));
  rb_define_const(mMolvieRuby, "EulFrmR", SWIG_From_int((int)(1)));
  rb_define_const(mMolvieRuby, "EulRepNo", SWIG_From_int((int)(0)));
  rb_define_const(mMolvieRuby, "EulRepYes", SWIG_From_int((int)(1)));
  rb_define_const(mMolvieRuby, "EulParEven", SWIG_From_int((int)(0)));
  rb_define_const(mMolvieRuby, "EulParOdd", SWIG_From_int((int)(1)));
  rb_define_const(mMolvieRuby, "EulSafe", SWIG_FromCharPtr(""));
  rb_define_const(mMolvieRuby, "EulNext", SWIG_FromCharPtr("\1\2"));
  rb_define_module_function(mMolvieRuby, "Eul_", _wrap_Eul_, -1);
  rb_define_module_function(mMolvieRuby, "Eul_ToQuat", _wrap_Eul_ToQuat, -1);
  rb_define_module_function(mMolvieRuby, "Eul_ToHMatrix", _wrap_Eul_ToHMatrix, -1);
  rb_define_module_function(mMolvieRuby, "Eul_FromHMatrix", _wrap_Eul_FromHMatrix, -1);
  rb_define_module_function(mMolvieRuby, "Eul_FromQuat", _wrap_Eul_FromQuat, -1);
  rb_define_singleton_method(mMolvieRuby, "mrcImageGeneralTypeList", _wrap_mrcImageGeneralTypeList_get, 0);
  rb_define_singleton_method(mMolvieRuby, "mrcImageGeneralTypeList=", _wrap_mrcImageGeneralTypeList_set, 1);
  
  SwigClassMRC_Status_t.klass = rb_define_class_under(mMolvieRuby, "MRC_Status_t", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_MRC_Status_t, (void *) &SwigClassMRC_Status_t);
  rb_define_alloc_func(SwigClassMRC_Status_t.klass, _wrap_MRC_Status_t_allocate);
  rb_define_method(SwigClassMRC_Status_t.klass, "initialize", _wrap_new_MRC_Status_t, -1);
  rb_define_method(SwigClassMRC_Status_t.klass, "all=", _wrap_MRC_Status_t_all_set, -1);
  rb_define_method(SwigClassMRC_Status_t.klass, "all", _wrap_MRC_Status_t_all_get, -1);
  rb_define_method(SwigClassMRC_Status_t.klass, "status", _wrap_MRC_Status_t_status_get, -1);
  SwigClassMRC_Status_t.mark = 0;
  SwigClassMRC_Status_t.destroy = (void (*)(void *)) free_MRC_Status_t;
  SwigClassMRC_Status_t.trackObjects = 0;
  
  SwigClassMRC_Status_t_status.klass = rb_define_class_under(mMolvieRuby, "MRC_Status_t_status", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_MRC_Status_t_status, (void *) &SwigClassMRC_Status_t_status);
  rb_define_alloc_func(SwigClassMRC_Status_t_status.klass, _wrap_MRC_Status_t_status_allocate);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "initialize", _wrap_new_MRC_Status_t_status, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "detail=", _wrap_MRC_Status_t_status_detail_set, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "detail", _wrap_MRC_Status_t_status_detail_get, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "category=", _wrap_MRC_Status_t_status_category_set, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "category", _wrap_MRC_Status_t_status_category_get, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "level=", _wrap_MRC_Status_t_status_level_set, -1);
  rb_define_method(SwigClassMRC_Status_t_status.klass, "level", _wrap_MRC_Status_t_status_level_get, -1);
  SwigClassMRC_Status_t_status.mark = 0;
  SwigClassMRC_Status_t_status.destroy = (void (*)(void *)) free_MRC_Status_t_status;
  SwigClassMRC_Status_t_status.trackObjects = 0;
  
  SwigClassMrcImageParaTypeIntegerCoord.klass = rb_define_class_under(mMolvieRuby, "MrcImageParaTypeIntegerCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageParaTypeIntegerCoord, (void *) &SwigClassMrcImageParaTypeIntegerCoord);
  rb_define_alloc_func(SwigClassMrcImageParaTypeIntegerCoord.klass, _wrap_mrcImageParaTypeIntegerCoord_allocate);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "initialize", _wrap_new_mrcImageParaTypeIntegerCoord, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "x=", _wrap_mrcImageParaTypeIntegerCoord_x_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "x", _wrap_mrcImageParaTypeIntegerCoord_x_get, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "y=", _wrap_mrcImageParaTypeIntegerCoord_y_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "y", _wrap_mrcImageParaTypeIntegerCoord_y_get, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "z=", _wrap_mrcImageParaTypeIntegerCoord_z_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeIntegerCoord.klass, "z", _wrap_mrcImageParaTypeIntegerCoord_z_get, -1);
  SwigClassMrcImageParaTypeIntegerCoord.mark = 0;
  SwigClassMrcImageParaTypeIntegerCoord.destroy = (void (*)(void *)) free_mrcImageParaTypeIntegerCoord;
  SwigClassMrcImageParaTypeIntegerCoord.trackObjects = 0;
  
  SwigClassMrcImageParaTypeRealCoord.klass = rb_define_class_under(mMolvieRuby, "MrcImageParaTypeRealCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageParaTypeRealCoord, (void *) &SwigClassMrcImageParaTypeRealCoord);
  rb_define_alloc_func(SwigClassMrcImageParaTypeRealCoord.klass, _wrap_mrcImageParaTypeRealCoord_allocate);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "initialize", _wrap_new_mrcImageParaTypeRealCoord, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "x=", _wrap_mrcImageParaTypeRealCoord_x_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "x", _wrap_mrcImageParaTypeRealCoord_x_get, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "y=", _wrap_mrcImageParaTypeRealCoord_y_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "y", _wrap_mrcImageParaTypeRealCoord_y_get, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "z=", _wrap_mrcImageParaTypeRealCoord_z_set, -1);
  rb_define_method(SwigClassMrcImageParaTypeRealCoord.klass, "z", _wrap_mrcImageParaTypeRealCoord_z_get, -1);
  SwigClassMrcImageParaTypeRealCoord.mark = 0;
  SwigClassMrcImageParaTypeRealCoord.destroy = (void (*)(void *)) free_mrcImageParaTypeRealCoord;
  SwigClassMrcImageParaTypeRealCoord.trackObjects = 0;
  rb_define_const(mMolvieRuby, "MRC_HEADER", SWIG_From_int((int)((1024))));
  rb_define_const(mMolvieRuby, "MRC_TAILER", SWIG_From_int((int)((1024))));
  rb_define_const(mMolvieRuby, "MRC_MAX_LABEL_N", SWIG_From_int((int)((10))));
  rb_define_const(mMolvieRuby, "MRC_MAX_LABEL_LEN", SWIG_From_int((int)((80))));
  rb_define_const(mMolvieRuby, "MRC_MAX_EXTRA", SWIG_From_int((int)((29))));
  rb_define_const(mMolvieRuby, "MRC_MAX_EXTRA_CCP4", SWIG_From_int((int)((15))));
  
  SwigClass_mrcImageHeader.klass = rb_define_class_under(mMolvieRuby, "_mrcImageHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p__mrcImageHeader, (void *) &SwigClass_mrcImageHeader);
  rb_define_alloc_func(SwigClass_mrcImageHeader.klass, _wrap__mrcImageHeader_allocate);
  rb_define_method(SwigClass_mrcImageHeader.klass, "initialize", _wrap_new__mrcImageHeader, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "N=", _wrap__mrcImageHeader_N_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "N", _wrap__mrcImageHeader_N_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Mode=", _wrap__mrcImageHeader_Mode_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Mode", _wrap__mrcImageHeader_Mode_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "StartN=", _wrap__mrcImageHeader_StartN_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "StartN", _wrap__mrcImageHeader_StartN_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "M=", _wrap__mrcImageHeader_M_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "M", _wrap__mrcImageHeader_M_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Length=", _wrap__mrcImageHeader_Length_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Length", _wrap__mrcImageHeader_Length_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Alpha=", _wrap__mrcImageHeader_Alpha_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Alpha", _wrap__mrcImageHeader_Alpha_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Beta=", _wrap__mrcImageHeader_Beta_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Beta", _wrap__mrcImageHeader_Beta_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Gamma=", _wrap__mrcImageHeader_Gamma_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Gamma", _wrap__mrcImageHeader_Gamma_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPC=", _wrap__mrcImageHeader_MAPC_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPC", _wrap__mrcImageHeader_MAPC_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPR=", _wrap__mrcImageHeader_MAPR_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPR", _wrap__mrcImageHeader_MAPR_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPS=", _wrap__mrcImageHeader_MAPS_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "MAPS", _wrap__mrcImageHeader_MAPS_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMin=", _wrap__mrcImageHeader_AMin_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMin", _wrap__mrcImageHeader_AMin_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMax=", _wrap__mrcImageHeader_AMax_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMax", _wrap__mrcImageHeader_AMax_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMean=", _wrap__mrcImageHeader_AMean_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "AMean", _wrap__mrcImageHeader_AMean_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "ISPG=", _wrap__mrcImageHeader_ISPG_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "ISPG", _wrap__mrcImageHeader_ISPG_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "NSYMBT=", _wrap__mrcImageHeader_NSYMBT_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "NSYMBT", _wrap__mrcImageHeader_NSYMBT_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "EXTRA=", _wrap__mrcImageHeader_EXTRA_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "EXTRA", _wrap__mrcImageHeader_EXTRA_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "OriginX=", _wrap__mrcImageHeader_OriginX_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "OriginX", _wrap__mrcImageHeader_OriginX_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "OriginY=", _wrap__mrcImageHeader_OriginY_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "OriginY", _wrap__mrcImageHeader_OriginY_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "LabelN=", _wrap__mrcImageHeader_LabelN_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "LabelN", _wrap__mrcImageHeader_LabelN_get, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Label=", _wrap__mrcImageHeader_Label_set, -1);
  rb_define_method(SwigClass_mrcImageHeader.klass, "Label", _wrap__mrcImageHeader_Label_get, -1);
  SwigClass_mrcImageHeader.mark = 0;
  SwigClass_mrcImageHeader.destroy = (void (*)(void *)) free__mrcImageHeader;
  SwigClass_mrcImageHeader.trackObjects = 0;
  
  SwigClass_mrcImageHeaderCCP4.klass = rb_define_class_under(mMolvieRuby, "_mrcImageHeaderCCP4", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p__mrcImageHeaderCCP4, (void *) &SwigClass_mrcImageHeaderCCP4);
  rb_define_alloc_func(SwigClass_mrcImageHeaderCCP4.klass, _wrap__mrcImageHeaderCCP4_allocate);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "initialize", _wrap_new__mrcImageHeaderCCP4, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "N=", _wrap__mrcImageHeaderCCP4_N_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "N", _wrap__mrcImageHeaderCCP4_N_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Mode=", _wrap__mrcImageHeaderCCP4_Mode_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Mode", _wrap__mrcImageHeaderCCP4_Mode_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "StartN=", _wrap__mrcImageHeaderCCP4_StartN_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "StartN", _wrap__mrcImageHeaderCCP4_StartN_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "NI=", _wrap__mrcImageHeaderCCP4_NI_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "NI", _wrap__mrcImageHeaderCCP4_NI_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Length=", _wrap__mrcImageHeaderCCP4_Length_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Length", _wrap__mrcImageHeaderCCP4_Length_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Alpha=", _wrap__mrcImageHeaderCCP4_Alpha_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Alpha", _wrap__mrcImageHeaderCCP4_Alpha_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Beta=", _wrap__mrcImageHeaderCCP4_Beta_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Beta", _wrap__mrcImageHeaderCCP4_Beta_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Gamma=", _wrap__mrcImageHeaderCCP4_Gamma_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Gamma", _wrap__mrcImageHeaderCCP4_Gamma_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPC=", _wrap__mrcImageHeaderCCP4_MAPC_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPC", _wrap__mrcImageHeaderCCP4_MAPC_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPR=", _wrap__mrcImageHeaderCCP4_MAPR_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPR", _wrap__mrcImageHeaderCCP4_MAPR_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPS=", _wrap__mrcImageHeaderCCP4_MAPS_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAPS", _wrap__mrcImageHeaderCCP4_MAPS_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMin=", _wrap__mrcImageHeaderCCP4_AMin_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMin", _wrap__mrcImageHeaderCCP4_AMin_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMax=", _wrap__mrcImageHeaderCCP4_AMax_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMax", _wrap__mrcImageHeaderCCP4_AMax_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMean=", _wrap__mrcImageHeaderCCP4_AMean_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "AMean", _wrap__mrcImageHeaderCCP4_AMean_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "ISPG=", _wrap__mrcImageHeaderCCP4_ISPG_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "ISPG", _wrap__mrcImageHeaderCCP4_ISPG_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "NSYMBT=", _wrap__mrcImageHeaderCCP4_NSYMBT_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "NSYMBT", _wrap__mrcImageHeaderCCP4_NSYMBT_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "LSKFLG=", _wrap__mrcImageHeaderCCP4_LSKFLG_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "LSKFLG", _wrap__mrcImageHeaderCCP4_LSKFLG_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "SKWMAT=", _wrap__mrcImageHeaderCCP4_SKWMAT_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "SKWMAT", _wrap__mrcImageHeaderCCP4_SKWMAT_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "SKWTRN=", _wrap__mrcImageHeaderCCP4_SKWTRN_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "SKWTRN", _wrap__mrcImageHeaderCCP4_SKWTRN_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "EXTRA=", _wrap__mrcImageHeaderCCP4_EXTRA_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "EXTRA", _wrap__mrcImageHeaderCCP4_EXTRA_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAP=", _wrap__mrcImageHeaderCCP4_MAP_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MAP", _wrap__mrcImageHeaderCCP4_MAP_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MARCHST=", _wrap__mrcImageHeaderCCP4_MARCHST_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "MARCHST", _wrap__mrcImageHeaderCCP4_MARCHST_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "ARMS=", _wrap__mrcImageHeaderCCP4_ARMS_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "ARMS", _wrap__mrcImageHeaderCCP4_ARMS_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "LabelN=", _wrap__mrcImageHeaderCCP4_LabelN_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "LabelN", _wrap__mrcImageHeaderCCP4_LabelN_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Label=", _wrap__mrcImageHeaderCCP4_Label_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderCCP4.klass, "Label", _wrap__mrcImageHeaderCCP4_Label_get, -1);
  SwigClass_mrcImageHeaderCCP4.mark = 0;
  SwigClass_mrcImageHeaderCCP4.destroy = (void (*)(void *)) free__mrcImageHeaderCCP4;
  SwigClass_mrcImageHeaderCCP4.trackObjects = 0;
  
  SwigClass_mrcImageHeaderIMOD.klass = rb_define_class_under(mMolvieRuby, "_mrcImageHeaderIMOD", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p__mrcImageHeaderIMOD, (void *) &SwigClass_mrcImageHeaderIMOD);
  rb_define_alloc_func(SwigClass_mrcImageHeaderIMOD.klass, _wrap__mrcImageHeaderIMOD_allocate);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "initialize", _wrap_new__mrcImageHeaderIMOD, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "N=", _wrap__mrcImageHeaderIMOD_N_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "N", _wrap__mrcImageHeaderIMOD_N_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Mode=", _wrap__mrcImageHeaderIMOD_Mode_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Mode", _wrap__mrcImageHeaderIMOD_Mode_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "StartN=", _wrap__mrcImageHeaderIMOD_StartN_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "StartN", _wrap__mrcImageHeaderIMOD_StartN_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "M=", _wrap__mrcImageHeaderIMOD_M_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "M", _wrap__mrcImageHeaderIMOD_M_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Length=", _wrap__mrcImageHeaderIMOD_Length_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Length", _wrap__mrcImageHeaderIMOD_Length_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Alpha=", _wrap__mrcImageHeaderIMOD_Alpha_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Alpha", _wrap__mrcImageHeaderIMOD_Alpha_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Beta=", _wrap__mrcImageHeaderIMOD_Beta_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Beta", _wrap__mrcImageHeaderIMOD_Beta_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Gamma=", _wrap__mrcImageHeaderIMOD_Gamma_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Gamma", _wrap__mrcImageHeaderIMOD_Gamma_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPC=", _wrap__mrcImageHeaderIMOD_MAPC_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPC", _wrap__mrcImageHeaderIMOD_MAPC_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPR=", _wrap__mrcImageHeaderIMOD_MAPR_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPR", _wrap__mrcImageHeaderIMOD_MAPR_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPS=", _wrap__mrcImageHeaderIMOD_MAPS_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAPS", _wrap__mrcImageHeaderIMOD_MAPS_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMin=", _wrap__mrcImageHeaderIMOD_AMin_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMin", _wrap__mrcImageHeaderIMOD_AMin_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMax=", _wrap__mrcImageHeaderIMOD_AMax_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMax", _wrap__mrcImageHeaderIMOD_AMax_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMean=", _wrap__mrcImageHeaderIMOD_AMean_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "AMean", _wrap__mrcImageHeaderIMOD_AMean_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "ISPG=", _wrap__mrcImageHeaderIMOD_ISPG_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "ISPG", _wrap__mrcImageHeaderIMOD_ISPG_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "NSYMBT=", _wrap__mrcImageHeaderIMOD_NSYMBT_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "NSYMBT", _wrap__mrcImageHeaderIMOD_NSYMBT_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "creatid=", _wrap__mrcImageHeaderIMOD_creatid_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "creatid", _wrap__mrcImageHeaderIMOD_creatid_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "extra1=", _wrap__mrcImageHeaderIMOD_extra1_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "extra1", _wrap__mrcImageHeaderIMOD_extra1_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nint=", _wrap__mrcImageHeaderIMOD_nint_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nint", _wrap__mrcImageHeaderIMOD_nint_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nreal=", _wrap__mrcImageHeaderIMOD_nreal_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nreal", _wrap__mrcImageHeaderIMOD_nreal_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "extra2=", _wrap__mrcImageHeaderIMOD_extra2_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "extra2", _wrap__mrcImageHeaderIMOD_extra2_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "imodStamp=", _wrap__mrcImageHeaderIMOD_imodStamp_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "imodStamp", _wrap__mrcImageHeaderIMOD_imodStamp_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "imodFlags=", _wrap__mrcImageHeaderIMOD_imodFlags_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "imodFlags", _wrap__mrcImageHeaderIMOD_imodFlags_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "idtype=", _wrap__mrcImageHeaderIMOD_idtype_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "idtype", _wrap__mrcImageHeaderIMOD_idtype_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "lnes=", _wrap__mrcImageHeaderIMOD_lnes_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "lnes", _wrap__mrcImageHeaderIMOD_lnes_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nd1=", _wrap__mrcImageHeaderIMOD_nd1_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nd1", _wrap__mrcImageHeaderIMOD_nd1_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nd2=", _wrap__mrcImageHeaderIMOD_nd2_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "nd2", _wrap__mrcImageHeaderIMOD_nd2_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "vd1=", _wrap__mrcImageHeaderIMOD_vd1_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "vd1", _wrap__mrcImageHeaderIMOD_vd1_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "vd2=", _wrap__mrcImageHeaderIMOD_vd2_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "vd2", _wrap__mrcImageHeaderIMOD_vd2_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "tiltangles=", _wrap__mrcImageHeaderIMOD_tiltangles_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "tiltangles", _wrap__mrcImageHeaderIMOD_tiltangles_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "xorg=", _wrap__mrcImageHeaderIMOD_xorg_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "xorg", _wrap__mrcImageHeaderIMOD_xorg_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "yorg=", _wrap__mrcImageHeaderIMOD_yorg_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "yorg", _wrap__mrcImageHeaderIMOD_yorg_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "zorg=", _wrap__mrcImageHeaderIMOD_zorg_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "zorg", _wrap__mrcImageHeaderIMOD_zorg_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAP=", _wrap__mrcImageHeaderIMOD_MAP_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MAP", _wrap__mrcImageHeaderIMOD_MAP_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MARCHST=", _wrap__mrcImageHeaderIMOD_MARCHST_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "MARCHST", _wrap__mrcImageHeaderIMOD_MARCHST_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "ARMS=", _wrap__mrcImageHeaderIMOD_ARMS_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "ARMS", _wrap__mrcImageHeaderIMOD_ARMS_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "LabelN=", _wrap__mrcImageHeaderIMOD_LabelN_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "LabelN", _wrap__mrcImageHeaderIMOD_LabelN_get, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Label=", _wrap__mrcImageHeaderIMOD_Label_set, -1);
  rb_define_method(SwigClass_mrcImageHeaderIMOD.klass, "Label", _wrap__mrcImageHeaderIMOD_Label_get, -1);
  SwigClass_mrcImageHeaderIMOD.mark = 0;
  SwigClass_mrcImageHeaderIMOD.destroy = (void (*)(void *)) free__mrcImageHeaderIMOD;
  SwigClass_mrcImageHeaderIMOD.trackObjects = 0;
  
  SwigClassMrcImageHeader.klass = rb_define_class_under(mMolvieRuby, "MrcImageHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageHeader, (void *) &SwigClassMrcImageHeader);
  rb_define_alloc_func(SwigClassMrcImageHeader.klass, _wrap_mrcImageHeader_allocate);
  rb_define_method(SwigClassMrcImageHeader.klass, "initialize", _wrap_new_mrcImageHeader, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "All=", _wrap_mrcImageHeader_All_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "All", _wrap_mrcImageHeader_All_get, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Int=", _wrap_mrcImageHeader_Int_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Int", _wrap_mrcImageHeader_Int_get, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Real=", _wrap_mrcImageHeader_Real_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Real", _wrap_mrcImageHeader_Real_get, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Cont=", _wrap_mrcImageHeader_Cont_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "Cont", _wrap_mrcImageHeader_Cont_get, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "ContCCP4=", _wrap_mrcImageHeader_ContCCP4_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "ContCCP4", _wrap_mrcImageHeader_ContCCP4_get, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "ContIMOD=", _wrap_mrcImageHeader_ContIMOD_set, -1);
  rb_define_method(SwigClassMrcImageHeader.klass, "ContIMOD", _wrap_mrcImageHeader_ContIMOD_get, -1);
  SwigClassMrcImageHeader.mark = 0;
  SwigClassMrcImageHeader.destroy = (void (*)(void *)) free_mrcImageHeader;
  SwigClassMrcImageHeader.trackObjects = 0;
  rb_define_const(mMolvieRuby, "FEI_EXTENDED_HEADER_EACH", SWIG_From_int((int)((128))));
  
  SwigClass_FEIextendedHeader.klass = rb_define_class_under(mMolvieRuby, "_FEIextendedHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p__FEIextendedHeader, (void *) &SwigClass_FEIextendedHeader);
  rb_define_alloc_func(SwigClass_FEIextendedHeader.klass, _wrap__FEIextendedHeader_allocate);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "initialize", _wrap_new__FEIextendedHeader, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "aTilt=", _wrap__FEIextendedHeader_aTilt_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "aTilt", _wrap__FEIextendedHeader_aTilt_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "bTilt=", _wrap__FEIextendedHeader_bTilt_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "bTilt", _wrap__FEIextendedHeader_bTilt_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "xStage=", _wrap__FEIextendedHeader_xStage_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "xStage", _wrap__FEIextendedHeader_xStage_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "yStage=", _wrap__FEIextendedHeader_yStage_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "yStage", _wrap__FEIextendedHeader_yStage_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "zStage=", _wrap__FEIextendedHeader_zStage_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "zStage", _wrap__FEIextendedHeader_zStage_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "xShift=", _wrap__FEIextendedHeader_xShift_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "xShift", _wrap__FEIextendedHeader_xShift_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "yShift=", _wrap__FEIextendedHeader_yShift_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "yShift", _wrap__FEIextendedHeader_yShift_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "defocus=", _wrap__FEIextendedHeader_defocus_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "defocus", _wrap__FEIextendedHeader_defocus_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "expTime=", _wrap__FEIextendedHeader_expTime_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "expTime", _wrap__FEIextendedHeader_expTime_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "mean=", _wrap__FEIextendedHeader_mean_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "mean", _wrap__FEIextendedHeader_mean_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "tiltAxis=", _wrap__FEIextendedHeader_tiltAxis_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "tiltAxis", _wrap__FEIextendedHeader_tiltAxis_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "pixelSize=", _wrap__FEIextendedHeader_pixelSize_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "pixelSize", _wrap__FEIextendedHeader_pixelSize_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "magnification=", _wrap__FEIextendedHeader_magnification_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "magnification", _wrap__FEIextendedHeader_magnification_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "ht=", _wrap__FEIextendedHeader_ht_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "ht", _wrap__FEIextendedHeader_ht_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "binning=", _wrap__FEIextendedHeader_binning_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "binning", _wrap__FEIextendedHeader_binning_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "appliedDefocus=", _wrap__FEIextendedHeader_appliedDefocus_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "appliedDefocus", _wrap__FEIextendedHeader_appliedDefocus_get, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "reminder=", _wrap__FEIextendedHeader_reminder_set, -1);
  rb_define_method(SwigClass_FEIextendedHeader.klass, "reminder", _wrap__FEIextendedHeader_reminder_get, -1);
  SwigClass_FEIextendedHeader.mark = 0;
  SwigClass_FEIextendedHeader.destroy = (void (*)(void *)) free__FEIextendedHeader;
  SwigClass_FEIextendedHeader.trackObjects = 0;
  
  SwigClassFEIextendedHeader.klass = rb_define_class_under(mMolvieRuby, "FEIextendedHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FEIextendedHeader, (void *) &SwigClassFEIextendedHeader);
  rb_define_alloc_func(SwigClassFEIextendedHeader.klass, _wrap_FEIextendedHeader_allocate);
  rb_define_method(SwigClassFEIextendedHeader.klass, "initialize", _wrap_new_FEIextendedHeader, -1);
  rb_define_method(SwigClassFEIextendedHeader.klass, "Real=", _wrap_FEIextendedHeader_Real_set, -1);
  rb_define_method(SwigClassFEIextendedHeader.klass, "Real", _wrap_FEIextendedHeader_Real_get, -1);
  rb_define_method(SwigClassFEIextendedHeader.klass, "Cont=", _wrap_FEIextendedHeader_Cont_set, -1);
  rb_define_method(SwigClassFEIextendedHeader.klass, "Cont", _wrap_FEIextendedHeader_Cont_get, -1);
  SwigClassFEIextendedHeader.mark = 0;
  SwigClassFEIextendedHeader.destroy = (void (*)(void *)) free_FEIextendedHeader;
  SwigClassFEIextendedHeader.trackObjects = 0;
  rb_define_const(mMolvieRuby, "MrcImageTailerMode2DProjection", SWIG_From_int((int)(0)));
  
  SwigClass_mrcImageTailer.klass = rb_define_class_under(mMolvieRuby, "_mrcImageTailer", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p__mrcImageTailer, (void *) &SwigClass_mrcImageTailer);
  rb_define_alloc_func(SwigClass_mrcImageTailer.klass, _wrap__mrcImageTailer_allocate);
  rb_define_method(SwigClass_mrcImageTailer.klass, "initialize", _wrap_new__mrcImageTailer, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Code=", _wrap__mrcImageTailer_Code_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Code", _wrap__mrcImageTailer_Code_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Mode=", _wrap__mrcImageTailer_Mode_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Mode", _wrap__mrcImageTailer_Mode_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "EulerAngleMode=", _wrap__mrcImageTailer_EulerAngleMode_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "EulerAngleMode", _wrap__mrcImageTailer_EulerAngleMode_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot1=", _wrap__mrcImageTailer_Rot1_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot1", _wrap__mrcImageTailer_Rot1_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot2=", _wrap__mrcImageTailer_Rot2_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot2", _wrap__mrcImageTailer_Rot2_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot3=", _wrap__mrcImageTailer_Rot3_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Rot3", _wrap__mrcImageTailer_Rot3_get, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Mirror=", _wrap__mrcImageTailer_Mirror_set, -1);
  rb_define_method(SwigClass_mrcImageTailer.klass, "Mirror", _wrap__mrcImageTailer_Mirror_get, -1);
  SwigClass_mrcImageTailer.mark = 0;
  SwigClass_mrcImageTailer.destroy = (void (*)(void *)) free__mrcImageTailer;
  SwigClass_mrcImageTailer.trackObjects = 0;
  
  SwigClassMrcImageTailer.klass = rb_define_class_under(mMolvieRuby, "MrcImageTailer", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageTailer, (void *) &SwigClassMrcImageTailer);
  rb_define_alloc_func(SwigClassMrcImageTailer.klass, _wrap_mrcImageTailer_allocate);
  rb_define_method(SwigClassMrcImageTailer.klass, "initialize", _wrap_new_mrcImageTailer, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "All=", _wrap_mrcImageTailer_All_set, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "All", _wrap_mrcImageTailer_All_get, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Int=", _wrap_mrcImageTailer_Int_set, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Int", _wrap_mrcImageTailer_Int_get, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Real=", _wrap_mrcImageTailer_Real_set, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Real", _wrap_mrcImageTailer_Real_get, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Cont=", _wrap_mrcImageTailer_Cont_set, -1);
  rb_define_method(SwigClassMrcImageTailer.klass, "Cont", _wrap_mrcImageTailer_Cont_get, -1);
  SwigClassMrcImageTailer.mark = 0;
  SwigClassMrcImageTailer.destroy = (void (*)(void *)) free_mrcImageTailer;
  SwigClassMrcImageTailer.trackObjects = 0;
  
  SwigClassMrcImage.klass = rb_define_class_under(mMolvieRuby, "MrcImage", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImage, (void *) &SwigClassMrcImage);
  rb_define_alloc_func(SwigClassMrcImage.klass, _wrap_mrcImage_allocate);
  rb_define_method(SwigClassMrcImage.klass, "initialize", _wrap_new_mrcImage, -1);
  rb_define_method(SwigClassMrcImage.klass, "Header=", _wrap_mrcImage_Header_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "Header", _wrap_mrcImage_Header_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "BytePerImage=", _wrap_mrcImage_BytePerImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "BytePerImage", _wrap_mrcImage_BytePerImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "BytePerBand=", _wrap_mrcImage_BytePerBand_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "BytePerBand", _wrap_mrcImage_BytePerBand_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "BandPerPixel=", _wrap_mrcImage_BandPerPixel_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "BandPerPixel", _wrap_mrcImage_BandPerPixel_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "PixelPerImage=", _wrap_mrcImage_PixelPerImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "PixelPerImage", _wrap_mrcImage_PixelPerImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "status=", _wrap_mrcImage_status_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "status", _wrap_mrcImage_status_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "Image=", _wrap_mrcImage_Image_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "Image", _wrap_mrcImage_Image_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageCharImage=", _wrap_mrcImage_ImageCharImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageCharImage", _wrap_mrcImage_ImageCharImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageShortImage=", _wrap_mrcImage_ImageShortImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageShortImage", _wrap_mrcImage_ImageShortImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageLongImage=", _wrap_mrcImage_ImageLongImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageLongImage", _wrap_mrcImage_ImageLongImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageULongImage=", _wrap_mrcImage_ImageULongImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageULongImage", _wrap_mrcImage_ImageULongImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageFloatImage=", _wrap_mrcImage_ImageFloatImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageFloatImage", _wrap_mrcImage_ImageFloatImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageDoubleImage=", _wrap_mrcImage_ImageDoubleImage_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageDoubleImage", _wrap_mrcImage_ImageDoubleImage_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "Tailer=", _wrap_mrcImage_Tailer_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "Tailer", _wrap_mrcImage_Tailer_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "numTailer=", _wrap_mrcImage_numTailer_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "numTailer", _wrap_mrcImage_numTailer_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "FEIHeader=", _wrap_mrcImage_FEIHeader_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "FEIHeader", _wrap_mrcImage_FEIHeader_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "numFEIHeader=", _wrap_mrcImage_numFEIHeader_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "numFEIHeader", _wrap_mrcImage_numFEIHeader_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "dummyHeader=", _wrap_mrcImage_dummyHeader_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "dummyHeader", _wrap_mrcImage_dummyHeader_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "dummyHeaderByte=", _wrap_mrcImage_dummyHeaderByte_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "dummyHeaderByte", _wrap_mrcImage_dummyHeaderByte_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagByteSwap=", _wrap_mrcImage_flagByteSwap_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagByteSwap", _wrap_mrcImage_flagByteSwap_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagCCP4=", _wrap_mrcImage_flagCCP4_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagCCP4", _wrap_mrcImage_flagCCP4_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageOffset=", _wrap_mrcImage_ImageOffset_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "ImageOffset", _wrap_mrcImage_ImageOffset_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "SymmetryOperator=", _wrap_mrcImage_SymmetryOperator_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "SymmetryOperator", _wrap_mrcImage_SymmetryOperator_get, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagSigned=", _wrap_mrcImage_flagSigned_set, -1);
  rb_define_method(SwigClassMrcImage.klass, "flagSigned", _wrap_mrcImage_flagSigned_get, -1);
  SwigClassMrcImage.mark = 0;
  SwigClassMrcImage.destroy = (void (*)(void *)) free_mrcImage;
  SwigClassMrcImage.trackObjects = 0;
  
  SwigClassMrcImagePyramidList.klass = rb_define_class_under(mMolvieRuby, "MrcImagePyramidList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImagePyramidList, (void *) &SwigClassMrcImagePyramidList);
  rb_define_alloc_func(SwigClassMrcImagePyramidList.klass, _wrap_mrcImagePyramidList_allocate);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "initialize", _wrap_new_mrcImagePyramidList, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "mrc=", _wrap_mrcImagePyramidList_mrc_set, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "mrc", _wrap_mrcImagePyramidList_mrc_get, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "up=", _wrap_mrcImagePyramidList_up_set, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "up", _wrap_mrcImagePyramidList_up_get, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "down=", _wrap_mrcImagePyramidList_down_set, -1);
  rb_define_method(SwigClassMrcImagePyramidList.klass, "down", _wrap_mrcImagePyramidList_down_get, -1);
  SwigClassMrcImagePyramidList.mark = 0;
  SwigClassMrcImagePyramidList.destroy = (void (*)(void *)) free_mrcImagePyramidList;
  SwigClassMrcImagePyramidList.trackObjects = 0;
  
  SwigClassMrcImagePyramid.klass = rb_define_class_under(mMolvieRuby, "MrcImagePyramid", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImagePyramid, (void *) &SwigClassMrcImagePyramid);
  rb_define_alloc_func(SwigClassMrcImagePyramid.klass, _wrap_mrcImagePyramid_allocate);
  rb_define_method(SwigClassMrcImagePyramid.klass, "initialize", _wrap_new_mrcImagePyramid, -1);
  rb_define_method(SwigClassMrcImagePyramid.klass, "top=", _wrap_mrcImagePyramid_top_set, -1);
  rb_define_method(SwigClassMrcImagePyramid.klass, "top", _wrap_mrcImagePyramid_top_get, -1);
  rb_define_method(SwigClassMrcImagePyramid.klass, "current=", _wrap_mrcImagePyramid_current_set, -1);
  rb_define_method(SwigClassMrcImagePyramid.klass, "current", _wrap_mrcImagePyramid_current_get, -1);
  SwigClassMrcImagePyramid.mark = 0;
  SwigClassMrcImagePyramid.destroy = (void (*)(void *)) free_mrcImagePyramid;
  SwigClassMrcImagePyramid.trackObjects = 0;
  
  SwigClassMrcImageInformation.klass = rb_define_class_under(mMolvieRuby, "MrcImageInformation", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageInformation, (void *) &SwigClassMrcImageInformation);
  rb_define_alloc_func(SwigClassMrcImageInformation.klass, _wrap_mrcImageInformation_allocate);
  rb_define_method(SwigClassMrcImageInformation.klass, "initialize", _wrap_new_mrcImageInformation, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "mean=", _wrap_mrcImageInformation_mean_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "mean", _wrap_mrcImageInformation_mean_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "rootMeanSquare=", _wrap_mrcImageInformation_rootMeanSquare_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "rootMeanSquare", _wrap_mrcImageInformation_rootMeanSquare_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfSphereSurface=", _wrap_mrcImageInformation_meanOfSphereSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfSphereSurface", _wrap_mrcImageInformation_meanOfSphereSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfSphereSurface=", _wrap_mrcImageInformation_sdOfSphereSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfSphereSurface", _wrap_mrcImageInformation_sdOfSphereSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfSphereSurface=", _wrap_mrcImageInformation_seOfSphereSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfSphereSurface", _wrap_mrcImageInformation_seOfSphereSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfCylinderSurface=", _wrap_mrcImageInformation_meanOfCylinderSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfCylinderSurface", _wrap_mrcImageInformation_meanOfCylinderSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfCylinderSurface=", _wrap_mrcImageInformation_sdOfCylinderSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfCylinderSurface", _wrap_mrcImageInformation_sdOfCylinderSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfCylinderSurface=", _wrap_mrcImageInformation_seOfCylinderSurface_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfCylinderSurface", _wrap_mrcImageInformation_seOfCylinderSurface_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfEdge=", _wrap_mrcImageInformation_meanOfEdge_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfEdge", _wrap_mrcImageInformation_meanOfEdge_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfEdge=", _wrap_mrcImageInformation_sdOfEdge_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfEdge", _wrap_mrcImageInformation_sdOfEdge_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfEdge=", _wrap_mrcImageInformation_seOfEdge_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfEdge", _wrap_mrcImageInformation_seOfEdge_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "max=", _wrap_mrcImageInformation_max_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "max", _wrap_mrcImageInformation_max_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxCoord=", _wrap_mrcImageInformation_maxCoord_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxCoord", _wrap_mrcImageInformation_maxCoord_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "min=", _wrap_mrcImageInformation_min_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "min", _wrap_mrcImageInformation_min_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minCoord=", _wrap_mrcImageInformation_minCoord_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minCoord", _wrap_mrcImageInformation_minCoord_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sd=", _wrap_mrcImageInformation_sd_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sd", _wrap_mrcImageInformation_sd_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "se=", _wrap_mrcImageInformation_se_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "se", _wrap_mrcImageInformation_se_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "rmax=", _wrap_mrcImageInformation_rmax_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "rmax", _wrap_mrcImageInformation_rmax_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagrmax=", _wrap_mrcImageInformation_flagrmax_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagrmax", _wrap_mrcImageInformation_flagrmax_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "RMS=", _wrap_mrcImageInformation_RMS_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "RMS", _wrap_mrcImageInformation_RMS_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "mode=", _wrap_mrcImageInformation_mode_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "mode", _wrap_mrcImageInformation_mode_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfAllAxis=", _wrap_mrcImageInformation_sdOfAllAxis_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfAllAxis", _wrap_mrcImageInformation_sdOfAllAxis_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "aveOfAllAxis=", _wrap_mrcImageInformation_aveOfAllAxis_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "aveOfAllAxis", _wrap_mrcImageInformation_aveOfAllAxis_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresOfHighValueArea=", _wrap_mrcImageInformation_thresOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresOfHighValueArea", _wrap_mrcImageInformation_thresOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfHighValueArea=", _wrap_mrcImageInformation_meanOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfHighValueArea", _wrap_mrcImageInformation_meanOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfHighValueArea=", _wrap_mrcImageInformation_sdOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfHighValueArea", _wrap_mrcImageInformation_sdOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfHighValueArea=", _wrap_mrcImageInformation_seOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfHighValueArea", _wrap_mrcImageInformation_seOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxOfHighValueArea=", _wrap_mrcImageInformation_maxOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxOfHighValueArea", _wrap_mrcImageInformation_maxOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minOfHighValueArea=", _wrap_mrcImageInformation_minOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minOfHighValueArea", _wrap_mrcImageInformation_minOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "medianOfHighValueArea=", _wrap_mrcImageInformation_medianOfHighValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "medianOfHighValueArea", _wrap_mrcImageInformation_medianOfHighValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresOfLowValueArea=", _wrap_mrcImageInformation_thresOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresOfLowValueArea", _wrap_mrcImageInformation_thresOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfLowValueArea=", _wrap_mrcImageInformation_meanOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "meanOfLowValueArea", _wrap_mrcImageInformation_meanOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfLowValueArea=", _wrap_mrcImageInformation_sdOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "sdOfLowValueArea", _wrap_mrcImageInformation_sdOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfLowValueArea=", _wrap_mrcImageInformation_seOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "seOfLowValueArea", _wrap_mrcImageInformation_seOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxOfLowValueArea=", _wrap_mrcImageInformation_maxOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "maxOfLowValueArea", _wrap_mrcImageInformation_maxOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minOfLowValueArea=", _wrap_mrcImageInformation_minOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "minOfLowValueArea", _wrap_mrcImageInformation_minOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "medianOfLowValueArea=", _wrap_mrcImageInformation_medianOfLowValueArea_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "medianOfLowValueArea", _wrap_mrcImageInformation_medianOfLowValueArea_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagXrange=", _wrap_mrcImageInformation_flagXrange_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagXrange", _wrap_mrcImageInformation_flagXrange_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagYrange=", _wrap_mrcImageInformation_flagYrange_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagYrange", _wrap_mrcImageInformation_flagYrange_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagZrange=", _wrap_mrcImageInformation_flagZrange_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagZrange", _wrap_mrcImageInformation_flagZrange_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "XrangeMin=", _wrap_mrcImageInformation_XrangeMin_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "XrangeMin", _wrap_mrcImageInformation_XrangeMin_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "XrangeMax=", _wrap_mrcImageInformation_XrangeMax_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "XrangeMax", _wrap_mrcImageInformation_XrangeMax_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "YrangeMin=", _wrap_mrcImageInformation_YrangeMin_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "YrangeMin", _wrap_mrcImageInformation_YrangeMin_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "YrangeMax=", _wrap_mrcImageInformation_YrangeMax_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "YrangeMax", _wrap_mrcImageInformation_YrangeMax_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "ZrangeMin=", _wrap_mrcImageInformation_ZrangeMin_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "ZrangeMin", _wrap_mrcImageInformation_ZrangeMin_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "ZrangeMax=", _wrap_mrcImageInformation_ZrangeMax_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "ZrangeMax", _wrap_mrcImageInformation_ZrangeMax_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagCentre=", _wrap_mrcImageInformation_flagCentre_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "flagCentre", _wrap_mrcImageInformation_flagCentre_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreX=", _wrap_mrcImageInformation_CentreX_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreX", _wrap_mrcImageInformation_CentreX_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreY=", _wrap_mrcImageInformation_CentreY_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreY", _wrap_mrcImageInformation_CentreY_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreZ=", _wrap_mrcImageInformation_CentreZ_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "CentreZ", _wrap_mrcImageInformation_CentreZ_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresHigh=", _wrap_mrcImageInformation_thresHigh_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresHigh", _wrap_mrcImageInformation_thresHigh_get, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresLow=", _wrap_mrcImageInformation_thresLow_set, -1);
  rb_define_method(SwigClassMrcImageInformation.klass, "thresLow", _wrap_mrcImageInformation_thresLow_get, -1);
  SwigClassMrcImageInformation.mark = 0;
  SwigClassMrcImageInformation.destroy = (void (*)(void *)) free_mrcImageInformation;
  SwigClassMrcImageInformation.trackObjects = 0;
  rb_define_const(mMolvieRuby, "MeanOfAll", SWIG_From_int((int)(meanOfAll)));
  rb_define_const(mMolvieRuby, "MeanOfSphereSurface", SWIG_From_int((int)(meanOfSphereSurface)));
  rb_define_const(mMolvieRuby, "MeanOfCylinderSurface", SWIG_From_int((int)(meanOfCylinderSurface)));
  rb_define_const(mMolvieRuby, "MeanOfEdge", SWIG_From_int((int)(meanOfEdge)));
  rb_define_const(mMolvieRuby, "MeanOfCentre", SWIG_From_int((int)(meanOfCentre)));
  rb_define_const(mMolvieRuby, "MeanOfSparse", SWIG_From_int((int)(meanOfSparse)));
  rb_define_const(mMolvieRuby, "MeanOf2DEdgeY", SWIG_From_int((int)(meanOf2DEdgeY)));
  rb_define_const(mMolvieRuby, "RMSofAllPixels", SWIG_From_int((int)(RMSofAllPixels)));
  rb_define_const(mMolvieRuby, "SdOfAllAxis", SWIG_From_int((int)(sdOfAllAxis)));
  rb_define_const(mMolvieRuby, "MeanOfHighValueArea", SWIG_From_int((int)(meanOfHighValueArea)));
  rb_define_const(mMolvieRuby, "MeanOfLowValueArea", SWIG_From_int((int)(meanOfLowValueArea)));
  rb_define_const(mMolvieRuby, "MeanOfLowValueAreaAndHighValueArea", SWIG_From_int((int)(meanOfLowValueAreaAndHighValueArea)));
  rb_define_const(mMolvieRuby, "MrcPixelRePart", SWIG_From_int((int)(mrcPixelRePart)));
  rb_define_const(mMolvieRuby, "MrcPixelImPart", SWIG_From_int((int)(mrcPixelImPart)));
  rb_define_const(mMolvieRuby, "MrcPixelSigmaPart", SWIG_From_int((int)(mrcPixelSigmaPart)));
  rb_define_const(mMolvieRuby, "MrcPixelMag", SWIG_From_int((int)(mrcPixelMag)));
  rb_define_const(mMolvieRuby, "MrcPixelPow", SWIG_From_int((int)(mrcPixelPow)));
  rb_define_const(mMolvieRuby, "MrcPixelLogMag", SWIG_From_int((int)(mrcPixelLogMag)));
  rb_define_const(mMolvieRuby, "MrcPixelLogPow", SWIG_From_int((int)(mrcPixelLogPow)));
  rb_define_const(mMolvieRuby, "MrcPixelPhase", SWIG_From_int((int)(mrcPixelPhase)));
  rb_define_const(mMolvieRuby, "MrcPixelHowNearest", SWIG_From_int((int)(mrcPixelHowNearest)));
  rb_define_const(mMolvieRuby, "MrcPixelHowLinear", SWIG_From_int((int)(mrcPixelHowLinear)));
  rb_define_const(mMolvieRuby, "MrcPixelHowCubicConv", SWIG_From_int((int)(mrcPixelHowCubicConv)));
  rb_define_const(mMolvieRuby, "MrcPixelHowPolySig", SWIG_From_int((int)(mrcPixelHowPolySig)));
  
  SwigClassLmrcImageSmoothingInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageSmoothingInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageSmoothingInfo, (void *) &SwigClassLmrcImageSmoothingInfo);
  rb_define_alloc_func(SwigClassLmrcImageSmoothingInfo.klass, _wrap_lmrcImageSmoothingInfo_allocate);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "initialize", _wrap_new_lmrcImageSmoothingInfo, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "mode=", _wrap_lmrcImageSmoothingInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "mode", _wrap_lmrcImageSmoothingInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sx=", _wrap_lmrcImageSmoothingInfo_sx_set, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sx", _wrap_lmrcImageSmoothingInfo_sx_get, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sy=", _wrap_lmrcImageSmoothingInfo_sy_set, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sy", _wrap_lmrcImageSmoothingInfo_sy_get, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sz=", _wrap_lmrcImageSmoothingInfo_sz_set, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sz", _wrap_lmrcImageSmoothingInfo_sz_get, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sigma=", _wrap_lmrcImageSmoothingInfo_sigma_set, -1);
  rb_define_method(SwigClassLmrcImageSmoothingInfo.klass, "sigma", _wrap_lmrcImageSmoothingInfo_sigma_get, -1);
  SwigClassLmrcImageSmoothingInfo.mark = 0;
  SwigClassLmrcImageSmoothingInfo.destroy = (void (*)(void *)) free_lmrcImageSmoothingInfo;
  SwigClassLmrcImageSmoothingInfo.trackObjects = 0;
  
  SwigClassLmrcImageCVEInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageCVEInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageCVEInfo, (void *) &SwigClassLmrcImageCVEInfo);
  rb_define_alloc_func(SwigClassLmrcImageCVEInfo.klass, _wrap_lmrcImageCVEInfo_allocate);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "initialize", _wrap_new_lmrcImageCVEInfo, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sx=", _wrap_lmrcImageCVEInfo_sx_set, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sx", _wrap_lmrcImageCVEInfo_sx_get, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sy=", _wrap_lmrcImageCVEInfo_sy_set, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sy", _wrap_lmrcImageCVEInfo_sy_get, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sz=", _wrap_lmrcImageCVEInfo_sz_set, -1);
  rb_define_method(SwigClassLmrcImageCVEInfo.klass, "sz", _wrap_lmrcImageCVEInfo_sz_get, -1);
  SwigClassLmrcImageCVEInfo.mark = 0;
  SwigClassLmrcImageCVEInfo.destroy = (void (*)(void *)) free_lmrcImageCVEInfo;
  SwigClassLmrcImageCVEInfo.trackObjects = 0;
  
  SwigClassLmrcImageTfunctionInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageTfunctionInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageTfunctionInfo, (void *) &SwigClassLmrcImageTfunctionInfo);
  rb_define_alloc_func(SwigClassLmrcImageTfunctionInfo.klass, _wrap_lmrcImageTfunctionInfo_allocate);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "initialize", _wrap_new_lmrcImageTfunctionInfo, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sx=", _wrap_lmrcImageTfunctionInfo_sx_set, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sx", _wrap_lmrcImageTfunctionInfo_sx_get, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sy=", _wrap_lmrcImageTfunctionInfo_sy_set, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sy", _wrap_lmrcImageTfunctionInfo_sy_get, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sz=", _wrap_lmrcImageTfunctionInfo_sz_set, -1);
  rb_define_method(SwigClassLmrcImageTfunctionInfo.klass, "sz", _wrap_lmrcImageTfunctionInfo_sz_get, -1);
  SwigClassLmrcImageTfunctionInfo.mark = 0;
  SwigClassLmrcImageTfunctionInfo.destroy = (void (*)(void *)) free_lmrcImageTfunctionInfo;
  SwigClassLmrcImageTfunctionInfo.trackObjects = 0;
  
  SwigClassLmrcImageHighlightInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageHighlightInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageHighlightInfo, (void *) &SwigClassLmrcImageHighlightInfo);
  rb_define_alloc_func(SwigClassLmrcImageHighlightInfo.klass, _wrap_lmrcImageHighlightInfo_allocate);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "initialize", _wrap_new_lmrcImageHighlightInfo, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "mode=", _wrap_lmrcImageHighlightInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "mode", _wrap_lmrcImageHighlightInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "Bias=", _wrap_lmrcImageHighlightInfo_Bias_set, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "Bias", _wrap_lmrcImageHighlightInfo_Bias_get, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "Grad=", _wrap_lmrcImageHighlightInfo_Grad_set, -1);
  rb_define_method(SwigClassLmrcImageHighlightInfo.klass, "Grad", _wrap_lmrcImageHighlightInfo_Grad_get, -1);
  SwigClassLmrcImageHighlightInfo.mark = 0;
  SwigClassLmrcImageHighlightInfo.destroy = (void (*)(void *)) free_lmrcImageHighlightInfo;
  SwigClassLmrcImageHighlightInfo.trackObjects = 0;
  
  SwigClassLmrcImageLowPassFilterInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageLowPassFilterInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageLowPassFilterInfo, (void *) &SwigClassLmrcImageLowPassFilterInfo);
  rb_define_alloc_func(SwigClassLmrcImageLowPassFilterInfo.klass, _wrap_lmrcImageLowPassFilterInfo_allocate);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "initialize", _wrap_new_lmrcImageLowPassFilterInfo, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "mode=", _wrap_lmrcImageLowPassFilterInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "mode", _wrap_lmrcImageLowPassFilterInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "hvp=", _wrap_lmrcImageLowPassFilterInfo_hvp_set, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "hvp", _wrap_lmrcImageLowPassFilterInfo_hvp_get, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "width=", _wrap_lmrcImageLowPassFilterInfo_width_set, -1);
  rb_define_method(SwigClassLmrcImageLowPassFilterInfo.klass, "width", _wrap_lmrcImageLowPassFilterInfo_width_get, -1);
  SwigClassLmrcImageLowPassFilterInfo.mark = 0;
  SwigClassLmrcImageLowPassFilterInfo.destroy = (void (*)(void *)) free_lmrcImageLowPassFilterInfo;
  SwigClassLmrcImageLowPassFilterInfo.trackObjects = 0;
  
  SwigClassLmrcImageHighPassFilterInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageHighPassFilterInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageHighPassFilterInfo, (void *) &SwigClassLmrcImageHighPassFilterInfo);
  rb_define_alloc_func(SwigClassLmrcImageHighPassFilterInfo.klass, _wrap_lmrcImageHighPassFilterInfo_allocate);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "initialize", _wrap_new_lmrcImageHighPassFilterInfo, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "mode=", _wrap_lmrcImageHighPassFilterInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "mode", _wrap_lmrcImageHighPassFilterInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "hvp=", _wrap_lmrcImageHighPassFilterInfo_hvp_set, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "hvp", _wrap_lmrcImageHighPassFilterInfo_hvp_get, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "width=", _wrap_lmrcImageHighPassFilterInfo_width_set, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "width", _wrap_lmrcImageHighPassFilterInfo_width_get, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "pathWindowLow=", _wrap_lmrcImageHighPassFilterInfo_pathWindowLow_set, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "pathWindowLow", _wrap_lmrcImageHighPassFilterInfo_pathWindowLow_get, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "pathWindowHigh=", _wrap_lmrcImageHighPassFilterInfo_pathWindowHigh_set, -1);
  rb_define_method(SwigClassLmrcImageHighPassFilterInfo.klass, "pathWindowHigh", _wrap_lmrcImageHighPassFilterInfo_pathWindowHigh_get, -1);
  SwigClassLmrcImageHighPassFilterInfo.mark = 0;
  SwigClassLmrcImageHighPassFilterInfo.destroy = (void (*)(void *)) free_lmrcImageHighPassFilterInfo;
  SwigClassLmrcImageHighPassFilterInfo.trackObjects = 0;
  
  SwigClassLmrcImageBandPassFilterInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageBandPassFilterInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageBandPassFilterInfo, (void *) &SwigClassLmrcImageBandPassFilterInfo);
  rb_define_alloc_func(SwigClassLmrcImageBandPassFilterInfo.klass, _wrap_lmrcImageBandPassFilterInfo_allocate);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "initialize", _wrap_new_lmrcImageBandPassFilterInfo, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "mode=", _wrap_lmrcImageBandPassFilterInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "mode", _wrap_lmrcImageBandPassFilterInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "hvl=", _wrap_lmrcImageBandPassFilterInfo_hvl_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "hvl", _wrap_lmrcImageBandPassFilterInfo_hvl_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "hvh=", _wrap_lmrcImageBandPassFilterInfo_hvh_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "hvh", _wrap_lmrcImageBandPassFilterInfo_hvh_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "wl=", _wrap_lmrcImageBandPassFilterInfo_wl_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "wl", _wrap_lmrcImageBandPassFilterInfo_wl_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "wh=", _wrap_lmrcImageBandPassFilterInfo_wh_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "wh", _wrap_lmrcImageBandPassFilterInfo_wh_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "flagLowWeight=", _wrap_lmrcImageBandPassFilterInfo_flagLowWeight_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "flagLowWeight", _wrap_lmrcImageBandPassFilterInfo_flagLowWeight_get, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "lowWeight=", _wrap_lmrcImageBandPassFilterInfo_lowWeight_set, -1);
  rb_define_method(SwigClassLmrcImageBandPassFilterInfo.klass, "lowWeight", _wrap_lmrcImageBandPassFilterInfo_lowWeight_get, -1);
  SwigClassLmrcImageBandPassFilterInfo.mark = 0;
  SwigClassLmrcImageBandPassFilterInfo.destroy = (void (*)(void *)) free_lmrcImageBandPassFilterInfo;
  SwigClassLmrcImageBandPassFilterInfo.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "mrcInit", _wrap_mrcInit, -1);
  rb_define_module_function(mMolvieRuby, "mrcDefaultHeaderValueSet", _wrap_mrcDefaultHeaderValueSet, -1);
  rb_define_module_function(mMolvieRuby, "mrcDefaultHeaderValueSetOnlyFixedValue", _wrap_mrcDefaultHeaderValueSetOnlyFixedValue, -1);
  rb_define_module_function(mMolvieRuby, "mrcHiddenDataSet", _wrap_mrcHiddenDataSet, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageFree", _wrap_mrcImageFree, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerInit", _wrap_mrcTailerInit, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerCopy", _wrap_mrcTailerCopy, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileReadGeneral", _wrap_mrcFileReadGeneral, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageReadGeneral", _wrap_mrcImageReadGeneral, -1);
  rb_define_module_function(mMolvieRuby, "mrcHeaderReadGeneral", _wrap_mrcHeaderReadGeneral, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerReadGeneral", _wrap_mrcTailerReadGeneral, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileGeneralListPrint", _wrap_mrcFileGeneralListPrint, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileRead", _wrap_mrcFileRead, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageRead", _wrap_mrcImageRead, -1);
  rb_define_module_function(mMolvieRuby, "mrcHeaderRead", _wrap_mrcHeaderRead, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerRead", _wrap_mrcTailerRead, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileReadFEIextendedMRC", _wrap_mrcFileReadFEIextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageReadFEIextendedMRC", _wrap_mrcImageReadFEIextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcHeaderReadFEIextendedMRC", _wrap_mrcHeaderReadFEIextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerReadFEIextendedMRC", _wrap_mrcTailerReadFEIextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileReadIMODextendedMRC", _wrap_mrcFileReadIMODextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageReadIMODextendedMRC", _wrap_mrcImageReadIMODextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcHeaderReadIMODextendedMRC", _wrap_mrcHeaderReadIMODextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerReadIMODextendedMRC", _wrap_mrcTailerReadIMODextendedMRC, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageByteSwap", _wrap_mrcImageByteSwap, -1);
  rb_define_const(mMolvieRuby, "MrcFileWriteMode_InfoPrint", SWIG_From_int((int)(1)));
  rb_define_const(mMolvieRuby, "MrcFileWriteMode_NoCallForStatData", SWIG_From_int((int)(2)));
  rb_define_module_function(mMolvieRuby, "mrcFileWrite", _wrap_mrcFileWrite, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageWrite", _wrap_mrcImageWrite, -1);
  rb_define_module_function(mMolvieRuby, "mrcHeaderWrite", _wrap_mrcHeaderWrite, -1);
  rb_define_module_function(mMolvieRuby, "mrcTailerWrite", _wrap_mrcTailerWrite, -1);
  rb_define_module_function(mMolvieRuby, "mrcFileWriteLowerResolution", _wrap_mrcFileWriteLowerResolution, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageDataGetbyAU", _wrap_mrcImageDataGetbyAU, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataGet", _wrap_mrcPixelDataGet, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelsDataGet", _wrap_mrcPixelsDataGet, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataGetbyMatrix3D", _wrap_mrcPixelDataGetbyMatrix3D, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataGetFloatImage", _wrap_mrcPixelDataGetFloatImage, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataGetFloatFTRe", _wrap_mrcPixelDataGetFloatFTRe, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataGetFloatFTIm", _wrap_mrcPixelDataGetFloatFTIm, -1);
  rb_define_module_function(mMolvieRuby, "mrcInfoSet", _wrap_mrcInfoSet, -1);
  rb_define_const(mMolvieRuby, "MrcImageDataSetModeCentre", SWIG_From_int((int)(mrcImageDataSetModeCentre)));
  rb_define_const(mMolvieRuby, "MrcImageDataSetModeOrigin", SWIG_From_int((int)(mrcImageDataSetModeOrigin)));
  rb_define_module_function(mMolvieRuby, "mrcImageDataSet", _wrap_mrcImageDataSet, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageDataSetbyAU", _wrap_mrcImageDataSetbyAU, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataSet", _wrap_mrcPixelDataSet, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataSetFloatImage", _wrap_mrcPixelDataSetFloatImage, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataSetFloatFTRe", _wrap_mrcPixelDataSetFloatFTRe, -1);
  rb_define_module_function(mMolvieRuby, "mrcPixelDataSetFloatFTIm", _wrap_mrcPixelDataSetFloatFTIm, -1);
  rb_define_module_function(mMolvieRuby, "mrcStatDataSet", _wrap_mrcStatDataSet, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageXSection", _wrap_lmrcImageXSection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageYSection", _wrap_lmrcImageYSection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageXProjection", _wrap_lmrcImageXProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageYProjection", _wrap_lmrcImageYProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageZProjection", _wrap_lmrcImageZProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageXYProjection", _wrap_lmrcImageXYProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageYZProjection", _wrap_lmrcImageYZProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageZXProjection", _wrap_lmrcImageZXProjection, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram", _wrap_lmrcImageHistgram, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram2", _wrap_lmrcImageHistgram2, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram5", _wrap_lmrcImageHistgram5, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram3", _wrap_lmrcImageHistgram3, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram4", _wrap_lmrcImageHistgram4, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHistgram6", _wrap_lmrcImageHistgram6, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageInformation", _wrap_lmrcImageInformation, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCopy", _wrap_lmrcImageCopy, -1);
  rb_define_module_function(mMolvieRuby, "IsFloatImage", _wrap_IsFloatImage, -1);
  rb_define_module_function(mMolvieRuby, "IsFloatFT", _wrap_IsFloatFT, -1);
  rb_define_module_function(mMolvieRuby, "IsImage", _wrap_IsImage, -1);
  rb_define_module_function(mMolvieRuby, "IsFT", _wrap_IsFT, -1);
  rb_define_module_function(mMolvieRuby, "IsFFT", _wrap_IsFFT, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageInfoSet", _wrap_mrcImageInfoSet, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageDividedByImage", _wrap_lmrcImageDividedByImage, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImagetMapForZero", _wrap_lmrcImagetMapForZero, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageSN", _wrap_lmrcImageSN, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageDividedByReal", _wrap_lmrcImageDividedByReal, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageDividedByRealForOnlyPositive", _wrap_lmrcImageDividedByRealForOnlyPositive, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageAddedByReal", _wrap_lmrcImageAddedByReal, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageStdDev", _wrap_lmrcImageStdDev, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageStdErr", _wrap_lmrcImageStdErr, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageAdd", _wrap_lmrcImageAdd, -1);
  rb_define_module_function(mMolvieRuby, "lmrcSQRImageAdd", _wrap_lmrcSQRImageAdd, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageSquare", _wrap_lmrcImageSquare, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRoot", _wrap_lmrcImageRoot, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageAbs", _wrap_lmrcImageAbs, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageConvolution", _wrap_lmrcImageConvolution, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageToIntImage", _wrap_lmrcImageToIntImage, -1);
  rb_define_module_function(mMolvieRuby, "lfft2d", _wrap_lfft2d, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageFFT", _wrap_lmrcImageFFT, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageFFTFirstDimensionOnly", _wrap_lmrcImageFFTFirstDimensionOnly, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFFTFGconj", _wrap_lmrcFFTFGconj, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFFTFxG", _wrap_lmrcFFTFxG, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCorrelation", _wrap_lmrcImageCorrelation, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCorrelationModePrint", _wrap_lmrcImageCorrelationModePrint, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageFFTCenterChange", _wrap_lmrcImageFFTCenterChange, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImagePattersonFunctionCalc", _wrap_lmrcImagePattersonFunctionCalc, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImagePattersonFunctionPrint", _wrap_lmrcImagePattersonFunctionPrint, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageGuinierFunctionPrint", _wrap_lmrcImageGuinierFunctionPrint, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCorrelationWithCTFCompensation", _wrap_lmrcImageCorrelationWithCTFCompensation, -1);
  rb_define_module_function(mMolvieRuby, "mrcError", _wrap_mrcError, -1);
  rb_define_module_function(mMolvieRuby, "mrcErrorMsg", _wrap_mrcErrorMsg, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoXAxisMag", _wrap_lmrcFSInfoXAxisMag, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoXAxisPhase", _wrap_lmrcFSInfoXAxisPhase, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoYAxisMag", _wrap_lmrcFSInfoYAxisMag, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoYAxisPhase", _wrap_lmrcFSInfoYAxisPhase, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistribution", _wrap_lmrcFSInfoScatteringAngularDistribution, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionAverage", _wrap_lmrcFSInfoScatteringAngularDistributionAverage, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionSD", _wrap_lmrcFSInfoScatteringAngularDistributionSD, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoSpacing", _wrap_lmrcFSInfoSpacing, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionDivisionAverage", _wrap_lmrcFSInfoScatteringAngularDistributionDivisionAverage, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionDivisionSD", _wrap_lmrcFSInfoScatteringAngularDistributionDivisionSD, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR", _wrap_lmrcFSInfoScatteringAngularDistributionDivisionAverageDelR, -1);
  rb_define_module_function(mMolvieRuby, "lmrcFSInfoScatteringAngularDistributionDivisionSDDelR", _wrap_lmrcFSInfoScatteringAngularDistributionDivisionSDDelR, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCheckSameSize", _wrap_lmrcImageCheckSameSize, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCheckFFT", _wrap_lmrcImageCheckFFT, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageSmoothingModeInfo", _wrap_lmrcImageSmoothingModeInfo, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageSmoothing", _wrap_lmrcImageSmoothing, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCVE", _wrap_lmrcImageCVE, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageTfunction", _wrap_lmrcImageTfunction, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHighlightingInfoPrint", _wrap_lmrcImageHighlightingInfoPrint, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHighlighting", _wrap_lmrcImageHighlighting, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageLowPassFilter", _wrap_lmrcImageLowPassFilter, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageHighPassFilter", _wrap_lmrcImageHighPassFilter, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageBandPassFilter", _wrap_lmrcImageBandPassFilter, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageShrink", _wrap_lmrcImageShrink, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageShift", _wrap_lmrcImageShift, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageShiftFollowingGC", _wrap_lmrcImageShiftFollowingGC, -1);
  rb_define_module_function(mMolvieRuby, "mrcInfoPrint", _wrap_mrcInfoPrint, -1);
  rb_define_const(mMolvieRuby, "LmrcImageMultiCTFCompensationSolventFlatteningModeDensityPeakIsSolvent", SWIG_From_int((int)(lmrcImageMultiCTFCompensationSolventFlatteningModeDensityPeakIsSolvent)));
  rb_define_const(mMolvieRuby, "LmrcImageMultiCTFCompensationSolventFlatteningModeDefinedSTDIsSolvent", SWIG_From_int((int)(lmrcImageMultiCTFCompensationSolventFlatteningModeDefinedSTDIsSolvent)));
  
  SwigClassLmrcImageMultiCTFCompensationInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageMultiCTFCompensationInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageMultiCTFCompensationInfo, (void *) &SwigClassLmrcImageMultiCTFCompensationInfo);
  rb_define_alloc_func(SwigClassLmrcImageMultiCTFCompensationInfo.klass, _wrap_lmrcImageMultiCTFCompensationInfo_allocate);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "initialize", _wrap_new_lmrcImageMultiCTFCompensationInfo, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "maxiteration=", _wrap_lmrcImageMultiCTFCompensationInfo_maxiteration_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "maxiteration", _wrap_lmrcImageMultiCTFCompensationInfo_maxiteration_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "okrms=", _wrap_lmrcImageMultiCTFCompensationInfo_okrms_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "okrms", _wrap_lmrcImageMultiCTFCompensationInfo_okrms_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "diversefactor=", _wrap_lmrcImageMultiCTFCompensationInfo_diversefactor_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "diversefactor", _wrap_lmrcImageMultiCTFCompensationInfo_diversefactor_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "z=", _wrap_lmrcImageMultiCTFCompensationInfo_z_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "z", _wrap_lmrcImageMultiCTFCompensationInfo_z_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "nhist=", _wrap_lmrcImageMultiCTFCompensationInfo_nhist_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "nhist", _wrap_lmrcImageMultiCTFCompensationInfo_nhist_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "logfile=", _wrap_lmrcImageMultiCTFCompensationInfo_logfile_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "logfile", _wrap_lmrcImageMultiCTFCompensationInfo_logfile_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "solventMode=", _wrap_lmrcImageMultiCTFCompensationInfo_solventMode_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "solventMode", _wrap_lmrcImageMultiCTFCompensationInfo_solventMode_get, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "definedSTD=", _wrap_lmrcImageMultiCTFCompensationInfo_definedSTD_set, -1);
  rb_define_method(SwigClassLmrcImageMultiCTFCompensationInfo.klass, "definedSTD", _wrap_lmrcImageMultiCTFCompensationInfo_definedSTD_get, -1);
  SwigClassLmrcImageMultiCTFCompensationInfo.mark = 0;
  SwigClassLmrcImageMultiCTFCompensationInfo.destroy = (void (*)(void *)) free_lmrcImageMultiCTFCompensationInfo;
  SwigClassLmrcImageMultiCTFCompensationInfo.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "lmrcImageMultiCTFCompensationInfoInit", _wrap_lmrcImageMultiCTFCompensationInfoInit, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageMultiCTFCompensationInfoSet", _wrap_lmrcImageMultiCTFCompensationInfoSet, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageMultiCTFCompensation", _wrap_lmrcImageMultiCTFCompensation, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCTFObservation", _wrap_lmrcImageCTFObservation, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImagesCTFObservation", _wrap_lmrcImagesCTFObservation, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageCTFCompensation", _wrap_lmrcImageCTFCompensation, -1);
  
  SwigClassLmrcImageCTFSNInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageCTFSNInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageCTFSNInfo, (void *) &SwigClassLmrcImageCTFSNInfo);
  rb_define_alloc_func(SwigClassLmrcImageCTFSNInfo.klass, _wrap_lmrcImageCTFSNInfo_allocate);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "initialize", _wrap_new_lmrcImageCTFSNInfo, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "mode=", _wrap_lmrcImageCTFSNInfo_mode_set, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "mode", _wrap_lmrcImageCTFSNInfo_mode_get, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "deg1=", _wrap_lmrcImageCTFSNInfo_deg1_set, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "deg1", _wrap_lmrcImageCTFSNInfo_deg1_get, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "deg2=", _wrap_lmrcImageCTFSNInfo_deg2_set, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "deg2", _wrap_lmrcImageCTFSNInfo_deg2_get, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "ctf=", _wrap_lmrcImageCTFSNInfo_ctf_set, -1);
  rb_define_method(SwigClassLmrcImageCTFSNInfo.klass, "ctf", _wrap_lmrcImageCTFSNInfo_ctf_get, -1);
  SwigClassLmrcImageCTFSNInfo.mark = 0;
  SwigClassLmrcImageCTFSNInfo.destroy = (void (*)(void *)) free_lmrcImageCTFSNInfo;
  SwigClassLmrcImageCTFSNInfo.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "lmrcImageCTFSN", _wrap_lmrcImageCTFSN, -1);
  
  SwigClassMrcImageFourierPowerSpectrum.klass = rb_define_class_under(mMolvieRuby, "MrcImageFourierPowerSpectrum", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_mrcImageFourierPowerSpectrum, (void *) &SwigClassMrcImageFourierPowerSpectrum);
  rb_define_alloc_func(SwigClassMrcImageFourierPowerSpectrum.klass, _wrap_mrcImageFourierPowerSpectrum_allocate);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "initialize", _wrap_new_mrcImageFourierPowerSpectrum, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "n=", _wrap_mrcImageFourierPowerSpectrum_n_set, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "n", _wrap_mrcImageFourierPowerSpectrum_n_get, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "d=", _wrap_mrcImageFourierPowerSpectrum_d_set, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "d", _wrap_mrcImageFourierPowerSpectrum_d_get, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "h=", _wrap_mrcImageFourierPowerSpectrum_h_set, -1);
  rb_define_method(SwigClassMrcImageFourierPowerSpectrum.klass, "h", _wrap_mrcImageFourierPowerSpectrum_h_get, -1);
  SwigClassMrcImageFourierPowerSpectrum.mark = 0;
  SwigClassMrcImageFourierPowerSpectrum.destroy = (void (*)(void *)) free_mrcImageFourierPowerSpectrum;
  SwigClassMrcImageFourierPowerSpectrum.trackObjects = 0;
  
  SwigClassLmrcImageFourierPowerSpectrumInfo.klass = rb_define_class_under(mMolvieRuby, "LmrcImageFourierPowerSpectrumInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_lmrcImageFourierPowerSpectrumInfo, (void *) &SwigClassLmrcImageFourierPowerSpectrumInfo);
  rb_define_alloc_func(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, _wrap_lmrcImageFourierPowerSpectrumInfo_allocate);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "initialize", _wrap_new_lmrcImageFourierPowerSpectrumInfo, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dX=", _wrap_lmrcImageFourierPowerSpectrumInfo_dX_set, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dX", _wrap_lmrcImageFourierPowerSpectrumInfo_dX_get, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dY=", _wrap_lmrcImageFourierPowerSpectrumInfo_dY_set, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dY", _wrap_lmrcImageFourierPowerSpectrumInfo_dY_get, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dZ=", _wrap_lmrcImageFourierPowerSpectrumInfo_dZ_set, -1);
  rb_define_method(SwigClassLmrcImageFourierPowerSpectrumInfo.klass, "dZ", _wrap_lmrcImageFourierPowerSpectrumInfo_dZ_get, -1);
  SwigClassLmrcImageFourierPowerSpectrumInfo.mark = 0;
  SwigClassLmrcImageFourierPowerSpectrumInfo.destroy = (void (*)(void *)) free_lmrcImageFourierPowerSpectrumInfo;
  SwigClassLmrcImageFourierPowerSpectrumInfo.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "lmrcImageFourierPowerSpectrumMakeSpectrum", _wrap_lmrcImageFourierPowerSpectrumMakeSpectrum, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageFourierPowerSpectrumDeleteSpectrum", _wrap_lmrcImageFourierPowerSpectrumDeleteSpectrum, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageFourierPowerSpectrum", _wrap_lmrcImageFourierPowerSpectrum, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DModePrint", _wrap_lmrcImageRotation3DModePrint, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DFollowingEulerAngle", _wrap_lmrcImageRotation3DFollowingEulerAngle, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DFollowingMatrix3D", _wrap_lmrcImageRotation3DFollowingMatrix3D, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DFollowingEulerAngle2", _wrap_lmrcImageRotation3DFollowingEulerAngle2, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DFollowingMatrix3D2", _wrap_lmrcImageRotation3DFollowingMatrix3D2, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation3DZXY", _wrap_lmrcImageRotation3DZXY, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation2D", _wrap_lmrcImageRotation2D, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageRotation2DPeriodicBoundary", _wrap_lmrcImageRotation2DPeriodicBoundary, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageSectionGetModeDescription", _wrap_mrcImageSectionGetModeDescription, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageSectionGet", _wrap_mrcImageSectionGet, -1);
  rb_define_module_function(mMolvieRuby, "mrcImageSectionSet", _wrap_mrcImageSectionSet, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageMaxDataGet", _wrap_lmrcImageMaxDataGet, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageStackAlloc", _wrap_lmrcImageStackAlloc, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImageStackPush", _wrap_lmrcImageStackPush, -1);
  rb_define_module_function(mMolvieRuby, "lmrcImagePixelValueSort", _wrap_lmrcImagePixelValueSort, -1);
  rb_define_const(mMolvieRuby, "PDB_FILE_RECORD_FULL_LENGTH", SWIG_From_int((int)((80))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RECORD_START", SWIG_From_int((int)((0))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RECORD_LENGTH", SWIG_From_int((int)((6))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ATOM_NUMBER_START", SWIG_From_int((int)((6))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ATOM_NUMBER_LENGTH", SWIG_From_int((int)((5))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ATOM_NAME_START", SWIG_From_int((int)((12))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ATOM_NAME_LENGTH", SWIG_From_int((int)((4))));
  rb_define_const(mMolvieRuby, "PDB_FILE_LOCATION_START", SWIG_From_int((int)((16))));
  rb_define_const(mMolvieRuby, "PDB_FILE_LOCATION_LENGTH", SWIG_From_int((int)((1))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RESIDUE_START", SWIG_From_int((int)((17))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RESIDUE_LENGTH", SWIG_From_int((int)((3))));
  rb_define_const(mMolvieRuby, "PDB_FILE_CHAIN_IDENT_START", SWIG_From_int((int)((21))));
  rb_define_const(mMolvieRuby, "PDB_FILE_CHAIN_IDENT_LENGTH", SWIG_From_int((int)((1))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RESNUM_START", SWIG_From_int((int)((22))));
  rb_define_const(mMolvieRuby, "PDB_FILE_RESNUM_LENGTH", SWIG_From_int((int)((4))));
  rb_define_const(mMolvieRuby, "PDB_FILE_INSERTION_START", SWIG_From_int((int)((26))));
  rb_define_const(mMolvieRuby, "PDB_FILE_INSERTION_LENGTH", SWIG_From_int((int)((1))));
  rb_define_const(mMolvieRuby, "PDB_FILE_X_START", SWIG_From_int((int)((30))));
  rb_define_const(mMolvieRuby, "PDB_FILE_X_LENGTH", SWIG_From_int((int)((8))));
  rb_define_const(mMolvieRuby, "PDB_FILE_Y_START", SWIG_From_int((int)((38))));
  rb_define_const(mMolvieRuby, "PDB_FILE_Y_LENGTH", SWIG_From_int((int)((8))));
  rb_define_const(mMolvieRuby, "PDB_FILE_Z_START", SWIG_From_int((int)((46))));
  rb_define_const(mMolvieRuby, "PDB_FILE_Z_LENGTH", SWIG_From_int((int)((8))));
  rb_define_const(mMolvieRuby, "PDB_FILE_OCCUPANCY_START", SWIG_From_int((int)((54))));
  rb_define_const(mMolvieRuby, "PDB_FILE_OCCUPANCY_LENGTH", SWIG_From_int((int)((6))));
  rb_define_const(mMolvieRuby, "PDB_FILE_TEMPERATURE_START", SWIG_From_int((int)((60))));
  rb_define_const(mMolvieRuby, "PDB_FILE_TEMPERATURE_LENGTH", SWIG_From_int((int)((6))));
  rb_define_const(mMolvieRuby, "PDB_FILE_FOOT_START", SWIG_From_int((int)((67))));
  rb_define_const(mMolvieRuby, "PDB_FILE_FOOT_LENGTH", SWIG_From_int((int)((3))));
  rb_define_const(mMolvieRuby, "PDB_FILE_FOOTNOTE_START", SWIG_From_int((int)((70))));
  rb_define_const(mMolvieRuby, "PDB_FILE_FOOTNOTE_LENGTH", SWIG_From_int((int)((10))));
  rb_define_const(mMolvieRuby, "PDB_FILE_SEGID_START", SWIG_From_int((int)((72))));
  rb_define_const(mMolvieRuby, "PDB_FILE_SEGID_LENGTH", SWIG_From_int((int)((4))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ELEMENT_START", SWIG_From_int((int)((76))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ELEMENT_LENGTH", SWIG_From_int((int)((2))));
  rb_define_const(mMolvieRuby, "PDB_FILE_CHARGE_START", SWIG_From_int((int)((78))));
  rb_define_const(mMolvieRuby, "PDB_FILE_CHARGE_LENGTH", SWIG_From_int((int)((2))));
  rb_define_const(mMolvieRuby, "MAX_RESIDUE_NUMBER", SWIG_From_int((int)((20))));
  rb_define_const(mMolvieRuby, "RESIDUE_ONECHAR_MODE", SWIG_From_int((int)((1))));
  rb_define_const(mMolvieRuby, "RESIDUE_THREECHAR_MODE", SWIG_From_int((int)((3))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U11_START", SWIG_From_int((int)((28))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U11_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U22_START", SWIG_From_int((int)((35))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U22_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U33_START", SWIG_From_int((int)((42))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U33_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U12_START", SWIG_From_int((int)((49))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U12_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U13_START", SWIG_From_int((int)((56))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U13_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U23_START", SWIG_From_int((int)((63))));
  rb_define_const(mMolvieRuby, "PDB_FILE_ANISOU_U23_LENGTH", SWIG_From_int((int)((7))));
  rb_define_const(mMolvieRuby, "PdbRecordAtom", SWIG_FromCharPtr("(ATOM  )"));
  rb_define_const(mMolvieRuby, "PdbRecordHeteroAtom", SWIG_FromCharPtr("(HETATM)"));
  rb_define_const(mMolvieRuby, "PdbRecordANISOU", SWIG_FromCharPtr("(ANISOU)"));
  rb_define_const(mMolvieRuby, "PdbRecordHelix", SWIG_FromCharPtr("(HELIX )"));
  rb_define_const(mMolvieRuby, "PdbRecordSheet", SWIG_FromCharPtr("(SHEET )"));
  rb_define_const(mMolvieRuby, "PdbRecordTurn", SWIG_FromCharPtr("(TURN  )"));
  rb_define_const(mMolvieRuby, "PdbRecordEnd", SWIG_FromCharPtr("(END   )"));
  
  SwigClassResidueName.klass = rb_define_class_under(mMolvieRuby, "ResidueName", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_residueName, (void *) &SwigClassResidueName);
  rb_define_alloc_func(SwigClassResidueName.klass, _wrap_residueName_allocate);
  rb_define_method(SwigClassResidueName.klass, "initialize", _wrap_new_residueName, -1);
  rb_define_method(SwigClassResidueName.klass, "residueName3=", _wrap_residueName_residueName3_set, -1);
  rb_define_method(SwigClassResidueName.klass, "residueName3", _wrap_residueName_residueName3_get, -1);
  rb_define_method(SwigClassResidueName.klass, "residueName1=", _wrap_residueName_residueName1_set, -1);
  rb_define_method(SwigClassResidueName.klass, "residueName1", _wrap_residueName_residueName1_get, -1);
  SwigClassResidueName.mark = 0;
  SwigClassResidueName.destroy = (void (*)(void *)) free_residueName;
  SwigClassResidueName.trackObjects = 0;
  
  SwigClassPdbCoord.klass = rb_define_class_under(mMolvieRuby, "PdbCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbCoord, (void *) &SwigClassPdbCoord);
  rb_define_alloc_func(SwigClassPdbCoord.klass, _wrap_pdbCoord_allocate);
  rb_define_method(SwigClassPdbCoord.klass, "initialize", _wrap_new_pdbCoord, -1);
  rb_define_method(SwigClassPdbCoord.klass, "x=", _wrap_pdbCoord_x_set, -1);
  rb_define_method(SwigClassPdbCoord.klass, "x", _wrap_pdbCoord_x_get, -1);
  rb_define_method(SwigClassPdbCoord.klass, "y=", _wrap_pdbCoord_y_set, -1);
  rb_define_method(SwigClassPdbCoord.klass, "y", _wrap_pdbCoord_y_get, -1);
  rb_define_method(SwigClassPdbCoord.klass, "z=", _wrap_pdbCoord_z_set, -1);
  rb_define_method(SwigClassPdbCoord.klass, "z", _wrap_pdbCoord_z_get, -1);
  SwigClassPdbCoord.mark = 0;
  SwigClassPdbCoord.destroy = (void (*)(void *)) free_pdbCoord;
  SwigClassPdbCoord.trackObjects = 0;
  rb_define_const(mMolvieRuby, "HelixClassRightHandedAlpha", SWIG_From_int((int)(HelixClassRightHandedAlpha)));
  rb_define_const(mMolvieRuby, "HelixClassRightHandedOmega", SWIG_From_int((int)(HelixClassRightHandedOmega)));
  rb_define_const(mMolvieRuby, "HelixClassRightHandedPi", SWIG_From_int((int)(HelixClassRightHandedPi)));
  rb_define_const(mMolvieRuby, "HelixClassRightHandedGammda", SWIG_From_int((int)(HelixClassRightHandedGammda)));
  rb_define_const(mMolvieRuby, "HelixClassRightHanded310", SWIG_From_int((int)(HelixClassRightHanded310)));
  rb_define_const(mMolvieRuby, "HelixClassLeftHandedAlpha", SWIG_From_int((int)(HelixClassLeftHandedAlpha)));
  rb_define_const(mMolvieRuby, "HelixClassLeftHandedOmega", SWIG_From_int((int)(HelixClassLeftHandedOmega)));
  rb_define_const(mMolvieRuby, "HelixClassLeftHandedGammda", SWIG_From_int((int)(HelixClassLeftHandedGammda)));
  rb_define_const(mMolvieRuby, "HelixClassPolyProline", SWIG_From_int((int)(HelixClassPolyProline)));
  
  SwigClassPdbSecondaryStructureHelix.klass = rb_define_class_under(mMolvieRuby, "PdbSecondaryStructureHelix", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbSecondaryStructureHelix, (void *) &SwigClassPdbSecondaryStructureHelix);
  rb_define_alloc_func(SwigClassPdbSecondaryStructureHelix.klass, _wrap_pdbSecondaryStructureHelix_allocate);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initialize", _wrap_new_pdbSecondaryStructureHelix, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "serNum=", _wrap_pdbSecondaryStructureHelix_serNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "serNum", _wrap_pdbSecondaryStructureHelix_serNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "helixID=", _wrap_pdbSecondaryStructureHelix_helixID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "helixID", _wrap_pdbSecondaryStructureHelix_helixID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initResName=", _wrap_pdbSecondaryStructureHelix_initResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initResName", _wrap_pdbSecondaryStructureHelix_initResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initChainID=", _wrap_pdbSecondaryStructureHelix_initChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initChainID", _wrap_pdbSecondaryStructureHelix_initChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initSeqNum=", _wrap_pdbSecondaryStructureHelix_initSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initSeqNum", _wrap_pdbSecondaryStructureHelix_initSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initICode=", _wrap_pdbSecondaryStructureHelix_initICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "initICode", _wrap_pdbSecondaryStructureHelix_initICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endResName=", _wrap_pdbSecondaryStructureHelix_endResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endResName", _wrap_pdbSecondaryStructureHelix_endResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endChainID=", _wrap_pdbSecondaryStructureHelix_endChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endChainID", _wrap_pdbSecondaryStructureHelix_endChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endSeqNum=", _wrap_pdbSecondaryStructureHelix_endSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endSeqNum", _wrap_pdbSecondaryStructureHelix_endSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endICode=", _wrap_pdbSecondaryStructureHelix_endICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "endICode", _wrap_pdbSecondaryStructureHelix_endICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "helixClass=", _wrap_pdbSecondaryStructureHelix_helixClass_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "helixClass", _wrap_pdbSecondaryStructureHelix_helixClass_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "comment=", _wrap_pdbSecondaryStructureHelix_comment_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "comment", _wrap_pdbSecondaryStructureHelix_comment_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "length=", _wrap_pdbSecondaryStructureHelix_length_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureHelix.klass, "length", _wrap_pdbSecondaryStructureHelix_length_get, -1);
  SwigClassPdbSecondaryStructureHelix.mark = 0;
  SwigClassPdbSecondaryStructureHelix.destroy = (void (*)(void *)) free_pdbSecondaryStructureHelix;
  SwigClassPdbSecondaryStructureHelix.trackObjects = 0;
  
  SwigClassPdbSecondaryStructureSheet.klass = rb_define_class_under(mMolvieRuby, "PdbSecondaryStructureSheet", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbSecondaryStructureSheet, (void *) &SwigClassPdbSecondaryStructureSheet);
  rb_define_alloc_func(SwigClassPdbSecondaryStructureSheet.klass, _wrap_pdbSecondaryStructureSheet_allocate);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initialize", _wrap_new_pdbSecondaryStructureSheet, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "strand=", _wrap_pdbSecondaryStructureSheet_strand_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "strand", _wrap_pdbSecondaryStructureSheet_strand_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "sheetID=", _wrap_pdbSecondaryStructureSheet_sheetID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "sheetID", _wrap_pdbSecondaryStructureSheet_sheetID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "numStrands=", _wrap_pdbSecondaryStructureSheet_numStrands_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "numStrands", _wrap_pdbSecondaryStructureSheet_numStrands_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initResName=", _wrap_pdbSecondaryStructureSheet_initResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initResName", _wrap_pdbSecondaryStructureSheet_initResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initChainID=", _wrap_pdbSecondaryStructureSheet_initChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initChainID", _wrap_pdbSecondaryStructureSheet_initChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initSeqNum=", _wrap_pdbSecondaryStructureSheet_initSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initSeqNum", _wrap_pdbSecondaryStructureSheet_initSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initICode=", _wrap_pdbSecondaryStructureSheet_initICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "initICode", _wrap_pdbSecondaryStructureSheet_initICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endResName=", _wrap_pdbSecondaryStructureSheet_endResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endResName", _wrap_pdbSecondaryStructureSheet_endResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endChainID=", _wrap_pdbSecondaryStructureSheet_endChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endChainID", _wrap_pdbSecondaryStructureSheet_endChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endSeqNum=", _wrap_pdbSecondaryStructureSheet_endSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endSeqNum", _wrap_pdbSecondaryStructureSheet_endSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endICode=", _wrap_pdbSecondaryStructureSheet_endICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "endICode", _wrap_pdbSecondaryStructureSheet_endICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "sense=", _wrap_pdbSecondaryStructureSheet_sense_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "sense", _wrap_pdbSecondaryStructureSheet_sense_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curAtom=", _wrap_pdbSecondaryStructureSheet_curAtom_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curAtom", _wrap_pdbSecondaryStructureSheet_curAtom_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curResName=", _wrap_pdbSecondaryStructureSheet_curResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curResName", _wrap_pdbSecondaryStructureSheet_curResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curChainID=", _wrap_pdbSecondaryStructureSheet_curChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curChainID", _wrap_pdbSecondaryStructureSheet_curChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curResSeq=", _wrap_pdbSecondaryStructureSheet_curResSeq_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curResSeq", _wrap_pdbSecondaryStructureSheet_curResSeq_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curICode=", _wrap_pdbSecondaryStructureSheet_curICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "curICode", _wrap_pdbSecondaryStructureSheet_curICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevAtom=", _wrap_pdbSecondaryStructureSheet_prevAtom_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevAtom", _wrap_pdbSecondaryStructureSheet_prevAtom_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevResName=", _wrap_pdbSecondaryStructureSheet_prevResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevResName", _wrap_pdbSecondaryStructureSheet_prevResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevChainID=", _wrap_pdbSecondaryStructureSheet_prevChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevChainID", _wrap_pdbSecondaryStructureSheet_prevChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevResSeq=", _wrap_pdbSecondaryStructureSheet_prevResSeq_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevResSeq", _wrap_pdbSecondaryStructureSheet_prevResSeq_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevICode=", _wrap_pdbSecondaryStructureSheet_prevICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureSheet.klass, "prevICode", _wrap_pdbSecondaryStructureSheet_prevICode_get, -1);
  SwigClassPdbSecondaryStructureSheet.mark = 0;
  SwigClassPdbSecondaryStructureSheet.destroy = (void (*)(void *)) free_pdbSecondaryStructureSheet;
  SwigClassPdbSecondaryStructureSheet.trackObjects = 0;
  
  SwigClassPdbSecondaryStructureTurn.klass = rb_define_class_under(mMolvieRuby, "PdbSecondaryStructureTurn", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbSecondaryStructureTurn, (void *) &SwigClassPdbSecondaryStructureTurn);
  rb_define_alloc_func(SwigClassPdbSecondaryStructureTurn.klass, _wrap_pdbSecondaryStructureTurn_allocate);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initialize", _wrap_new_pdbSecondaryStructureTurn, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "serNum=", _wrap_pdbSecondaryStructureTurn_serNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "serNum", _wrap_pdbSecondaryStructureTurn_serNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "turnID=", _wrap_pdbSecondaryStructureTurn_turnID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "turnID", _wrap_pdbSecondaryStructureTurn_turnID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initResName=", _wrap_pdbSecondaryStructureTurn_initResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initResName", _wrap_pdbSecondaryStructureTurn_initResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initChainID=", _wrap_pdbSecondaryStructureTurn_initChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initChainID", _wrap_pdbSecondaryStructureTurn_initChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initSeqNum=", _wrap_pdbSecondaryStructureTurn_initSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initSeqNum", _wrap_pdbSecondaryStructureTurn_initSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initICode=", _wrap_pdbSecondaryStructureTurn_initICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "initICode", _wrap_pdbSecondaryStructureTurn_initICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endResName=", _wrap_pdbSecondaryStructureTurn_endResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endResName", _wrap_pdbSecondaryStructureTurn_endResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endChainID=", _wrap_pdbSecondaryStructureTurn_endChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endChainID", _wrap_pdbSecondaryStructureTurn_endChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endSeqNum=", _wrap_pdbSecondaryStructureTurn_endSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endSeqNum", _wrap_pdbSecondaryStructureTurn_endSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endICode=", _wrap_pdbSecondaryStructureTurn_endICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "endICode", _wrap_pdbSecondaryStructureTurn_endICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "comment=", _wrap_pdbSecondaryStructureTurn_comment_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureTurn.klass, "comment", _wrap_pdbSecondaryStructureTurn_comment_get, -1);
  SwigClassPdbSecondaryStructureTurn.mark = 0;
  SwigClassPdbSecondaryStructureTurn.destroy = (void (*)(void *)) free_pdbSecondaryStructureTurn;
  SwigClassPdbSecondaryStructureTurn.trackObjects = 0;
  
  SwigClassPdbSecondaryStructureNo.klass = rb_define_class_under(mMolvieRuby, "PdbSecondaryStructureNo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbSecondaryStructureNo, (void *) &SwigClassPdbSecondaryStructureNo);
  rb_define_alloc_func(SwigClassPdbSecondaryStructureNo.klass, _wrap_pdbSecondaryStructureNo_allocate);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initialize", _wrap_new_pdbSecondaryStructureNo, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "serNum=", _wrap_pdbSecondaryStructureNo_serNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "serNum", _wrap_pdbSecondaryStructureNo_serNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "noID=", _wrap_pdbSecondaryStructureNo_noID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "noID", _wrap_pdbSecondaryStructureNo_noID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initResName=", _wrap_pdbSecondaryStructureNo_initResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initResName", _wrap_pdbSecondaryStructureNo_initResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initChainID=", _wrap_pdbSecondaryStructureNo_initChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initChainID", _wrap_pdbSecondaryStructureNo_initChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initSeqNum=", _wrap_pdbSecondaryStructureNo_initSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initSeqNum", _wrap_pdbSecondaryStructureNo_initSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initICode=", _wrap_pdbSecondaryStructureNo_initICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "initICode", _wrap_pdbSecondaryStructureNo_initICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endResName=", _wrap_pdbSecondaryStructureNo_endResName_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endResName", _wrap_pdbSecondaryStructureNo_endResName_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endChainID=", _wrap_pdbSecondaryStructureNo_endChainID_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endChainID", _wrap_pdbSecondaryStructureNo_endChainID_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endSeqNum=", _wrap_pdbSecondaryStructureNo_endSeqNum_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endSeqNum", _wrap_pdbSecondaryStructureNo_endSeqNum_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endICode=", _wrap_pdbSecondaryStructureNo_endICode_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "endICode", _wrap_pdbSecondaryStructureNo_endICode_get, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "comment=", _wrap_pdbSecondaryStructureNo_comment_set, -1);
  rb_define_method(SwigClassPdbSecondaryStructureNo.klass, "comment", _wrap_pdbSecondaryStructureNo_comment_get, -1);
  SwigClassPdbSecondaryStructureNo.mark = 0;
  SwigClassPdbSecondaryStructureNo.destroy = (void (*)(void *)) free_pdbSecondaryStructureNo;
  SwigClassPdbSecondaryStructureNo.trackObjects = 0;
  rb_define_const(mMolvieRuby, "PdbFileSecondaryStructureModeNo", SWIG_From_int((int)(pdbFileSecondaryStructureModeNo)));
  rb_define_const(mMolvieRuby, "PdbFileSecondaryStructureModeHelix", SWIG_From_int((int)(pdbFileSecondaryStructureModeHelix)));
  rb_define_const(mMolvieRuby, "PdbFileSecondaryStructureModeSheet", SWIG_From_int((int)(pdbFileSecondaryStructureModeSheet)));
  rb_define_const(mMolvieRuby, "PdbFileSecondaryStructureModeTurn", SWIG_From_int((int)(pdbFileSecondaryStructureModeTurn)));
  
  SwigClassPdbFileSecondaryStructureRecord.klass = rb_define_class_under(mMolvieRuby, "PdbFileSecondaryStructureRecord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbFileSecondaryStructureRecord, (void *) &SwigClassPdbFileSecondaryStructureRecord);
  rb_define_alloc_func(SwigClassPdbFileSecondaryStructureRecord.klass, _wrap_pdbFileSecondaryStructureRecord_allocate);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "initialize", _wrap_new_pdbFileSecondaryStructureRecord, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "mode=", _wrap_pdbFileSecondaryStructureRecord_mode_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "mode", _wrap_pdbFileSecondaryStructureRecord_mode_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "helix=", _wrap_pdbFileSecondaryStructureRecord_helix_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "helix", _wrap_pdbFileSecondaryStructureRecord_helix_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "sheet=", _wrap_pdbFileSecondaryStructureRecord_sheet_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "sheet", _wrap_pdbFileSecondaryStructureRecord_sheet_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "turn=", _wrap_pdbFileSecondaryStructureRecord_turn_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "turn", _wrap_pdbFileSecondaryStructureRecord_turn_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "no=", _wrap_pdbFileSecondaryStructureRecord_no_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "no", _wrap_pdbFileSecondaryStructureRecord_no_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "prev=", _wrap_pdbFileSecondaryStructureRecord_prev_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "prev", _wrap_pdbFileSecondaryStructureRecord_prev_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "next=", _wrap_pdbFileSecondaryStructureRecord_next_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructureRecord.klass, "next", _wrap_pdbFileSecondaryStructureRecord_next_get, -1);
  SwigClassPdbFileSecondaryStructureRecord.mark = 0;
  SwigClassPdbFileSecondaryStructureRecord.destroy = (void (*)(void *)) free_pdbFileSecondaryStructureRecord;
  SwigClassPdbFileSecondaryStructureRecord.trackObjects = 0;
  
  SwigClassPdbFileSecondaryStructure.klass = rb_define_class_under(mMolvieRuby, "PdbFileSecondaryStructure", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbFileSecondaryStructure, (void *) &SwigClassPdbFileSecondaryStructure);
  rb_define_alloc_func(SwigClassPdbFileSecondaryStructure.klass, _wrap_pdbFileSecondaryStructure_allocate);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "initialize", _wrap_new_pdbFileSecondaryStructure, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "nSecondaryStructure=", _wrap_pdbFileSecondaryStructure_nSecondaryStructure_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "nSecondaryStructure", _wrap_pdbFileSecondaryStructure_nSecondaryStructure_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "top=", _wrap_pdbFileSecondaryStructure_top_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "top", _wrap_pdbFileSecondaryStructure_top_get, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "SecondaryStructure=", _wrap_pdbFileSecondaryStructure_SecondaryStructure_set, -1);
  rb_define_method(SwigClassPdbFileSecondaryStructure.klass, "SecondaryStructure", _wrap_pdbFileSecondaryStructure_SecondaryStructure_get, -1);
  SwigClassPdbFileSecondaryStructure.mark = 0;
  SwigClassPdbFileSecondaryStructure.destroy = (void (*)(void *)) free_pdbFileSecondaryStructure;
  SwigClassPdbFileSecondaryStructure.trackObjects = 0;
  
  SwigClassPdbRecord.klass = rb_define_class_under(mMolvieRuby, "PdbRecord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbRecord, (void *) &SwigClassPdbRecord);
  rb_define_alloc_func(SwigClassPdbRecord.klass, _wrap_pdbRecord_allocate);
  rb_define_method(SwigClassPdbRecord.klass, "initialize", _wrap_new_pdbRecord, -1);
  rb_define_method(SwigClassPdbRecord.klass, "FullRecord=", _wrap_pdbRecord_FullRecord_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "FullRecord", _wrap_pdbRecord_FullRecord_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Record=", _wrap_pdbRecord_Record_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Record", _wrap_pdbRecord_Record_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "AtomSerialNumber=", _wrap_pdbRecord_AtomSerialNumber_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "AtomSerialNumber", _wrap_pdbRecord_AtomSerialNumber_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "AtomName=", _wrap_pdbRecord_AtomName_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "AtomName", _wrap_pdbRecord_AtomName_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "LocationIndicator=", _wrap_pdbRecord_LocationIndicator_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "LocationIndicator", _wrap_pdbRecord_LocationIndicator_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ResidueName=", _wrap_pdbRecord_ResidueName_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ResidueName", _wrap_pdbRecord_ResidueName_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ChainIdentifier=", _wrap_pdbRecord_ChainIdentifier_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ChainIdentifier", _wrap_pdbRecord_ChainIdentifier_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ResidueSequenceNumber=", _wrap_pdbRecord_ResidueSequenceNumber_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "ResidueSequenceNumber", _wrap_pdbRecord_ResidueSequenceNumber_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "InsertionCode=", _wrap_pdbRecord_InsertionCode_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "InsertionCode", _wrap_pdbRecord_InsertionCode_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Coord=", _wrap_pdbRecord_Coord_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Coord", _wrap_pdbRecord_Coord_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Occupancy=", _wrap_pdbRecord_Occupancy_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Occupancy", _wrap_pdbRecord_Occupancy_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "TemperatureFactor=", _wrap_pdbRecord_TemperatureFactor_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "TemperatureFactor", _wrap_pdbRecord_TemperatureFactor_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "FootnoteNumber=", _wrap_pdbRecord_FootnoteNumber_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "FootnoteNumber", _wrap_pdbRecord_FootnoteNumber_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Footnote=", _wrap_pdbRecord_Footnote_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Footnote", _wrap_pdbRecord_Footnote_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "SegID=", _wrap_pdbRecord_SegID_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "SegID", _wrap_pdbRecord_SegID_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Element=", _wrap_pdbRecord_Element_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Element", _wrap_pdbRecord_Element_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Charge=", _wrap_pdbRecord_Charge_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "Charge", _wrap_pdbRecord_Charge_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "flagANISOU=", _wrap_pdbRecord_flagANISOU_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "flagANISOU", _wrap_pdbRecord_flagANISOU_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "pAtomforANISOU=", _wrap_pdbRecord_pAtomforANISOU_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "pAtomforANISOU", _wrap_pdbRecord_pAtomforANISOU_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U11=", _wrap_pdbRecord_U11_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U11", _wrap_pdbRecord_U11_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U22=", _wrap_pdbRecord_U22_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U22", _wrap_pdbRecord_U22_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U33=", _wrap_pdbRecord_U33_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U33", _wrap_pdbRecord_U33_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U12=", _wrap_pdbRecord_U12_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U12", _wrap_pdbRecord_U12_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U13=", _wrap_pdbRecord_U13_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U13", _wrap_pdbRecord_U13_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U23=", _wrap_pdbRecord_U23_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "U23", _wrap_pdbRecord_U23_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "prev=", _wrap_pdbRecord_prev_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "prev", _wrap_pdbRecord_prev_get, -1);
  rb_define_method(SwigClassPdbRecord.klass, "next=", _wrap_pdbRecord_next_set, -1);
  rb_define_method(SwigClassPdbRecord.klass, "next", _wrap_pdbRecord_next_get, -1);
  SwigClassPdbRecord.mark = 0;
  SwigClassPdbRecord.destroy = (void (*)(void *)) free_pdbRecord;
  SwigClassPdbRecord.trackObjects = 0;
  
  SwigClassPdbFile.klass = rb_define_class_under(mMolvieRuby, "PdbFile", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbFile, (void *) &SwigClassPdbFile);
  rb_define_alloc_func(SwigClassPdbFile.klass, _wrap_pdbFile_allocate);
  rb_define_method(SwigClassPdbFile.klass, "initialize", _wrap_new_pdbFile, -1);
  rb_define_method(SwigClassPdbFile.klass, "top=", _wrap_pdbFile_top_set, -1);
  rb_define_method(SwigClassPdbFile.klass, "top", _wrap_pdbFile_top_get, -1);
  rb_define_method(SwigClassPdbFile.klass, "PDB=", _wrap_pdbFile_PDB_set, -1);
  rb_define_method(SwigClassPdbFile.klass, "PDB", _wrap_pdbFile_PDB_get, -1);
  rb_define_method(SwigClassPdbFile.klass, "nAtom=", _wrap_pdbFile_nAtom_set, -1);
  rb_define_method(SwigClassPdbFile.klass, "nAtom", _wrap_pdbFile_nAtom_get, -1);
  rb_define_method(SwigClassPdbFile.klass, "second=", _wrap_pdbFile_second_set, -1);
  rb_define_method(SwigClassPdbFile.klass, "second", _wrap_pdbFile_second_get, -1);
  SwigClassPdbFile.mark = 0;
  SwigClassPdbFile.destroy = (void (*)(void *)) free_pdbFile;
  SwigClassPdbFile.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "pdbFileRead", _wrap_pdbFileRead, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileWrite", _wrap_pdbFileWrite, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileWriteCoord", _wrap_pdbFileWriteCoord, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileTableWrite", _wrap_pdbFileTableWrite, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileWriteSecondaryStructure", _wrap_pdbFileWriteSecondaryStructure, -1);
  rb_define_module_function(mMolvieRuby, "pdbMatrixFileFormat", _wrap_pdbMatrixFileFormat, -1);
  rb_define_module_function(mMolvieRuby, "pdbMatrixFileRead", _wrap_pdbMatrixFileRead, -1);
  rb_define_module_function(mMolvieRuby, "pdbMatrixFileWrite", _wrap_pdbMatrixFileWrite, -1);
  rb_define_module_function(mMolvieRuby, "pdbTrans", _wrap_pdbTrans, -1);
  rb_define_module_function(mMolvieRuby, "pdbTransCuda", _wrap_pdbTransCuda, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileResidueSequenceNumberIncrementAll", _wrap_pdbFileResidueSequenceNumberIncrementAll, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileResidueSequenceNumberIncrement", _wrap_pdbFileResidueSequenceNumberIncrement, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileChainIdentifierSetAll", _wrap_pdbFileChainIdentifierSetAll, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileChainIdentifierSet", _wrap_pdbFileChainIdentifierSet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileChainIdentifierGet", _wrap_pdbFileChainIdentifierGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileTemperatureFactorGet", _wrap_pdbFileTemperatureFactorGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileTemperatureFactorSet", _wrap_pdbFileTemperatureFactorSet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileOccupancyGet", _wrap_pdbFileOccupancyGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileOccupancySet", _wrap_pdbFileOccupancySet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileCoordSet", _wrap_pdbFileCoordSet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileCoordGet", _wrap_pdbFileCoordGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileResidueSequenceNumberGet", _wrap_pdbFileResidueSequenceNumberGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileResidueNameGet", _wrap_pdbFileResidueNameGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileTop", _wrap_pdbFileTop, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileTopPointer", _wrap_pdbFileTopPointer, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileNext", _wrap_pdbFileNext, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileNextAtom", _wrap_pdbFileNextAtom, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileNextCA", _wrap_pdbFileNextCA, -1);
  rb_define_module_function(mMolvieRuby, "pdbFilePrev", _wrap_pdbFilePrev, -1);
  rb_define_module_function(mMolvieRuby, "pdbFilePrevAtom", _wrap_pdbFilePrevAtom, -1);
  rb_define_module_function(mMolvieRuby, "pdbFilePrevCA", _wrap_pdbFilePrevCA, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileEnd", _wrap_pdbFileEnd, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileGoToEnd", _wrap_pdbFileGoToEnd, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsEndLine", _wrap_pdbFileIsEndLine, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsAtom", _wrap_pdbFileIsAtom, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsANISOU", _wrap_pdbFileIsANISOU, -1);
  rb_define_module_function(mMolvieRuby, "pdbRecordIsNearby", _wrap_pdbRecordIsNearby, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsCA", _wrap_pdbFileIsCA, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsNegative", _wrap_pdbFileIsNegative, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsPositive", _wrap_pdbFileIsPositive, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsCharge", _wrap_pdbFileIsCharge, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsSecondaryStructure", _wrap_pdbFileIsSecondaryStructure, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsHelix", _wrap_pdbFileIsHelix, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsSheet", _wrap_pdbFileIsSheet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileIsTurn", _wrap_pdbFileIsTurn, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileNew", _wrap_pdbFileNew, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileAppend", _wrap_pdbFileAppend, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileFree", _wrap_pdbFileFree, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileRecordPrint", _wrap_pdbFileRecordPrint, -1);
  rb_define_module_function(mMolvieRuby, "pdbZValueGet", _wrap_pdbZValueGet, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileRecordTablePrint", _wrap_pdbFileRecordTablePrint, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileSecondaryStructureRecordPrint", _wrap_pdbFileSecondaryStructureRecordPrint, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileCAOnlyCopy", _wrap_pdbFileCAOnlyCopy, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileCAOnlyCopyAll", _wrap_pdbFileCAOnlyCopyAll, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileCopyAll", _wrap_pdbFileCopyAll, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileAppendAll", _wrap_pdbFileAppendAll, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileOneRecordCopy", _wrap_pdbFileOneRecordCopy, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileOneProteinCopy", _wrap_pdbFileOneProteinCopy, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationFollowingEulerAngle", _wrap_pdbRotationFollowingEulerAngle, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationFollowingEulerAngleInverse", _wrap_pdbRotationFollowingEulerAngleInverse, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationXYZ", _wrap_pdbRotationXYZ, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationZYX", _wrap_pdbRotationZYX, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationZXY", _wrap_pdbRotationZXY, -1);
  rb_define_module_function(mMolvieRuby, "pdbRotationYXZ", _wrap_pdbRotationYXZ, -1);
  rb_define_module_function(mMolvieRuby, "pdbSecondaryStructureSetFromPDB", _wrap_pdbSecondaryStructureSetFromPDB, -1);
  rb_define_module_function(mMolvieRuby, "pdbNoSecondaryStructureSetFromPDB", _wrap_pdbNoSecondaryStructureSetFromPDB, -1);
  rb_define_module_function(mMolvieRuby, "pdbSecondaryStructureAppend", _wrap_pdbSecondaryStructureAppend, -1);
  rb_define_module_function(mMolvieRuby, "pdbFileWithSecondaryStructure", _wrap_pdbFileWithSecondaryStructure, -1);
  
  SwigClassCameraInfo.klass = rb_define_class_under(mMolvieRuby, "CameraInfo", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_cameraInfo, (void *) &SwigClassCameraInfo);
  rb_define_alloc_func(SwigClassCameraInfo.klass, _wrap_cameraInfo_allocate);
  rb_define_method(SwigClassCameraInfo.klass, "initialize", _wrap_new_cameraInfo, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Fovy=", _wrap_cameraInfo_Fovy_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Fovy", _wrap_cameraInfo_Fovy_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Aspect=", _wrap_cameraInfo_Aspect_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Aspect", _wrap_cameraInfo_Aspect_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "ClipNear=", _wrap_cameraInfo_ClipNear_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "ClipNear", _wrap_cameraInfo_ClipNear_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "ClipFar=", _wrap_cameraInfo_ClipFar_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "ClipFar", _wrap_cameraInfo_ClipFar_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Eye=", _wrap_cameraInfo_Eye_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Eye", _wrap_cameraInfo_Eye_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Centre=", _wrap_cameraInfo_Centre_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Centre", _wrap_cameraInfo_Centre_get, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Up=", _wrap_cameraInfo_Up_set, -1);
  rb_define_method(SwigClassCameraInfo.klass, "Up", _wrap_cameraInfo_Up_get, -1);
  SwigClassCameraInfo.mark = 0;
  SwigClassCameraInfo.destroy = (void (*)(void *)) free_cameraInfo;
  SwigClassCameraInfo.trackObjects = 0;
  rb_define_const(mMolvieRuby, "None", SWIG_From_int((int)(none)));
  rb_define_const(mMolvieRuby, "Atom", SWIG_From_int((int)(atom)));
  rb_define_const(mMolvieRuby, "Stick", SWIG_From_int((int)(stick)));
  rb_define_const(mMolvieRuby, "Serial", SWIG_From_int((int)(serial)));
  rb_define_const(mMolvieRuby, "Residue", SWIG_From_int((int)(residue)));
  rb_define_const(mMolvieRuby, "Temp", SWIG_From_int((int)(temp)));
  rb_define_const(mMolvieRuby, "Sticktemp", SWIG_From_int((int)(sticktemp)));
  rb_define_const(mMolvieRuby, "Stickresidue", SWIG_From_int((int)(stickresidue)));
  rb_define_const(mMolvieRuby, "Normal", SWIG_From_int((int)(normal)));
  rb_define_const(mMolvieRuby, "Drive", SWIG_From_int((int)(drive)));
  rb_define_const(mMolvieRuby, "Parallel", SWIG_From_int((int)(parallel)));
  rb_define_const(mMolvieRuby, "Surface", SWIG_From_int((int)(surface)));
  rb_define_const(mMolvieRuby, "Multi", SWIG_From_int((int)(multi)));
  rb_define_const(mMolvieRuby, "Coaster", SWIG_From_int((int)(coaster)));
  
  SwigClassCoord.klass = rb_define_class_under(mMolvieRuby, "Coord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_Coord, (void *) &SwigClassCoord);
  rb_define_alloc_func(SwigClassCoord.klass, _wrap_Coord_allocate);
  rb_define_method(SwigClassCoord.klass, "initialize", _wrap_new_Coord, -1);
  rb_define_method(SwigClassCoord.klass, "x=", _wrap_Coord_x_set, -1);
  rb_define_method(SwigClassCoord.klass, "x", _wrap_Coord_x_get, -1);
  rb_define_method(SwigClassCoord.klass, "y=", _wrap_Coord_y_set, -1);
  rb_define_method(SwigClassCoord.klass, "y", _wrap_Coord_y_get, -1);
  rb_define_method(SwigClassCoord.klass, "z=", _wrap_Coord_z_set, -1);
  rb_define_method(SwigClassCoord.klass, "z", _wrap_Coord_z_get, -1);
  SwigClassCoord.mark = 0;
  SwigClassCoord.destroy = (void (*)(void *)) free_Coord;
  SwigClassCoord.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "lmolviePDBread", _wrap_lmolviePDBread, -1);
  rb_define_module_function(mMolvieRuby, "get_pdb", _wrap_get_pdb, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieInitNormal", _wrap_lmolvieInitNormal, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieIdleTest", _wrap_lmolvieIdleTest, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieIdleNormal", _wrap_lmolvieIdleNormal, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieDisplayTest", _wrap_lmolvieDisplayTest, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieDisplayNormal", _wrap_lmolvieDisplayNormal, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieReshapeNormal", _wrap_lmolvieReshapeNormal, -1);
  rb_define_module_function(mMolvieRuby, "myCameraRotateY", _wrap_myCameraRotateY, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouse", _wrap_lmolvieMouse, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseMotion", _wrap_lmolvieMouseMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMousePassiveMotion", _wrap_lmolvieMousePassiveMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseDrive", _wrap_lmolvieMouseDrive, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseMotionDrive", _wrap_lmolvieMouseMotionDrive, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMousePassiveMotionDrive", _wrap_lmolvieMousePassiveMotionDrive, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseParallel", _wrap_lmolvieMouseParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseMotionParallel", _wrap_lmolvieMouseMotionParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMousePassiveMotionParallel", _wrap_lmolvieMousePassiveMotionParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseMulti", _wrap_lmolvieMouseMulti, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMouseMotionMulti", _wrap_lmolvieMouseMotionMulti, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMousePassiveMotionMulti", _wrap_lmolvieMousePassiveMotionMulti, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieKeyboard", _wrap_lmolvieKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieKeyboardNormal", _wrap_lmolvieKeyboardNormal, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieKeyboardDrive", _wrap_lmolvieKeyboardDrive, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieKeyboardParallel", _wrap_lmolvieKeyboardParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieKeyboardSurface", _wrap_lmolvieKeyboardSurface, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieInitParallel", _wrap_lmolvieInitParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieDisplayParallel", _wrap_lmolvieDisplayParallel, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieReshapeParallel", _wrap_lmolvieReshapeParallel, -1);
  rb_define_module_function(mMolvieRuby, "operationModeGet", _wrap_operationModeGet, -1);
  rb_define_module_function(mMolvieRuby, "operationModeSet", _wrap_operationModeSet, -1);
  rb_define_module_function(mMolvieRuby, "myCameraRotateX", _wrap_myCameraRotateX, -1);
  rb_define_module_function(mMolvieRuby, "myCameraRotateZ", _wrap_myCameraRotateZ, -1);
  rb_define_module_function(mMolvieRuby, "myCameraEyeRotateX", _wrap_myCameraEyeRotateX, -1);
  rb_define_module_function(mMolvieRuby, "myCameraEyeRotateY", _wrap_myCameraEyeRotateY, -1);
  rb_define_module_function(mMolvieRuby, "myCameraTranslateX", _wrap_myCameraTranslateX, -1);
  rb_define_module_function(mMolvieRuby, "myCameraTranslateY", _wrap_myCameraTranslateY, -1);
  rb_define_module_function(mMolvieRuby, "myCameraTranslateZ", _wrap_myCameraTranslateZ, -1);
  rb_define_module_function(mMolvieRuby, "resetMyCamera", _wrap_resetMyCamera, -1);
  rb_define_module_function(mMolvieRuby, "getMyCamera", _wrap_getMyCamera, -1);
  rb_define_module_function(mMolvieRuby, "upCalc", _wrap_upCalc, -1);
  rb_define_module_function(mMolvieRuby, "moveMyCamera", _wrap_moveMyCamera, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieLightSet", _wrap_lmolvieLightSet, -1);
  rb_define_module_function(mMolvieRuby, "get_LightPos", _wrap_get_LightPos, -1);
  rb_define_module_function(mMolvieRuby, "monoSound", _wrap_monoSound, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieVoice", _wrap_lmolvieVoice, -1);
  rb_define_module_function(mMolvieRuby, "drawContour", _wrap_drawContour, -1);
  rb_define_module_function(mMolvieRuby, "scaleBarSwitch", _wrap_scaleBarSwitch, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerIdle", _wrap_lmolvieViewerIdle, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerKeyboard", _wrap_lmolvieViewerKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerSpecial", _wrap_lmolvieViewerSpecial, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerMouse", _wrap_lmolvieViewerMouse, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerMouseMotion", _wrap_lmolvieViewerMouseMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerMousePassiveMotion", _wrap_lmolvieViewerMousePassiveMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieViewerDisplay", _wrap_lmolvieViewerDisplay, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMrcViewerKeyboard", _wrap_lmolvieMrcViewerKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMrcViewerMouse", _wrap_lmolvieMrcViewerMouse, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMrcViewerMouseMotion", _wrap_lmolvieMrcViewerMouseMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMrcViewerMousePassiveMotion", _wrap_lmolvieMrcViewerMousePassiveMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieMrcViewerDisplay", _wrap_lmolvieMrcViewerDisplay, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieProjectionKeyboard", _wrap_lmolvieProjectionKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieProjectionMouse", _wrap_lmolvieProjectionMouse, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieProjectionMouseMotion", _wrap_lmolvieProjectionMouseMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieProjectionMousePassiveMotion", _wrap_lmolvieProjectionMousePassiveMotion, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieDockKeyboard", _wrap_lmolvieDockKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "displayMultiPDB1", _wrap_displayMultiPDB1, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieDockDisplay", _wrap_lmolvieDockDisplay, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieFlightKeyboard", _wrap_lmolvieFlightKeyboard, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieFlightDisplay", _wrap_lmolvieFlightDisplay, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieFlightIdle", _wrap_lmolvieFlightIdle, -1);
  rb_define_module_function(mMolvieRuby, "lmolvieTest", _wrap_lmolvieTest, -1);
  rb_define_module_function(mMolvieRuby, "myDisplayListMakeAtom", _wrap_myDisplayListMakeAtom, -1);
  rb_define_module_function(mMolvieRuby, "setDriveMyCamera", _wrap_setDriveMyCamera, -1);
  rb_define_module_function(mMolvieRuby, "resetDriveMyCamera", _wrap_resetDriveMyCamera, -1);
  rb_define_module_function(mMolvieRuby, "setCameraCentreTag", _wrap_setCameraCentreTag, -1);
  rb_define_singleton_method(mMolvieRuby, "drawatomc", _wrap_drawatomc_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomc=", _wrap_drawatomc_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomca", _wrap_drawatomca_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomca=", _wrap_drawatomca_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomo", _wrap_drawatomo_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomo=", _wrap_drawatomo_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomn", _wrap_drawatomn_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomn=", _wrap_drawatomn_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatoms", _wrap_drawatoms_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatoms=", _wrap_drawatoms_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomp", _wrap_drawatomp_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomp=", _wrap_drawatomp_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomh", _wrap_drawatomh_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomh=", _wrap_drawatomh_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomfe", _wrap_drawatomfe_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomfe=", _wrap_drawatomfe_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawstick", _wrap_drawstick_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawstick=", _wrap_drawstick_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawatomserial", _wrap_drawatomserial_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawatomserial=", _wrap_drawatomserial_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawresidue", _wrap_drawresidue_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawresidue=", _wrap_drawresidue_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawtemp", _wrap_drawtemp_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawtemp=", _wrap_drawtemp_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawsticktemp", _wrap_drawsticktemp_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawsticktemp=", _wrap_drawsticktemp_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawstickresidue", _wrap_drawstickresidue_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawstickresidue=", _wrap_drawstickresidue_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawsurface", _wrap_drawsurface_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawsurface=", _wrap_drawsurface_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawdistancefromtarget", _wrap_drawdistancefromtarget_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawdistancefromtarget=", _wrap_drawdistancefromtarget_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawwireframe", _wrap_drawwireframe_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawwireframe=", _wrap_drawwireframe_set, 1);
  rb_define_singleton_method(mMolvieRuby, "drawchain", _wrap_drawchain_get, 0);
  rb_define_singleton_method(mMolvieRuby, "drawchain=", _wrap_drawchain_set, 1);
  
  SwigClassPdbCenter.klass = rb_define_class_under(mMolvieRuby, "PdbCenter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_pdbCenter, (void *) &SwigClassPdbCenter);
  rb_define_alloc_func(SwigClassPdbCenter.klass, _wrap_pdbCenter_allocate);
  rb_define_method(SwigClassPdbCenter.klass, "initialize", _wrap_new_pdbCenter, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xCenter=", _wrap_pdbCenter_xCenter_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xCenter", _wrap_pdbCenter_xCenter_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yCenter=", _wrap_pdbCenter_yCenter_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yCenter", _wrap_pdbCenter_yCenter_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zCenter=", _wrap_pdbCenter_zCenter_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zCenter", _wrap_pdbCenter_zCenter_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xMax=", _wrap_pdbCenter_xMax_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xMax", _wrap_pdbCenter_xMax_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xMin=", _wrap_pdbCenter_xMin_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xMin", _wrap_pdbCenter_xMin_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xWidth=", _wrap_pdbCenter_xWidth_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "xWidth", _wrap_pdbCenter_xWidth_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yMax=", _wrap_pdbCenter_yMax_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yMax", _wrap_pdbCenter_yMax_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yMin=", _wrap_pdbCenter_yMin_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yMin", _wrap_pdbCenter_yMin_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yWidth=", _wrap_pdbCenter_yWidth_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "yWidth", _wrap_pdbCenter_yWidth_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zMax=", _wrap_pdbCenter_zMax_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zMax", _wrap_pdbCenter_zMax_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zMin=", _wrap_pdbCenter_zMin_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zMin", _wrap_pdbCenter_zMin_get, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zWidth=", _wrap_pdbCenter_zWidth_set, -1);
  rb_define_method(SwigClassPdbCenter.klass, "zWidth", _wrap_pdbCenter_zWidth_get, -1);
  SwigClassPdbCenter.mark = 0;
  SwigClassPdbCenter.destroy = (void (*)(void *)) free_pdbCenter;
  SwigClassPdbCenter.trackObjects = 0;
  
  SwigClassElementSwitch.klass = rb_define_class_under(mMolvieRuby, "ElementSwitch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_elementSwitch, (void *) &SwigClassElementSwitch);
  rb_define_alloc_func(SwigClassElementSwitch.klass, _wrap_elementSwitch_allocate);
  rb_define_method(SwigClassElementSwitch.klass, "initialize", _wrap_new_elementSwitch, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementC=", _wrap_elementSwitch_elementC_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementC", _wrap_elementSwitch_elementC_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementO=", _wrap_elementSwitch_elementO_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementO", _wrap_elementSwitch_elementO_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementN=", _wrap_elementSwitch_elementN_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementN", _wrap_elementSwitch_elementN_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementS=", _wrap_elementSwitch_elementS_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementS", _wrap_elementSwitch_elementS_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementP=", _wrap_elementSwitch_elementP_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementP", _wrap_elementSwitch_elementP_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementH=", _wrap_elementSwitch_elementH_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementH", _wrap_elementSwitch_elementH_get, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementFE=", _wrap_elementSwitch_elementFE_set, -1);
  rb_define_method(SwigClassElementSwitch.klass, "elementFE", _wrap_elementSwitch_elementFE_get, -1);
  SwigClassElementSwitch.mark = 0;
  SwigClassElementSwitch.destroy = (void (*)(void *)) free_elementSwitch;
  SwigClassElementSwitch.trackObjects = 0;
  
  SwigClassProteinStatus.klass = rb_define_class_under(mMolvieRuby, "ProteinStatus", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ProteinStatus, (void *) &SwigClassProteinStatus);
  rb_define_alloc_func(SwigClassProteinStatus.klass, _wrap_ProteinStatus_allocate);
  rb_define_method(SwigClassProteinStatus.klass, "initialize", _wrap_new_ProteinStatus, -1);
  rb_define_method(SwigClassProteinStatus.klass, "__pdbCenter=", _wrap_ProteinStatus___pdbCenter_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "__pdbCenter", _wrap_ProteinStatus___pdbCenter_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "__elementSwitch=", _wrap_ProteinStatus___elementSwitch_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "__elementSwitch", _wrap_ProteinStatus___elementSwitch_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_x=", _wrap_ProteinStatus_spin_x_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_x", _wrap_ProteinStatus_spin_x_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_y=", _wrap_ProteinStatus_spin_y_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_y", _wrap_ProteinStatus_spin_y_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_z=", _wrap_ProteinStatus_spin_z_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "spin_z", _wrap_ProteinStatus_spin_z_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "move_x=", _wrap_ProteinStatus_move_x_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "move_x", _wrap_ProteinStatus_move_x_get, -1);
  rb_define_method(SwigClassProteinStatus.klass, "move_y=", _wrap_ProteinStatus_move_y_set, -1);
  rb_define_method(SwigClassProteinStatus.klass, "move_y", _wrap_ProteinStatus_move_y_get, -1);
  SwigClassProteinStatus.mark = 0;
  SwigClassProteinStatus.destroy = (void (*)(void *)) free_ProteinStatus;
  SwigClassProteinStatus.trackObjects = 0;
  rb_define_module_function(mMolvieRuby, "getpdbCenter", _wrap_getpdbCenter, -1);
  rb_define_module_function(mMolvieRuby, "putpdbCenter", _wrap_putpdbCenter, -1);
  rb_define_module_function(mMolvieRuby, "proteinInit", _wrap_proteinInit, -1);
  rb_define_module_function(mMolvieRuby, "get_elementSwitch", _wrap_get_elementSwitch, -1);
  rb_define_module_function(mMolvieRuby, "put_elementSwitch", _wrap_put_elementSwitch, -1);
  rb_define_module_function(mMolvieRuby, "getSpin_x", _wrap_getSpin_x, -1);
  rb_define_module_function(mMolvieRuby, "getSpin_y", _wrap_getSpin_y, -1);
  rb_define_module_function(mMolvieRuby, "getSpin_z", _wrap_getSpin_z, -1);
  rb_define_module_function(mMolvieRuby, "proteinRotateX", _wrap_proteinRotateX, -1);
  rb_define_module_function(mMolvieRuby, "proteinRotateY", _wrap_proteinRotateY, -1);
  rb_define_module_function(mMolvieRuby, "proteinRotateZ", _wrap_proteinRotateZ, -1);
  rb_define_module_function(mMolvieRuby, "getMultiMoveX", _wrap_getMultiMoveX, -1);
  rb_define_module_function(mMolvieRuby, "getMultiMoveY", _wrap_getMultiMoveY, -1);
  rb_define_module_function(mMolvieRuby, "MultiMoveX", _wrap_MultiMoveX, -1);
  rb_define_module_function(mMolvieRuby, "MultiMoveY", _wrap_MultiMoveY, -1);
  rb_define_module_function(mMolvieRuby, "saveproteinStatus", _wrap_saveproteinStatus, -1);
  rb_define_module_function(mMolvieRuby, "texture", _wrap_texture, -1);
  rb_define_const(mMolvieRuby, "WIN_WIDTH", SWIG_From_int((int)((600))));
  rb_define_const(mMolvieRuby, "WIN_HEIGHT", SWIG_From_int((int)((600))));
  rb_define_const(mMolvieRuby, "WIN_POSX", SWIG_From_int((int)((0))));
  rb_define_const(mMolvieRuby, "WIN_POSY", SWIG_From_int((int)((0))));
  rb_define_const(mMolvieRuby, "WIN_NAME", SWIG_FromCharPtr("molvie ver. 1.00"));
  rb_define_module_function(mMolvieRuby, "main", _wrap_main, -1);
  rb_define_module_function(mMolvieRuby, "fopen", _wrap_fopen, -1);
  rb_define_module_function(mMolvieRuby, "fclose", _wrap_fclose, -1);
}

