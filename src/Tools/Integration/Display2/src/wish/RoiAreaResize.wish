#!/usr/local/bin/wish -f
proc roiAreaResizeStart {c x y} {
	global mousePressed
	global Roi

	set mousePressed(mode) 1
	set mousePressed(startx) $x
	set mousePressed(starty) $y

	switch $Roi(Shape)  {
		Rectangle {
			set rectanglePoints(near) [ rectangleNearPoint $x $y ]
		}
		TiltRectangle {
			set rectanglePoints(near) [ rectangleNearPoint $x $y ]
		}
		Line {
			set linePoints(near) [ lineNearPoint $x $y ]
		}
		Spline {
			set splinePoints(near) [ splineNearPoint $x $y ]
		}
		default {
			puts "Not supported Action"
		}
	}
}

proc roiAreaResizeMotion {c x y} {
	global mousePressed
	global Roi

	if { $mousePressed(mode) == 1 } {
		$c delete $Roi(CurrentObject)
		set mousePressed(endx) $x
		set mousePressed(endy) $y
		switch $Roi(Shape) {
			Rectangle {
				set Roi(CurrentObject) [rectangleResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			TiltRectangle {
				set Roi(CurrentObject) [rectangleResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			Line {
				set Roi(CurrentObject) [lineResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			Spline {
				set Roi(CurrentObject) [splineResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			default {
				puts "Not supported Action"
			}
		}
		set mousePressed(startx) $x
		set mousePressed(starty) $y
	}
}

proc roiAreaResizeEnd {c x y} {
	global mousePressed
	global Roi
	
	if { $mousePressed(mode) == 1 } {
		$c delete $Roi(CurrentObject)
		set mousePressed(endx) $x
		set mousePressed(endy) $y
		switch $Roi(Shape) {
			Rectangle {
				set Roi(CurrentObject) [rectangleResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			TiltRectangle {
				set Roi(CurrentObject) [rectangleResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			Line {
				set Roi(CurrentObject) [lineResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			Spline {
				set Roi(CurrentObject) [splineResize $c $mousePressed(startx) $mousePressed(starty) $mousePressed(endx) $mousePressed(endy) ]
			}
			default {
				puts "Not supported Action"
			}
		}
	}
	set mousePressed(mode) 0
}

proc rectangleResize { c startx starty endx endy } {
	global rectanglePoints 


	switch $rectanglePoints(near) {
		0 {
			rectangleResizeCalc $rectanglePoints(x2) $rectanglePoints(y2) $endx $endy \
								$rectanglePoints(x3) $rectanglePoints(y3) \
								$rectanglePoints(x0) $rectanglePoints(y0) \
								$rectanglePoints(x1) $rectanglePoints(y1)
			set rectanglePoints(x3) $rectanglePoints(bx) 
			set rectanglePoints(y3) $rectanglePoints(by)  
			set rectanglePoints(x0) $rectanglePoints(cx)  
			set rectanglePoints(y0) $rectanglePoints(cy)  
			set rectanglePoints(x1) $rectanglePoints(dx)  
			set rectanglePoints(y1) $rectanglePoints(dy) 
		}
		1 {
			rectangleResizeCalc $rectanglePoints(x3) $rectanglePoints(y3) $endx $endy \
								$rectanglePoints(x0) $rectanglePoints(y0) \
								$rectanglePoints(x1) $rectanglePoints(y1) \
								$rectanglePoints(x2) $rectanglePoints(y2)
			set rectanglePoints(x0) $rectanglePoints(bx) 
			set rectanglePoints(y0) $rectanglePoints(by)  
			set rectanglePoints(x1) $rectanglePoints(cx)  
			set rectanglePoints(y1) $rectanglePoints(cy)  
			set rectanglePoints(x2) $rectanglePoints(dx)  
			set rectanglePoints(y2) $rectanglePoints(dy) 
		}
		2 {
			rectangleResizeCalc $rectanglePoints(x0) $rectanglePoints(y0) $endx $endy \
								$rectanglePoints(x1) $rectanglePoints(y1) \
								$rectanglePoints(x2) $rectanglePoints(y2) \
								$rectanglePoints(x3) $rectanglePoints(y3)
			set rectanglePoints(x1) $rectanglePoints(bx) 
			set rectanglePoints(y1) $rectanglePoints(by)  
			set rectanglePoints(x2) $rectanglePoints(cx)  
			set rectanglePoints(y2) $rectanglePoints(cy)  
			set rectanglePoints(x3) $rectanglePoints(dx)  
			set rectanglePoints(y3) $rectanglePoints(dy) 
		}
		3 {
			rectangleResizeCalc $rectanglePoints(x1) $rectanglePoints(y1) $endx $endy \
								$rectanglePoints(x2) $rectanglePoints(y2) \
								$rectanglePoints(x3) $rectanglePoints(y3) \
								$rectanglePoints(x0) $rectanglePoints(y0)
			set rectanglePoints(x2) $rectanglePoints(bx) 
			set rectanglePoints(y2) $rectanglePoints(by)  
			set rectanglePoints(x3) $rectanglePoints(cx)  
			set rectanglePoints(y3) $rectanglePoints(cy)  
			set rectanglePoints(x0) $rectanglePoints(dx)  
			set rectanglePoints(y0) $rectanglePoints(dy) 
		}
	}
	return [ rectangleCreate $c \
							$rectanglePoints(x0) $rectanglePoints(y0) $rectanglePoints(x1) $rectanglePoints(y1) \
						    $rectanglePoints(x2) $rectanglePoints(y2) $rectanglePoints(x3) $rectanglePoints(y3) ]
}

#
# a     : fixed point
# point : pointed point
# a -> b -> c -> d ( Counter-clockwise)
#  
# Algorism
# 
proc rectangleResizeCalc { ax ay pointx pointy bx by cx cy dx dy } {
	global rectanglePoints

	set dtmpUpper [ expr ($pointx-$ax)*($by-$ay)-($pointy-$ay)*($bx-$ax) ]
	set dtmpLower [ expr ($by    -$ay)*($dx-$ax)-($bx    -$ax)*($dy-$ay) ]
	if { $dtmpLower == 0 } {
		set dtmp 1.0
	} else {
		set dtmp [ expr 1.0*$dtmpUpper/$dtmpLower ]
	}
	set btmpUpper [ expr ($pointx-$ax)*($dy-$ay)-($pointy-$ay)*($dx-$ax) ]
	set btmpLower [ expr ($bx    -$ax)*($dy-$ay)-($by    -$ay)*($dx-$ax) ]
	if { $btmpLower == 0 } {
		set btmp 1.0
	} else {
		set btmp [ expr 1.0*$btmpUpper/$btmpLower ]
	}
	set rectanglePoints(bx) [ expr ($bx-$ax)*$btmp + $ax ]
	set rectanglePoints(by) [ expr ($by-$ay)*$btmp + $ay ]
	set rectanglePoints(cx) $pointx
	set rectanglePoints(cy) $pointy
	set rectanglePoints(dx) [ expr ($dx-$ax)*$dtmp + $ax ]
	set rectanglePoints(dy) [ expr ($dy-$ay)*$dtmp + $ay ]
}

proc lineResize { c startx starty endx endy } {
	global linePoints 
	global mainImage

	switch $linePoints(near) {
		0 {
    		set linePoints(x0) $endx
    		set linePoints(y0) $endy
		}
		1 {
    		set linePoints(x1) $endx
    		set linePoints(y1) $endy
		}
	}

    set linePoints(length)    [ expr sqrt(($linePoints(x0)-$linePoints(x1))*($linePoints(x0)-$linePoints(x1))\
									     +($linePoints(y0)-$linePoints(y1))*($linePoints(y0)-$linePoints(y1))) ]
	set linePoints(absLength) [ expr sqrt(($linePoints(x0)-$linePoints(x1))*($linePoints(x0)-$linePoints(x1))*$mainImage(lx)*$mainImage(lx)\
										 +($linePoints(y0)-$linePoints(y1))*($linePoints(y0)-$linePoints(y1))*$mainImage(ly)*$mainImage(ly)) ]

	return [ lineCreate $c $linePoints(x0) $linePoints(y0) $linePoints(x1) $linePoints(y1) ]
}

proc splineResize { c startx starty endx endy } {
	global splinePoints 

	set splinePoints(x$splinePoints(near)) $endx
	set splinePoints(y$splinePoints(near)) $endy

    set points {}
	for { set i 0 } {$i <= $splinePoints(N)} {incr i} {
		append points [ coordGetInMainImageToCanvas $c x $splinePoints(x$i)] " " \
					  [ coordGetInMainImageToCanvas $c y $splinePoints(y$i)] " "
	}
	return [ splineCreate $c $points ]
}

