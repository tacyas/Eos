/*
  # mrcImagePCA : $Revision$  
  # $Date$ 
  # Created by $Author$
  # Usage : mrcImagePCA
  # Attention
  #   $Loccker$
  #  	$State$ 
  #
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define GLOBAL_DECLARATION
#include "../inc/config.h"

#define DEBUG
#include "genUtil.h"
#include "Memory.h"
#include "mrcImage.h"
#include "../inc/mrcImagePCA.h"

typedef struct lmrcImagePCAInfo {
	float EPS; 
    int NX;
	int NY;
	int Dimension;
	int*    EigenValueOrder;           /* Original Eigen Value Order */
	double* EigenValue;           /* Sorted Eigen Value */	
	double* IntegratedEigenValue; /* Integrated Eigen Value*/	

	int numOfEigenImage; 
	mrcImage* EigenImage;
} lmrcImagePCAInfo;

/*
  typedef enum lmrcImagePCAMode {
  a=0,
  b=1
  } lmrcImagePCAMode;
  
*/

#ifdef __cplusplus
    extern "C" {
#endif

void lmrcImagePCA(mrcImage* Out, int nOut, mrcImage* In, int nIn, lmrcImagePCAInfo* linfo, int mode);
double getMax(double** a,int& p,int& q);
void transform(double** a,double** u,int p,int q);
 
#ifdef __cplusplus
    }
#endif


static int dim;
//static int newdim;
//static float NX,NY;  
int
main(int argc, char* argv[]) 
{
	mrcImagePCAInfo info;
	lmrcImagePCAInfo linfo;
	mrcImage* In;
	mrcImage* Out;
  	int i;
  //      FILE* fpin;
  //	FILE* fpout;
	DEBUGPRINT("Program Start\n");
	init0(&info);
	argCheck(&info, argc, argv);
	init1(&info);
 
 	DEBUGPRINT("where");
  	In  = (mrcImage*)MemoryAllocate(mrcImage, info.flagInList, "in main");
  	for(i=0; i<info.flagInList; i++) {
    		mrcFileRead(&In[i], info.InList[i], "in main", 0);
    		DEBUGPRINT("where\n");
  	}
  	Out = (mrcImage*)MemoryAllocate(mrcImage, info.flagOutList, "in main");
 
 	linfo.EPS = info.EPS;	
	linfo.NX=info.NX;
	linfo.NY=info.NY;
	linfo.numOfEigenImage =info.numOfEigenImage;
	//NX=info.NX;
	//NY=info.NY;
  	lmrcImagePCA(Out, info.flagOutList, In, info.flagInList, &linfo, 0);
  
  	for(i=0; i<info.flagOutList; i++) {
    		mrcFileWrite(&Out[i], info.OutList[i], "in main", 0);
  	}

	if(info.flagOutvector) {
   	/*	for(i=0; i<linfo.Dimension; i++){
	  		fprintf(info.fptOutvector,"%4d         %4d        %5.2lf        %3.2lf\n", i, 
				linfo.EigenValueOrder[i],
				linfo.EigenValue[i],
				linfo.IntegratedEigenValue[i]);
		}*/
		for(i=0; i<linfo.Dimension; i++)
			fprintf(info.fptOutvector,"%4d\n",i);  
		for(i=0; i<linfo.Dimension; i++)
			fprintf(info.fptOutvector,"%4d\n",linfo.EigenValueOrder[i]);
		for(i=0; i<linfo.Dimension; i++)
			fprintf(info.fptOutvector,"%5.2lf\n",linfo.EigenValue[i]);
		for(i=0; i<linfo.Dimension; i++)		
			fprintf(info.fptOutvector,"%3.2lf\n",linfo.IntegratedEigenValue[i]);
	}

	if(info.flagEigenImage) {
		char s[1024];
		for(i=0; i<	linfo.numOfEigenImage; i++) {
			sprintf(s, "%s.%05d", info.EigenImage, i);
			mrcFileWrite(&linfo.EigenImage[i], s, "in main", 0);
		}
	}
  	exit(EXIT_SUCCESS);
  
  	return 0;
}

void
additionalUsage()
{
  	fprintf(stderr, "----- Additional Usage -----\n");
}

void 
lmrcImagePCA(mrcImage* Out, int nOut, mrcImage* In, int nIn, lmrcImagePCAInfo* linfo, int mode)
{
  	int count,i,j;
  	int p,q;
							       
 	float  x;
 	float  y;
 	float  z;
//    int x;
 // 	int y;
//	int z;
  	double data;
  	double sum;
 	
	dim = In[0].HeaderN.x*In[0].HeaderN.y*In[0].HeaderN.z;

  	double* ave;
  	ave=new double[dim];
  
  	double** a;  
  	a = new double*[dim];
  	for(i=0;i<dim;i++)
    		a[i]=new double[dim*2];
  
  	double** b;
  	b = new double*[dim];
  	for(i=0;i<nIn;i++)
    		b[i]=new double[dim];
  
  	double** c;
  	c=new double*[dim];
  	for(i=0;i<nIn;i++)
    	c[i]=new double[dim];

	for(i=0; i<nOut; i++) {
		// (*Out).  <==>  Out-> 
		Out[i].HeaderN.x = linfo->NX;
		Out[i].HeaderN.y = linfo->NY;
  		Out[i].HeaderN.z = 1;
  		Out[i].HeaderLength.x = In->HeaderLength.x;
  		Out[i].HeaderLength.y = In->HeaderLength.y;
  		Out[i].HeaderLength.z = 0.0;
  		Out[i].HeaderMode =  In->HeaderMode;
  		mrcInit(&Out[i], NULL);
	}
  
  // real part data of the ith image at (x, y, z) 	
  // mrcPixelDataGet(&In[i], x, y, z, &data, mrcPixelRePart, mrcPixelHowNearest);
  	for(i=0; i<nIn; i++){
    	count=0;
    	for(z=0;z<In->HeaderN.z;z++){
      	for(y=0;y<In->HeaderN.y;y++){
		for(x=0;x<In->HeaderN.x;x++){
			if(count%1000==0)
     			DEBUGPRINT2("count=%d i=%d\n",count,i);
	  		mrcPixelDataGet(&In[i], x, y, z, &data, mrcPixelRePart, mrcPixelHowNearest);
	  		b[i][count]=data;
			count++;
		}
      	}
    	}
  	}
 
 	// Calculation of co-variance matrix  
	// Step 1: Calc Average of each pixel -> ave[i]
  	for(i=0;i<dim;i++){
		 if(i%1000==0)
	 		DEBUGPRINT("sumn=0\n");
    	sum=0.0;
    	for(j=0; j<nIn; j++){
      		sum=sum+b[j][i];
    	}
    	ave[i]=sum/nIn;
  	}
 
 	// Step 2: b(original data) -> c (average -> 0)   
  	for(i=0;i<dim;i++){
		if(i%1000==0)
		      DEBUGPRINT1("c i=%d\n",i);
    	for(j=0; j<nIn; j++){
      		c[j][i]=b[j][i]-ave[i];
    	}
  	}
 
 	// Step 3: Calc co-variance matrix 
  	for(i=0;i<dim;i++){
		if(i%1000==0)
			DEBUGPRINT1("a sum  i=%d\n",i);
    	for(j=i;j<dim;j++){
      		sum=0.0;
      		for(p=0;p<nIn;p++){
				sum=sum+c[p][i]*c[p][j];
      		}
      		a[i][j]=sum/nIn;
      		a[j][i]=a[i][j];
    	}
  	}
 
 	// Initialize u : eingen vectors -> Unit vector 
  	double** u=new double*[dim];
  	for(i=0;i<dim;i++)
    		u[i]=new double[dim];
  	for(i=0;i<dim;i++){
		 if(i%1000==0)
		 	DEBUGPRINT1("u i=%d\n",i);
    	for(j=0;j<dim;j++) {
      		if(i==j)
				u[i][j]=1;
      		else
				u[i][j]=0;
    	}
  	}
  
  	DEBUGPRINT("Calc eigen vector and eigen values: Start\n");
	count = 0;
 	while(1){
		count++;
    	double max;
    	max=getMax(a, p, q);   // a:covar has the max value at (p, q), where p != q
    	transform(a,u,p,q);    // a:diagonal covar u: unit vector  
    	if(max<linfo->EPS) {
			DEBUGPRINT("EPSbreak\n");
      		break;
		}
  	}
	linfo->numOfEigenImage = MIN(count,linfo->numOfEigenImage);
  	DEBUGPRINT1("Calc eigen vector and eigen values: End : loop count %d\n", count);

  	double* amaxd;
  	amaxd=new double[dim];
  	int* amaxi;
  	amaxi=new int[dim];
  	double* aper;
  	aper =new double[dim];

  	double t;
  	int s;
  	double asum=0.0;
 	double asumsum=0.0;

	// Sum up the diagonal elements 
  	for(i=0;i<dim;i++){
		if(i%1000==0)
			DEBUGPRINT1("amaxd[i]f, amaxi[i], i=%d\n",i);
    	amaxd[i]=a[i][i];
    	amaxi[i]=i;
		asum=asum+a[i][i];
  	}
 
 	// Order
  	for(i=0;i<dim-1;i++){
		if(i%1000==0)
			DEBUGPRINT1("sort i=%d\n",i);
    	for(j=i;j<dim;j++){
      		if(amaxd[i]<amaxd[j]){
				t=amaxd[i];
				s=amaxi[i];
				amaxd[i]=amaxd[j]; // d: engine value  
				amaxi[i]=amaxi[j]; // i: original position   
				amaxd[j]=t;
				amaxi[j]=s;
      		}
    	}
  	}
 
 	// Weight of eigen values
   	for(i=0;i<dim;i++){
		asumsum=asumsum+amaxd[i];
		aper[i]=(asumsum/asum)*100.0;
	}
 
 	// Set weights of each eigen vector for each image 
  	for(i=0;i<nOut;i++) {
		q=0;
    	for(z=0;z<Out->HeaderN.z;z++){
      		for(y=0;y<Out->HeaderN.y;y++){
				for(x=0;x<Out->HeaderN.x;x++){
	  				sum=0.0;
	  				s=amaxi[q];
	  				count=0;
	  				for(p=0;p<dim;p++){
	    				sum=sum+u[p][s]*(b[i][count]-ave[count]);
	    				count++;
	  				}
	  				data=sum;
	  				mrcPixelDataSet(&Out[i], x, y, z, data, mrcPixelRePart);
	  				q++;
				}
			}
      	}	
    } 

	linfo->Dimension            = dim;
	linfo->EigenValueOrder      = amaxi;
	linfo->EigenValue           = amaxd;
	linfo->IntegratedEigenValue = aper;

	linfo->EigenImage = new mrcImage[linfo->numOfEigenImage];
	for(i=0; i<linfo->numOfEigenImage; i++) {
		linfo->EigenImage[i].Header = In[0].Header;
		mrcInit(&linfo->EigenImage[i], NULL);
		s = amaxi[i];
		q = 0;
    	for(z=0;z<linfo->EigenImage[i].HeaderN.z;z++){
    	for(y=0;y<linfo->EigenImage[i].HeaderN.y;y++){
    	for(x=0;x<linfo->EigenImage[i].HeaderN.x;x++){
			s = amaxi[i];
			data = u[q][s];
			mrcPixelDataSet(&linfo->EigenImage[i], x, y, z, data, mrcPixelRePart);
			q++;	
		}
		}
		}	
	}
}

double getMax(double** a, int& p, int& q){
  	double max=0.0;
  	int i,j;
  
  	for(i=0;i<dim-1;i++){
/*		if(i%1000==0)
			DEBUGPRINT1("getmax max dim=%d\n",dim);*/
    	for(j=i+1;j<dim;j++){
      		if(fabs(a[i][j])>max){
				p=i;
				q=j;
				max=fabs(a[i][j]);
      		}
    	}
  	}
  	return max;
}

void transform(double** a,double** u,int p,int q){
  	double alpha,beta,gamma;
  	double sine,cosine,w;
  	double wa,wb,wc;
  	int i,j;
  
  	wa=a[p][p];
  	wb=a[p][q];
  	wc=a[q][q];
  
  	alpha=-wb;
  	beta=(wa-wc)/2;
  	gamma=fabs(beta)/sqrt(alpha*alpha+beta*beta);
  
  	sine=sqrt((1.0-gamma)/2);
  	if(alpha*beta<0)
    		sine=-sine;
  	cosine=sqrt(1.0-sine*sine);
  
  	for(j=0;j<dim;j++){
/*		if(j%1000==0)
			DEBUGPRINT1("transform a[p][i] j=%d\n",j);*/
    	w=a[p][j]*cosine-a[q][j]*sine;
    	a[q][j]=a[p][j]*sine+a[q][j]*cosine;
    	a[p][j]=w;
  	}
  	for(j=0;j<dim;j++){
/*		if(j%1000==0)
			DEBUGPRINT1("transform a[j][q] j=%d\n",j);*/
    	a[j][p]=a[p][j];
    	a[j][q]=a[q][j];
  	}
  
  	w=2.0*wb*sine*cosine;
  	a[p][p]=wa*cosine*cosine+wc*sine*sine-w;
  	a[q][q]=wa*sine*sine+wc*cosine*cosine+w;
  	a[p][q]=a[q][p]=0;
  
  	for(i=0;i<dim;i++){
	/*	if(i%1000==0)
			DEBUGPRINT1("transform u[i][p] i=%d\n",i);*/
    	w=u[i][p]*cosine-u[i][q]*sine;
    	u[i][q]=u[i][p]*sine+u[i][q]*cosine;
    	u[i][p]=w;
  	}
}

    			
	
