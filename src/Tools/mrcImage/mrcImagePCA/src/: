/*
  # mrcImagePCA : $Revision$  
  # $Date$ 
  # Created by $Author$
  # Usage : mrcImagePCA
  # Attention
  #   $Loccker$
  #  	$State$ 
  #
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define GLOBAL_DECLARATION
#include "../inc/config.h"

#define DEBUG
#include "genUtil.h"
#include "Memory.h"
#include "mrcImage.h"
#include "../inc/mrcImagePCA.h"

/*
Example:
typedef struct lmrcImagePCAInfo {
float a;
int b;
long flagRedirect;

long flagInList;
char** InList;
char* InListList;
FILE** fptInList;
FILE* fptInListList;

long flagOutList;
char** OutList;
char* OutListList;
FILE** fptOutList;
FILE* fptOutListList;

long flagconfigFile;
char* configFile;
FILE* fptconfigFile;

long flagmode;
long mode;

} lmrcImagePCAInfo;
*/
/*
  typedef enum lmrcImagePCAMode {
  a=0,
  b=1
  } lmrcImagePCAMode;
  
*/

#ifdef __cplusplus
    extern "C" {
#endif

/*
  extern double mrcPixelDataGet(mrcImage* mrc,
				mrcImageParaTypeReal x  ,
				mrcImageParaTypeReal y  ,
				mrcImageParaTypeReal z  , 
                                double* data,
                                mrcPixelDataType mode,
                                mrcPixelDataHowToGet how);

  extern void mrcImageDataSet(mrcImage* out,
			        mrcImage* in,
			        mrcImageParaTypeReal x,
			        mrcImageParaTypeReal y,
			        mrcImageParaTypeReal z,
			        float phi,
			        mrcImageDataSetMode  mode);
  
  extern mrcStatusType mrcFileRead  (mrcImage* mrc, char* filename, char* message, long mode);
  extern mrcStatusType mrcFileWrite  (mrcImage* mrc, char* filename, char* message, long mode);
  extern void argCheck(mrcImagePCAInfo* info, int argc, char* avgv[]);
  extern void init0(mrcImagePCAInfo* info);
  extern void init1(mrcImagePCAInfo* info);
  extern void additionalUsage();
*/
   
void lmrcImagePCA(mrcImage* Out, int nOut, mrcImage* In, int nIn, int mode);
double getMax(double** a,int& p,int& q);
void transform(double** a,double** u,int p,int q);
 
#ifdef __cplusplus
    };
#endif


const double EPS=0.0001;
static int dim;
//static int newdim;
  
int
main(int argc, char* argv[]) 
{
	mrcImagePCAInfo info;
	mrcImage* In;
	mrcImage* Out;
  	int i;
  //      FILE* fpin;
  //	FILE* fpout;
	fprintf(stderr, "Where\n");
        DEBUGPRINT("where\n");
	DEBUGPRINT("Program Start\n");
  	DEBUGPRINT("where\n");
	init0(&info);
	argCheck(&info, argc, argv);
	init1(&info);
 
 	DEBUGPRINT("where");
  
  /*     if((fpin=fopen(info.InList,"r"))==NULL){
	 fprintf(stderr ,"File can not be opened.\n");
	 exit(1);
	 }
	 
	 if((fpout=fopen(info.OutList,"w"))==NULL){
	 fprintf(stderr ,"File can not be opened.\n");
	 exit(1);
	 }
  */
	printf("where");			
  	In  = MemoryAllocate(mrcImage, info.flagInList, "in main");
  
  	for(i=0; i<info.flagInList; i++) {
    		mrcFileRead(&In[i], info.InList[i], "in main", 0);
    		DEBUGPRINT("where\n");
  	}
  
  	info.flagOutList=info.flagInList;
  
  //	In  = MemoryAllocate(mrcImage, info.flagInList, "in main");
  //	InOut  = MemoryAllocate(mrcImage, info.flagInOutList, "in main");
  //	Out = (mrcImage*)memoryAllocate(sizeof(mrcImage)*info.flagOutList, "in main"); 
  
  	Out  = MemoryAllocate(mrcImage, info.flagOutList, "in main");
  
 
  
  	lmrcImagePCA(Out, info.flagOutList,In, info.flagInList, 0);
  
  	for(i=0; i<info.flagOutList; i++) {
    		mrcFileWrite(&Out[i], info.OutList[i], "in main", 0);
  	}
  
  	exit(EXIT_SUCCESS);
  
  	return 0;
}

void
additionalUsage()
{
  	fprintf(stderr, "----- Additional Usage -----\n");
}

void 
lmrcImagePCA(mrcImage* Out, int nOut, mrcImage* In, int nIn, int mode)
{
  	int count,i,j;
  	int p,q;
  
  // mrcImageParaTypeInteger x;
  // mrcImageParaTypeInteger y;
  // mrcImageParaTypeInteger z;
  	float  x;
  	float  y;
  	float  z;
  
  	double data;
  	double sum;
  
  	double* ave;
  	ave=new double[dim];
  
  	double** a;  
  	a=new double*[dim];
  
  	for(i=0;i<dim;i++)
    		a[i]=new double[dim*2];
  
  	double** b;
  	b=new double*[dim];
  	for(i=0;i<nIn;i++)
    		b[i]=new double[dim];
  
  	double** c;
  	c=new double*[dim];
  	for(i=0;i<nIn;i++)
    		c[i]=new double[dim];

  	Out->HeaderN.x =3.0;
  	Out->HeaderN.y =3.0;
  	Out->HeaderN.z = 1.0;
  	Out->HeaderLength.x = In->HeaderLength.x;
  	Out->HeaderLength.y = In->HeaderLength.y;
  	Out->HeaderLength.z = 0.0;
  	dim=In->HeaderN.x*In->HeaderN.y*In->HeaderN.z;
  //newdim=In->HeaderN.x*In->HeaderN.y*In->HeaderN.z;
  //newdim=Out->HeaderN.x*Out->HeaderN.y*Out->HeaderN.z;
  	Out->HeaderMode =  In->HeaderMode;
  //  Out->HeaderMode = mrcFloatImage;
  	mrcInit(Out, NULL);

  
  // real part data of the ith image at (x, y, z) 	
  // mrcPixelDataGet(&In[i], x, y, z, &data, mrcPixelRePart, mrcPixelHowNearest);
  	for(i=0; i<nIn; i++){
    		count=0;
    		for(z=0;z<In->HeaderN.z;z++){
      			for(y=0;y<In->HeaderN.y;y++){
				for(x=0;x<In->HeaderN.x;x++){
	  				mrcPixelDataGet(&In[i], x, y, z, &data, mrcPixelRePart, mrcPixelHowNearest);
	  				b[i][count]=data;
	  				count++;
				}
      			}
    		}
  	}
  
  	for(i=0;i<dim;i++){
    		sum=0.0;
    		for(j=0; j<nIn; j++){
      			sum=sum+b[j][i];
    		}
    		ave[i]=sum/nIn;
  	}
  
  	for(i=0;i<dim;i++){
    		for(j=0; j<nIn; j++){
      			c[j][i]=b[j][i]-ave[i];
    		}
  	}
  
  	for(i=0;i<dim;i++){
    		for(j=i;j<dim;j++){
      			sum=0.0;
      			for(p=0;p<nIn;p++){
				sum=sum+c[p][i]*c[p][j];
      			}
      			a[i][j]=sum/nIn;
      			a[j][i]=a[i][j];
    		}
  	}
  
  	double** u=new double*[dim];
  	for(i=0;i<dim;i++)
    		u[i]=new double[dim];
  	for(i=0;i<dim;i++){
    		for(j=0;j<dim;j++){
      			if(i==j)
				u[i][j]=1;
      			else
				u[i][j]=0;
    		}
  	}
  
 	while(1){
    		double max;
    		max=getMax(a,p,q);
    		transform(a,u,p,q);
    		if(max<EPS)
      			break;
  	}
  
  // mrcPixelDataSet(&Out[i], x, y, z, data, mrcPixelRePart);
  
  	double* amaxd;
  	amaxd=new double[dim];
  	int* amaxi;
  	amaxi=new int[dim];
  	double t;
  	int s;
  
  	for(i=0;i<dim;i++){
    		amaxd[i]=a[i][i];
    		amaxi[i]=i;
  	}
  
  	for(i=0;i<dim-1;i++){
    		for(j=i;j<dim;j++){
      			if(amaxd[i]<amaxd[j]){
				t=amaxd[i];
				s=amaxi[i];
				amaxd[i]=amaxd[j];
				amaxi[i]=amaxi[j];
				amaxd[j]=t;
				amaxi[j]=s;
      			}
    		}
  	}
  
  	q=0;
  	for(i=0;i<nOut;i++){
    		for(z=0;z<Out->HeaderN.z;z++){
      			for(y=0;y<Out->HeaderN.y;y++){
				for(x=0;x<Out->HeaderN.x;x++){
	  				sum=0.0;
	  				s=amaxi[q];
	  				count=0;
	  				for(p=0;p<dim;p++){
	    					sum=sum+u[p][s]*(b[i][count]-ave[count]);
	    					count++;
	  				}
	  				data=sum;
	  				mrcPixelDataSet(&Out[i], x, y, z, data, mrcPixelRePart);
	  				q++;
				}
      			}
    		}
  	}
  
}

double getMax(double** a,int& p,int& q){
  	double max=0.0;
  	int i,j;
  
  	for(i=0;i<dim-1;i++){
    		for(j=i+1;j<dim;j++){
      			if(fabs(a[i][j])>max){
				p=i;
				q=j;
				max=fabs(a[i][j]);
      			}
    		}
  	}
  	return max;
}

void transform(double** a,double** u,int p,int q){
  	double alpha,beta,gamma;
  	double sine,cosine,w;
  	double wa,wb,wc;
  	int i,j;
  
  	wa=a[p][p];
  	wb=a[p][q];
  	wc=a[q][q];
  
  	alpha=-wb;
  	beta=(wa-wc)/2;
  	gamma=fabs(beta)/sqrt(alpha*alpha+beta*beta);
  
  	sine=sqrt((1.0-gamma)/2);
  	if(alpha*beta<0)
    		sine=-sine;
  	cosine=sqrt(1.0-sine*sine);
  
  	for(j=0;j<dim;j++){
    		w=a[p][j]*cosine-a[q][j]*sine;
    		a[q][j]=a[p][j]*sine+a[q][j]*cosine;
    		a[p][j]=w;
  	}
  	for(j=0;j<dim;j++){
    		a[j][p]=a[p][j];
    		a[j][q]=a[q][j];
  	}
  
  	w=2.0*wb*sine*cosine;
  	a[p][p]=wa*cosine*cosine+wc*sine*sine-w;
  	a[q][q]=wa*sine*sine+wc*cosine*cosine+w;
  	a[p][q]=a[q][p]=0;
  
  	for(i=0;i<dim;i++){
    		w=u[i][p]*cosine-u[i][q]*sine;
    		u[i][q]=u[i][p]*sine+u[i][q]*cosine;
    		u[i][p]=w;
  	}
}


