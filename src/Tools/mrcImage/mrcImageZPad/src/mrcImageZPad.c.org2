/*
# %M% %Y% %I%
# The latest update : %G% at %U%
#
#%Z% mrcImageZPad ver %I%
#%Z% Created by Kenji Murakami 052109 for actin paper
#%Z%
#%Z% Usage : mrcImageZPad edited by mrcImage3DPad
#%Z% Attention
#%Z%
*/
static char __sccs_id[] = "%Z%mrcImageZPad ver%I%; Date:%D% %Z%";
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>                  
#define GLOBAL_DECLARATION
#include "../inc/config.h"

#define DEBUG
#include "genUtil.h"
#include "mrcImage.h"

/* prototypes */
void lmrcImage3DPadfilament(mrcImage* out ,mrcImage* in ,float rmax ,int Nx ,int Ny ,double w ,int mode ,double v ,long flagv);
double lmrcImage3DPadfilamentCalcavr(mrcImage* in ,double rmax);


void
main(int argc, char* argv[]) 
{
	mrcImageZPadInfo info;

/* variables */
	mrcImage in;
	mrcImage out;

/* input patameters ,file open */
	init0(&info);
	argCheck(&info, argc, argv);
	init1(&info);
	mrcFileRead(&in ,info.In ,"in main" ,0);
	
/* begin */
	DEBUGPRINT("Program Start\n");
	if (!info.flagr){
	  info.r=in.HeaderN.x*0.5;
	}
	if (!info.flagNx){
	  info.Nx=in.HeaderN.x;
	}
	if (!info.flagNy){
	  info.Ny=in.HeaderN.y;
	}
	if (!info.flagNz){
	  info.Nz=in.HeaderN.z;
	}

	lmrcImage3DPadfilament(&out ,&in ,info.r ,info.Nx ,info.Ny ,info.w ,info.mode ,info.v ,info.flagv);
	mrcFileWrite(&out ,info.Out ,"in main" ,0);
	exit(EXIT_SUCCESS);
}

void
additionalUsage()
{
  fprintf(stderr, "----- mode -----\n");
  fprintf(stderr, "0:Out of threshold is avrage of threshold plain.\n");
  fprintf(stderr, "1:Mulplying cos function.\n");
  fprintf(stderr, "2:Mulplying cos function and out of threshold is avrage of threshold plain.\n");

  /*

}

void lmrcImage3DPadfilament(mrcImage* out ,mrcImage* in ,float rmax ,int Nx ,int Ny ,double w ,int mode ,double v ,long flagv)
{
/* variables */
  int x,y,z;
  double data,cz,sz,r2,av,c,dr2;

/* begin */
  DEBUGPRINT1("%f ",rmax);
  out->Header = in->Header;
  out->HeaderN.z = Nz;
  mrcInit(out,NULL);
  cz=(in->HeaderN.z-1)*0.5;
  sz=(out->HeaderN.z-in->HeaderN.z)*0.5;

  r2=SQR(rmax);
  switch(mode){
  case 0:
    if (!flagv){
      av=lmrcImage3DPadfilamentCalcavr(in ,rmax);
    } else {
      av=v;
    }
    DEBUGPRINT1("%f \n",av);
    for (z=0 ;z<out->HeaderN.z;z++){
      for (x=0;x<out->HeaderN.x;x++){
	for (y=0;y<out->HeaderN.y;y++){
	  mrcPixelDataSet(out ,x ,y ,z ,av, mrcPixelRePart);
	}
      }
    }
    for (z=0 ;z<in->HeaderN.z;z++){
      for (x=0;x<in->HeaderN.x;x++){
	for (y=0;y<in->HeaderN.y;y++){
	  mrcPixelDataGet(in ,x ,y ,z ,&data, mrcPixelRePart, mrcPixelHowNearest);
	  dr2=SQR(z-cz);
	  if (r2>=dr2 ){
	    mrcPixelDataSet(out ,x ,y ,z+sz ,data, mrcPixelRePart);
	  }
	}
      }
    }
    break;
  case 1:
    for (z=0 ;z<in->HeaderN.z;z++){
      for (x=0;x<in->HeaderN.x;x++){
	for (y=0;y<in->HeaderN.y;y++){
	  mrcPixelDataGet(in ,x ,y ,z ,&data, mrcPixelRePart, mrcPixelHowNearest);
	  dr2=SQR(z-cz);
	  if (SQR(rmax-w)>dr2 ){
	    mrcPixelDataSet(out ,x ,y ,z+sz ,data, mrcPixelRePart);
	  }else if (SQR(rmax+w)<dr2 ){
	    mrcPixelDataSet(out ,x ,y ,z+sz ,0, mrcPixelRePart);
	  }else {
	    c= (cos( ( rmax-sqrt(dr2)) / w *PI/2 )+1 )/2;
	    mrcPixelDataSet(out ,x ,y ,z+sz ,data*c, mrcPixelRePart);
	  }
	    
	}
      }
    }
    break;
  case 2:
    av=lmrcImage3DPadfilamentCalcavr(in ,rmax+w);
    fprintf(stdout,"av :%g\n",av); 
    for (z=0 ;z<in->HeaderN.z;z++){
      for (x=0;x<in->HeaderN.x;x++){
	for (y=0;y<in->HeaderN.y;y++){
	  mrcPixelDataGet(in ,x ,y ,z ,&data, mrcPixelRePart, mrcPixelHowNearest);
	  dr2=SQR(z-cz);
	  if (SQR(rmax-w)>dr2 ){
	    mrcPixelDataSet(out ,x ,y ,z+sz ,data, mrcPixelRePart);
	  }else if (SQR(rmax+w)<dr2 ){
	    mrcPixelDataSet(out ,x ,y ,z+sz ,av, mrcPixelRePart);
	  }else {
	    c= (cos( ( rmax-sqrt(dr2)) / w *PI/2 )+1 )/2;
	    mrcPixelDataSet(out ,x ,y ,z+sz ,(data-av)*c+av , mrcPixelRePart);
	  }
	}
      }
    }  
  }
  mrcStatDataSet(out ,0);
}



double lmrcImage3DPadfilamentCalcavr(mrcImage* in ,double rmax)
{
/* variables */
  int x,y,z,n;
  double cz,r2,sum,data,av;
  
/* begin */
  n=0;
  sum=0;
  cz=(in->HeaderN.z-1)*0.5;
  for (z=0;z<in->HeaderN.z;z++){
   r2=SQR(z-cz);
   if  (r2>=SQR(rmax) && r2<SQR(rmax+1)){
    for  (x=0 ;x<in->HeaderN.x;x++){
     for  (y=0 ;y<in->HeaderN.y;y++){
 	mrcPixelDataGet(in ,x ,y ,z ,&data, mrcPixelRePart, mrcPixelHowNearest);
  	  sum+=data;
	  n++;
	}  
       }	
      }
     }s
    av=sum/n;
    return(av);
} 
