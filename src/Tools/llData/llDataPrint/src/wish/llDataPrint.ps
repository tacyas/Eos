%!PS-Adobe-1.0
%%Title: llDataPrint.wish
%%Creator: Id: a2ps,v 1.32 1993/06/25 00:44:18 utashiro Exp 
%%CreationDate: Mon Jul 26 10:03:29 JST 1999
%%Pages: (atend)
%%PageOrder: Ascend
%%DocumentPaperSizes: A4
%%Orientation: Landscape
%%EndComments

/$a2psdict 100 dict def
$a2psdict begin
% Initialize page description variables.
/inch {72 mul} bind def
%% SelectTray
statusdict /a4tray known { statusdict begin a4tray end } if
/landscape true def
/twinpage true def
/sheetheight 11.64 inch def
/sheetwidth 8.27 inch def
/lmargin 1.2 inch def
/smargin 1.2 inch def
/paper_adjust 0.05 inch def
/noborder false def
/noheader false def
/headersize 0.22 inch def
/nofooter false def
/nopunchmark true def
/bodyfontsize 6.6 def
/kanjiAsciiRatio 1 def
/lines 66 def
/columns 86 def
/date (Jul 26 1999 10:03) def
/doasciimag false def
%!  PostScript Source Code
%
%  File: imag:/users/local/a2ps/header.ps
%  Created: Tue Nov 29 12:14:02 1988 by miguel@imag (Miguel Santana)
%  Version: 2.0
%  Description: PostScript prolog for a2ps ascii to PostScript program.
% 
%  Edit History:
%  - Original version by evan@csli (Evan Kirshenbaum).
%  - Modified by miguel@imag to:
%    1) Correct an overflow bug when printing page number 10 (operator
%	cvs).
%    2) Define two other variables (sheetwidth, sheetheight) describing
%	the physical page (by default A4 format).
%    3) Minor changes (reorganization, comments, etc).
%  - Modified by tullemans@apolloway.prl.philips.nl
%    1) Correct stack overflows with regard to operators cvs and copy.
%       The resulting substrings where in some cases not popped off 
%       the stack, what can result in a stack overflow.
%    2) Replaced copypage and erasepage by showpage. Page througput
%       degrades severely (see red book page 140) on our ps-printer
%       after printing sheet 16 (i.e. page 8) of a file which was 
%       actually bigger. For this purpose the definitions of startdoc
%       and startpage are changed.
%  - Modified by Tim Clark <T.Clark@uk.ac.warwick> to:
%    1) Print one page per sheet (portrait) as an option.
%    2) Reduce size of file name heading, if it's too big.
%    3) Save and restore PostScript state at begining/end. It now uses
%	conventional %%Page %%Trailer markers.
%    4) Print one wide page per sheet in landscape mode as an option.
%  - Modified by miguel@imag.fr to
%    1) Add new option to print n copies of a file.
%    2) Add new option to suppress heading printing.
%    3) Add new option to suppress page surrounding border printing.
%    4) Add new option to change font size. Number of lines and columns
%	are now automatically adjusted, depending on font size and
%	printing mode used.
%    5) Minor changes (best layout, usage message, etc).
%  - Modified by kanazawa@sra.co.jp to:
%    1) Handle Japanese code
%  - Modified by utashiro@sra.co.jp to:
%    1) Fix bug in printing long label
%    2) Handle carriage-return
%    3) Specify kanji-ascii character retio
%    4) Add footer label
%    5) Change filename->fname becuase ghostscript has operator filename
%    6) Support three different font style
%    7) Incorporate B4 paper support and punchmark contributed
%       by Masami Ueno <cabbage@kki.esi.yamanashi.ac.jp>
%

% Copyright (c) 1988, Miguel Santana, miguel@imag.imag.fr
%
% Permission is granted to copy and distribute this file in modified
% or unmodified form, for noncommercial use, provided (a) this copyright
% notice is preserved, (b) no attempt is made to restrict redistribution
% of this file, and (c) this file is not distributed as part of any
% collection whose redistribution is restricted by a compilation copyright.
%


% General macros.
/xdef {exch def} bind def
/getfont {exch findfont exch scalefont} bind def

% Page description variables and inch function are defined by a2ps program.

% Character size for differents fonts.
   landscape
   { /filenamefontsize 12 def }
   { /filenamefontsize 16 def }
ifelse
/datefontsize filenamefontsize 0.8 mul def
/headermargin filenamefontsize 0.25 mul def
/bodymargin bodyfontsize 0.7 mul def

% Font assignment to differents kinds of "objects"
/filenamefontname /Helvetica-Bold def
/stdfilenamefont filenamefontname filenamefontsize getfont def
/datefont /Helvetica datefontsize getfont def
/footerfont /Helvetica-Bold datefontsize getfont def
/mag { doasciimag { [ 1 0 0 asciimagsize 0 0 ] makefont } if } def
/bodynfont /Courier bodyfontsize getfont mag def
/bodybfont /Courier-Bold bodyfontsize getfont mag def
/bodyofont /Courier-BoldOblique bodyfontsize getfont mag def
/fontarray [ bodynfont bodybfont bodyofont ] def
/bodyfont bodynfont def

% Initializing kanji fonts
/kanji_initialized false def
/kanji_init {
   kanji_initialized not
   {
      /bodykfontsize bodyfontsize kanjiAsciiRatio mul def
      /bodyknfont /Ryumin-Light-H bodykfontsize getfont def
      /bodykbfont /GothicBBB-Medium-H bodykfontsize getfont def
      /bodykofont bodykbfont [ 1 0 .2 1 0 0 ] makefont def
      /KanjiRomanDiff 1.2 bodyfontsize mul 1.0 bodykfontsize mul sub def
      /KanjiRomanDiffHalf KanjiRomanDiff 2 div def
      /kfontarray [ bodyknfont bodykbfont bodykofont ] def
      /kanji_initialized true def
   } if
} def

% Backspace width
/backspacewidth
   bodyfont setfont (0) stringwidth pop
   def

% Logical page attributs (a half of a real page or sheet).
/pagewidth
   bodyfont setfont (0) stringwidth pop columns mul bodymargin dup add add
   def
/pageheight
   bodyfontsize 1.1 mul lines mul bodymargin dup add add headersize add
   def

% Coordinates for upper corner of a logical page and for sheet number.
% Coordinates depend on format mode used.
% In twinpage mode, coordinate x of upper corner is not the same for left
% and right pages: upperx is an array of two elements, indexed by sheetside.
/rightmargin smargin 3 div def
/leftmargin smargin 2 mul 3 div def
/topmargin lmargin twinpage {3} {2} ifelse div def
landscape
{  % Landscape format
   /punchx .4 inch def           % for PunchMark
   /punchy sheetwidth 2 div def  % for PunchMark
   /uppery rightmargin pageheight add bodymargin add def
   /sheetnumbery sheetwidth leftmargin pageheight add datefontsize add sub def
   twinpage
   {  % Two logical pages
      /upperx [ topmargin 2 mul			% upperx for left page
		dup topmargin add pagewidth add	% upperx for right page
	      ] def
      /sheetnumberx sheetheight topmargin 2 mul sub def
   }
   {  /upperx [ topmargin dup ] def
      /sheetnumberx sheetheight topmargin sub datefontsize sub def
   }
   ifelse
}
{  % Portrait format
   /punchx .3 inch def
   /punchy sheetheight 2 div def
   /uppery topmargin pageheight add def
   /upperx [ leftmargin dup ] def
   /sheetnumberx sheetwidth rightmargin sub datefontsize sub def
   /sheetnumbery
	 sheetheight 
	 topmargin pageheight add datefontsize add headermargin add
      sub
      def
}
ifelse

% Strings used to make easy printing numbers
/pnum 12 string def
/empty 12 string def

% Other initializations.
datefont setfont
/datewidth date stringwidth pop def
/pagenumwidth (Page 999) stringwidth pop def
/filenameroom
         pagewidth
	 filenamefontsize 4 mul datewidth add pagenumwidth add
      sub
   def


% Function startdoc: initializes printer and global variables.
/startdoc
    { /sheetside 0 def			% sheet side that contains current page
      /sheet 1 def			% sheet number
   } bind def

% Function newfile: init file name for each new file.
/newfile
    { cleanup
      /fname xdef
      stdfilenamefont setfont
      /filenamewidth fname stringwidth pop def
      /filenamefont
	 filenamewidth filenameroom gt
	 {
	       filenamefontname
	       filenamefontsize filenameroom mul filenamewidth div
	    getfont
	 }
	 {  stdfilenamefont }
	 ifelse
	 def
    } bind def

% Function printpage: Print a physical page.
/printpage
    { /sheetside 0 def
      twinpage
      {  noborder not
	    { sheetnumber }
	 if
      }
      {  noheader noborder not and
	    { sheetnumber }
	 if
      }
      ifelse
      showpage 
%      pagesave restore
      /sheet sheet 1 add def
    } bind def

% Function cleanup: terminates printing, flushing last page if necessary.
/cleanup
    { twinpage sheetside 1 eq and
         { printpage }
      if
    } bind def

%
% Function startpage: prints page header and page border and initializes
% printing of the file lines.  Page number is stored on the top of stack.
/startpage
    { /pagenum exch def
      sheetside 0 eq
	{ % /pagesave save def
	  landscape
	    { sheetwidth 0 inch translate	% new coordinates system origin
	      90 rotate				% landscape format
	      paper_adjust neg 0 translate
	    } if
	} if
      noborder not { printborder } if
      noheader not { printheader } if
      nofooter not { printfooter } if
      nopunchmark not { punchmark } if
	 upperx sheetside get  bodymargin  add
	    uppery
	    bodymargin bodyfontsize add  noheader {0} {headersize} ifelse  add
	 sub
      moveto
    } bind def

% Function printheader: prints page header.
/printheader
    { upperx sheetside get  uppery headersize sub 1 add  moveto
      datefont setfont
      gsave
        datefontsize headermargin rmoveto
	date show					% date/hour
      grestore
      gsave
	pagenum pnum cvs pop
	   pagewidth pagenumwidth sub
	   headermargin
	rmoveto
        (Page ) show pnum show				% page number
      grestore
      empty pnum copy pop
      gsave
        filenamefont setfont
	      filenameroom fname stringwidth pop sub 2 div datewidth add
	      filenamefontsize 2 mul 
	   add 
	   headermargin
	rmoveto
        fname show						% file name
      grestore
    } bind def

% Function printfooter: prints page footer.
/printfooter
    { upperx 0 get sheetnumbery moveto
      footerfont setfont
      fname show
    } bind def

% Function printborder: prints border page.
/printborder 
    { upperx sheetside get uppery moveto
      gsave					% print the four sides
        pagewidth 0 rlineto			% of the square
        0 pageheight neg rlineto
        pagewidth neg 0 rlineto
        closepath stroke
      grestore
      noheader not
         { 0 headersize neg rmoveto pagewidth 0 rlineto stroke }
      if
    } bind def

% Punch Marker
/punchmark {
  gsave
    newpath punchx punchy moveto
    punchx 2 add punchy -0.5 add lineto
    punchx 2 add punchy 0.5 add lineto
    punchx punchy lineto
    closepath
    0 setgray .8 setlinewidth stroke
  grestore
  } bind def

%
% Function endpage: adds a sheet number to the page (footnote) and prints
% the formatted page (physical impression). Activated at the end of each
% source page (lines reached or FF character).
/endpage
   { twinpage  sheetside 0 eq  and
        { /sheetside 1 def }
        { printpage }
     ifelse
   } bind def

% Function sheetnumber: prints the sheet number.
/sheetnumber
    { sheetnumberx sheetnumbery moveto
      datefont setfont
      sheet pnum cvs
	 dup stringwidth pop (0) stringwidth pop sub neg 0 rmoveto show
      empty pnum copy pop
    } bind def

% Function bs: go back one character width to emulate BS
/bs { backspacewidth neg 0 rmoveto } bind def

% Function s: print a source string
/s  { fontarray fonttype get setfont
      show
    } bind def

% Function ks: print a kanji source string
/ks { kfontarray fonttype get setfont
      KanjiRomanDiffHalf 0 rmoveto
      KanjiRomanDiff 0 3 -1 roll ashow
      KanjiRomanDiffHalf neg 0 rmoveto
    } def

% Function bl: beginning of line
/bl { gsave } bind def

% Function nl: newline
/nl {
      grestore
      0 bodyfontsize 1.1 mul neg rmoveto
    } bind def

% Function cr: carriage return
/cr { grestore } bind def

% Function hlr: half-line up
/hlr { 0 bodyfontsize 0.55 mul rmoveto } bind def

% Function hlr: half-line down
/hlf { 0 bodyfontsize 0.55 mul neg rmoveto } bind def

% Function hlr: half-character backward
/hcr { backspacewidth 2 div neg 0 rmoveto } bind def

% Function hlr: half-character forward
/hcf { backspacewidth 2 div 0 rmoveto } bind def

/R { /fonttype 0 def } bind def
/B { /fonttype 1 def } bind def
/I { /fonttype 2 def } bind def
R
/docsave save def
startdoc
%%EndProlog

(llDataPrint.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#!/usr/local/bin/bltwish) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (## Environment Set) s nl
bl ( ) s nl
bl ( ) s (if [file exists llDataPrint.wish ] {) s nl
bl ( ) s (    lappend auto_path [ pwd ]) s nl
bl ( ) s (    auto_mkindex [ pwd ] *.wish) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (if [info exists env\(EOS_HOME\) ] {) s nl
bl ( ) s (    set path $env\(EOS_HOME\)/bin/wish/llDataPrint) s nl
bl ( ) s (} else {) s nl
bl ( ) s (    set path [ pwd ]) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (if [info exists env\(EOS_HOME\)] {) s nl
bl ( ) s (    set libpath $env\(EOS_HOME\)/lib) s nl
bl ( ) s (} else {) s nl
bl ( ) s (    set libpath {}) s nl
bl ( ) s (}) s nl
bl ( ) s (if ![file exists $path/llDataPrint.wish] {) s nl
bl ( ) s (    tk_dialog .d "Error:" "Wrong Directory!" error 0 OK) s nl
bl ( ) s (    exit 0) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (lappend auto_path $libpath) s nl
bl ( ) s (lappend auto_path $path) s nl
bl ( ) s nl
bl ( ) s (auto_mkindex $path    *.wish) s nl
bl ( ) s (auto_mkindex $libpath *.wish) s nl
bl ( ) s nl
bl ( ) s (# Try to import the blt namespace into the global scope.  If it) s nl
bl ( ) s (# fails, we'll assume BLT was loaded into the global scope.) s nl
bl ( ) s (#) s nl
bl ( ) s (catch { ) s nl
bl ( ) s (    import add blt ) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (#) s nl
bl ( ) s (# Convenient "quit" key) s nl
bl ( ) s (#) s nl
bl ( ) s (bind all <Control-KeyPress-c> { exit 0 } ) s nl
bl ( ) s (focus .) s nl
bl ( ) s nl
bl ( ) s (#) s nl
bl ( ) s (# Replace Tk widgets with tiling widgets) s nl
bl ( ) s (#) s nl
bl ( ) s nl
bl ( ) s (set tileCmds { button checkbutton radiobutton frame label scrollbar toplevel }) s nl
bl ( ) s nl
bl ( ) s (if { [info commands "namespace"] == "namespace" } {) s nl
bl ( ) s (    namespace import blt::*) s nl
bl ( ) s (} else {) s nl
bl ( ) s (    foreach cmd $tileCmds  {) s nl
bl ( ) s (        rename $cmd "") s nl
bl ( ) s (        rename tile$cmd $cmd) s nl
bl ( ) s (    }) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (set llMaxOnePage 10) s nl
bl ( ) s nl

endpage
2 startpage
bl ( ) s (llDataPrintOptionSet ) s nl
bl ( ) s nl
bl ( ) s (proc FormatLabel { w value } {) s nl
bl ( ) s (    puts stderr "tick is $value") s nl
bl ( ) s (    return $value) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (set remote {}) s nl
bl ( ) s nl
bl ( ) s (wm min . 10 10) s nl
bl ( ) s nl
bl ( ) s (#) s nl
bl ( ) s (# ) s nl
bl ( ) s (#) s nl
bl ( ) s (llDataPrintInit) s nl
bl ( ) s (llDataPrintMenuSet) s nl
bl ( ) s (llDataPrintGraphCreate) s nl
bl ( ) s (llDataPrintDesktopSet 0) s nl
bl ( ) s nl

endpage
(llDataPrintDesktop.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#!/usr/local/bin/bltwish) s nl
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintDesktopSet { re } {) s nl
bl ( ) s (        global nFrame   ) s nl
bl ( ) s nl
bl ( ) s (        if $re {) s nl
bl ( ) s (                puts "redraw") s nl
bl ( ) s (                pack forget .menu) s nl
bl ( ) s (                pack forget .graphFrames\($nFrame\(old\)\)) s nl
bl ( ) s (        }) s nl
bl ( ) s nl
bl ( ) s (        tk_menuBar .menu .menu.file .menu.edit .menu.help) s nl
bl ( ) s (        pack .menu -fill x -side top -expand true -ipadx 3 -ipady 3) s nl
bl ( ) s nl
bl ( ) s (        #puts $nFrame\(current\)) s nl
bl ( ) s (        #puts .graphFrames\($nFrame\(current\)\)) s nl
bl ( ) s nl
bl ( ) s (        pack .graphFrames\($nFrame\(current\)\) -fill both -side bottom -expand true) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintGraph.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#!/usr/local/bin/bltwish) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintGraphCreate { } {) s nl
bl ( ) s (        global llMax    ) s nl
bl ( ) s (        global truePitch ) s nl
bl ( ) s (        global nRMax) s nl
bl ( ) s (        global Rmax) s nl
bl ( ) s (        global Rmin) s nl
bl ( ) s (        global NN) s nl
bl ( ) s (        global NL) s nl
bl ( ) s (        global nFrame) s nl
bl ( ) s (        global Mode) s nl
bl ( ) s (        set nF 0) s nl
bl ( ) s (        for {set i 0} { $i < $llMax } {incr i 1} {) s nl
bl ( ) s (                global vR$i) s nl
bl ( ) s (                global vA$i) s nl
bl ( ) s (                global vP$i) s nl
bl ( ) s nl
bl ( ) s (                set nF      [expr $i/\($nFrame\(column\)*$nFrame\(row\)\)]) s nl
bl ( ) s (                set nRow    [expr $i%$nFrame\(row\)]) s nl
bl ( ) s (                set nColumn [expr \($i%\($nFrame\(column\)*$nFrame\(row\)\)\)/$nFrame\(row\)]) s nl
bl ( ) s (#               puts "$nF $nRow $nColumn\\n") s nl
bl ( ) s (#               if [ catch { frame .graphFrame } ] {) s nl
bl ( ) s (#               }) s nl
bl ( ) s (                if [ catch { frame .graphFrames\($nF\) } ] {) s nl
bl ( ) s (                        #puts "test nF:$nF, nR:$nRow, nC:$nColumn\\n") s nl
bl ( ) s (                }) s nl
bl ( ) s (                set graph .graph\($i\)) s nl
bl ( ) s (                if [ catch { graph $graph } ] {) s nl
bl ( ) s (                }) s nl
bl ( ) s (                $graph configure \\) s nl
bl ( ) s (                        -title "\($NN\($i\), $NL\($i\)\)" \\) s nl
bl ( ) s (                        -background white) s nl
bl ( ) s (        ) s nl
bl ( ) s (                # Amplitude) s nl
bl ( ) s (                if [ catch { $graph element create Amplitude \\) s nl
bl ( ) s (                        -x vR$i \\) s nl
bl ( ) s (                        -y vA$i } ] {) s nl
bl ( ) s (                } else {) s nl
bl ( ) s (                        $graph pen create AmplitudePen) s nl
bl ( ) s (                        $graph pen configure AmplitudePen "activeLine" \\) s nl
bl ( ) s (                                -color blue \\) s nl
bl ( ) s (                                -type  line \\) s nl
bl ( ) s (                                -linewidth 0.01i \\) s nl
bl ( ) s (                                -pixels 0 ) s nl
bl ( ) s (                        $graph pen create AmplitudesPen) s nl
bl ( ) s (                        $graph pen configure AmplitudesPen "activeLine" \\) s nl
bl ( ) s (                                -color blue \\) s nl
bl ( ) s (                                -symbol circle \\) s nl
bl ( ) s (                                -pixels 0.001i \\) s nl
bl ( ) s (                                -type line ) s nl
bl ( ) s (                }) s nl
bl ( ) s nl
bl ( ) s (                # Phase Axis) s nl
bl ( ) s (                if [ catch { $graph element create Phase \\) s nl
bl ( ) s (                        -x vR$i \\) s nl
bl ( ) s (                        -y vP$i } ] {) s nl
bl ( ) s (                } else {) s nl
bl ( ) s (                        $graph pen create PhasePen) s nl
bl ( ) s (                        $graph pen configure PhasePen "activeLine" \\) s nl
bl ( ) s (                                -color red \\) s nl
bl ( ) s (                                -symbol circle \\) s nl
bl ( ) s (                                -pixels 0.02i \\) s nl
bl ( ) s (                                -linewidth 0 \\) s nl
bl ( ) s (                                -type line ) s nl

endpage
2 startpage
bl ( ) s (                }) s nl
bl ( ) s nl
bl ( ) s (                #) s nl
bl ( ) s (                #) s nl
bl ( ) s (                #) s nl
bl ( ) s (                switch $Mode {) s nl
bl ( ) s (                        Single {) s nl
bl ( ) s (                                $graph element configure Amplitude -pen AmplitudePen ) s nl
bl ( ) s nl
bl ( ) s (                                $graph element configure Phase -pen PhasePen \\) s nl
bl ( ) s (                                        -mapy y2) s nl
bl ( ) s (                        }) s nl
bl ( ) s (                        Multi {) s nl
bl ( ) s (                                $graph element configure Amplitude -pen AmplitudesPen) s nl
bl ( ) s ( ) s nl
bl ( ) s nl
bl ( ) s (                                $graph element configure Phase -pen PhasePen \\) s nl
bl ( ) s (                                        -mapy y2) s nl
bl ( ) s (                        }) s nl
bl ( ) s (                }       ) s nl
bl ( ) s (                table .graphFrames\($nF\) $graph $nRow,$nColumn) s nl
bl ( ) s (                table configure .graphFrames\($nF\) \\) s nl
bl ( ) s (                        -columns $nFrame\(column\) \\) s nl
bl ( ) s (                        -rows    $nFrame\(row\) ) s nl
bl ( ) s nl
bl ( ) s (                .graphFrames\($nF\) configure -visual best ) s nl
bl ( ) s (#) s nl
bl ( ) s nl
bl ( ) s (                Blt_ZoomStack    $graph) s nl
bl ( ) s (                Blt_Crosshairs   $graph) s nl
bl ( ) s (                Blt_ActiveLegend $graph) s nl
bl ( ) s (                Blt_ClosestPoint $graph) s nl
bl ( ) s nl
bl ( ) s (#) s nl
bl ( ) s (# Axis Configuration) s nl
bl ( ) s (#) s nl
bl ( ) s (                if { $Rmax < $Rmin } {) s nl
bl ( ) s (                        set tmp $Rmax) s nl
bl ( ) s (                        set Rmax $Rmin) s nl
bl ( ) s (                        set Rmin $tmp) s nl
bl ( ) s (                }) s nl
bl ( ) s (                $graph xaxis configure \\) s nl
bl ( ) s (                        -color black \\) s nl
bl ( ) s (                        -title "" \\) s nl
bl ( ) s (                        -loose false \\) s nl
bl ( ) s (                        -min $Rmin \\) s nl
bl ( ) s (                        -max $Rmax ) s nl
bl ( ) s nl
bl ( ) s (                $graph yaxis configure \\) s nl
bl ( ) s (                        -color black \\) s nl
bl ( ) s (                        -title "" \\) s nl
bl ( ) s (                        -loose true) s nl
bl ( ) s nl
bl ( ) s (                $graph y2axis configure \\) s nl
bl ( ) s (                        -color black \\) s nl
bl ( ) s (                        -title "" \\) s nl
bl ( ) s (                        -loose false \\) s nl
bl ( ) s (                        -stepsize 90 \\) s nl
bl ( ) s (                        -min -30 \\) s nl
bl ( ) s (                        -max 390) s nl
bl ( ) s nl
bl ( ) s (                $graph legend configure -hide yes) s nl
bl ( ) s (        }) s nl
bl ( ) s (        set nFrame\(max\) $nF) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintInit.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintInit { } {) s nl
bl ( ) s (        global inFileName) s nl
bl ( ) s (        global outFileName) s nl
bl ( ) s (        global nFrame ) s nl
bl ( ) s nl
bl ( ) s (        wm title        . $inFileName) s nl
bl ( ) s (        wm protocol . WM_DELETE_WINDOW "Delete Window") s nl
bl ( ) s nl
bl ( ) s (        # Graph Frame Initial Setting ) s nl
bl ( ) s (        set nFrame\(current\) 0) s nl
bl ( ) s (        set nFrame\(old\)         0) s nl
bl ( ) s (        set nFrame\(max\)         0) s nl
bl ( ) s (        set nFrame\(row\)         4) s nl
bl ( ) s (        set nFrame\(column\)      2) s nl
bl ( ) s (        set nFrame\(psrow\)    4) s nl
bl ( ) s (        set nFrame\(pscolumn\) 2) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintMenu.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#!/usr/local/bin/bltwish) s nl
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintMenuSet {} {) s nl
bl ( ) s (        global nFrame) s nl
bl ( ) s nl
bl ( ) s (        frame .menu -relief raised -bd 2) s nl
bl ( ) s (        ) s nl
bl ( ) s (        menubutton .menu.file -text "File" -menu .menu.file.m -underline 0) s nl
bl ( ) s (        menubutton .menu.edit -text "Edit" -menu .menu.edit.m -underline 0) s nl
bl ( ) s (        menubutton .menu.help -text "Help" -menu .menu.help.m -underline 0) s nl
bl ( ) s (        button     .menu.prev -text "Prev" -command llDataPrintPrevGraphWatch) s nl
bl ( ) s (        button     .menu.next -text "Next" -command llDataPrintNextGraphWatch) s nl
bl ( ) s nl
bl ( ) s (        set m [ menu .menu.file.m ]) s nl
bl ( ) s (        $m add com -label "Open" -command {}  ) s nl
bl ( ) s (        $m add com -label "New"  -command {} ) s nl
bl ( ) s (        $m add com -label "Save\(PS\)" -command  { ) s nl
bl ( ) s (                for { set i 0 } { $i <= $nFrame\(max\) } { incr i 1 } {) s nl
bl ( ) s (                        llDataPrintNextGraphWatch) s nl
bl ( ) s (                }) s nl
bl ( ) s (                llDataPrintSavePS ) s nl
bl ( ) s (        } ) s nl
bl ( ) s nl
bl ( ) s (        $m add separator) s nl
bl ( ) s (        $m add com -label "Exit" -command { exit 0 } ) s nl
bl ( ) s (        ) s nl
bl ( ) s (        set m [ menu .menu.edit.m ]) s nl
bl ( ) s (        $m add com -label "Preference"  -command llDataPrintPreferenceWinCreate ) s nl
bl ( ) s (        $m add com -label "Next"  -command llDataPrintNextGraphWatch) s nl
bl ( ) s (        $m add com -label "Prev"  -command llDataPrintPrevGraphWatch) s nl
bl ( ) s nl
bl ( ) s (        pack .menu.file .menu.edit .menu.prev .menu.next .menu.help \\) s nl
bl ( ) s (                -fill x \\) s nl
bl ( ) s (                -side left \\) s nl
bl ( ) s (                -expand true \\) s nl
bl ( ) s (                -ipadx 3 \\) s nl
bl ( ) s (                -ipady 3) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (proc llDataPrintPrevGraphWatch { } {) s nl
bl ( ) s (        global nFrame ) s nl
bl ( ) s nl
bl ( ) s (        set nFrame\(old\) $nFrame\(current\)) s nl
bl ( ) s (        if { $nFrame\(current\) == 0 }  {) s nl
bl ( ) s (                set nFrame\(current\) $nFrame\(max\)) s nl
bl ( ) s (        } else {) s nl
bl ( ) s (                set nFrame\(current\) [expr $nFrame\(old\) - 1 ]) s nl
bl ( ) s (        }) s nl
bl ( ) s (        llDataPrintDesktopSet 1) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (proc llDataPrintNextGraphWatch { } {) s nl
bl ( ) s (        global nFrame ) s nl
bl ( ) s nl
bl ( ) s (        set nFrame\(old\) $nFrame\(current\)) s nl
bl ( ) s (        if { $nFrame\(current\) == $nFrame\(max\) }  {) s nl
bl ( ) s (                set nFrame\(current\) 0 ) s nl
bl ( ) s (        } else {) s nl
bl ( ) s (                set nFrame\(current\) [expr $nFrame\(old\) + 1 ]) s nl
bl ( ) s (        }) s nl
bl ( ) s (        llDataPrintDesktopSet 1) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintOption.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#!/usr/local/bin/bltwish) s nl
bl ( ) s (#) s nl
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintOptionSet {} {) s nl
bl ( ) s (        option add *Label.font *Helvetica-Bold-R-*-12-*) s nl
bl ( ) s (        option add *title.font *Helvetica-Bold-R-*-14-*) s nl
bl ( ) s (        option add *Entry.font *Courier-Medium-R-*-12-*) s nl
bl ( ) s nl
bl ( ) s (        option add *TileOffset          0) s nl
bl ( ) s (        option add *HighlightThickness      0) s nl
bl ( ) s (        option add *takeFocus           1) s nl
bl ( ) s (        ) s nl
bl ( ) s (        option add *graph.elemActiveColor   yellow4) s nl
bl ( ) s (        option add *graph.elemActiveFill    yellow) s nl
bl ( ) s (        option add *graph.elemPixels        2 ) s nl
bl ( ) s (        option add *graph.elemScaleSymbols  1) s nl
bl ( ) s nl
bl ( ) s (        option add *Graph.psDecorations true) s nl
bl ( ) s (        option add *Graph.PsLandscape   false) s nl
bl ( ) s nl
bl ( ) s (        set visual [winfo screenvisual .] ) s nl
bl ( ) s (        if { $visual != "staticgray" } {) s nl
bl ( ) s (            option add *print.background yellow) s nl
bl ( ) s (            option add *quit.background red) s nl
bl ( ) s (        }) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintPreference.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (#) s nl
bl ( ) s (proc llDataPrintPreferenceWinCreate { } {) s nl
bl ( ) s (        global Rmax) s nl
bl ( ) s (        global Rmin) s nl
bl ( ) s (        global NN) s nl
bl ( ) s (        global NL) s nl
bl ( ) s (        global truePitch) s nl
bl ( ) s (        global llMax) s nl
bl ( ) s (        global nFrame) s nl
bl ( ) s nl
bl ( ) s (        set w .pref) s nl
bl ( ) s (        if [ catch { toplevel $w -bd 4 } ] {) s nl
bl ( ) s (                raise $w) s nl
bl ( ) s (        } else {) s nl
bl ( ) s (                wm title $w "Preference"                ) s nl
bl ( ) s nl
bl ( ) s (                set R [ frame $w.sR ]) s nl
bl ( ) s (                CommandEntry $R.sRmax Rmax 20 {llDataPrintGraphCreate} -textvar Rmax) s nl
bl ( ) s (                CommandEntry $R.sRmin Rmin 20 {llDataPrintGraphCreate} -textvar Rmin) s nl
bl ( ) s (                pack $R.sRmin $R.sRmax -side left -fill x) s nl
bl ( ) s nl
bl ( ) s (                set R [ frame $w.nF ]) s nl
bl ( ) s (                button $R.prev -text prev -command llDataPrintPrevGraphWatch) s nl
bl ( ) s (                CommandEntry $R.current Frame 20 { llDataPrintDesktopSet 1 } -textvar) s nl
bl ( ) s ( nFrame\(current\)) s nl
bl ( ) s (                button $R.next -text next -command llDataPrintNextGraphWatch) s nl
bl ( ) s (                pack $R.prev $R.current $R.next -side left -fill x) s nl
bl ( ) s nl
bl ( ) s (                set R [ frame $w.layerLine ]) s nl
bl ( ) s (                #CheckButtonsCreate $R left {test test} {test2 test2}) s nl
bl ( ) s nl
bl ( ) s (                pack $w.sR $w.nF $w.layerLine -side top -fill x) s nl
bl ( ) s (        }) s nl
bl ( ) s (}) s nl

endpage
(llDataPrintSave.wish) newfile
/sheet 1 def
%%Page: 1 1
1 startpage
bl ( ) s (proc llDataPrintSavePS { } {) s nl
bl ( ) s (        llDataPrintSavePS0) s nl
bl ( ) s (}) s nl
bl ( ) s nl
bl ( ) s (proc llDataPrintSavePS0 { } {) s nl
bl ( ) s (        global inFileName) s nl
bl ( ) s (        global outFileName) s nl
bl ( ) s (        global fileSave) s nl
bl ( ) s (        global .graph) s nl
bl ( ) s (        global nFrame) s nl
bl ( ) s (        global llMax) s nl
bl ( ) s nl
bl ( ) s (        if { "" == $outFileName } {) s nl
bl ( ) s (                set outFileName [ fileSave ]) s nl
bl ( ) s (        }) s nl
bl ( ) s (        #set fontmap [ .graph\(0\) postscript cget fontmap ]) s nl
bl ( ) s (        #puts $fontmap) s nl
bl ( ) s nl
bl ( ) s (        exec touch  /tmp/all.llDataPrint) s nl
bl ( ) s (        exec rm     /tmp/all.llDataPrint) s nl
bl ( ) s nl
bl ( ) s (        #set nowFrame $nFrame\(current\) ) s nl
bl ( ) s nl
bl ( ) s (    for {set i 0} { $i < $llMax } {incr i 1} {) s nl
bl ( ) s (                set nF      [expr  $i/\($nFrame\(column\)*$nFrame\(row\)\)]) s nl
bl ( ) s (                set nRow    [expr  $i%$nFrame\(row\)]) s nl
bl ( ) s (                set nColumn [expr \($i%\($nFrame\(column\)*$nFrame\(row\)\)\)/$nFrame\(row\)]) s nl
bl ( ) s nl
bl ( ) s (                set nFrame\(old\)     $nFrame\(current\)) s nl
bl ( ) s (                set nFrame\(current\) $nF) s nl
bl ( ) s nl
bl ( ) s (                #llDataPrintDesktopSet 1) s nl
bl ( ) s nl
bl ( ) s (                #focus -force .graphFrames\($nF\)) s nl
bl ( ) s (                #puts "$nF $nRow $nColumn") s nl
bl ( ) s (                .graph\($i\) postscript output /tmp/$i.llDataPrint  \\) s nl
bl ( ) s (                                -center false \\) s nl
bl ( ) s (                                -height 200  \\) s nl
bl ( ) s (                                -width  350  \\) s nl
bl ( ) s (                                -padx [expr 50 + $nColumn*350] \\) s nl
bl ( ) s (                                -pady [expr $nRow*250 ]) s nl
bl ( ) s nl
bl ( ) s (                exec echo "%%Page:" >> /tmp/all.llDataPrint) s nl
bl ( ) s (                exec cat /tmp/$i.llDataPrint >> /tmp/all.llDataPrint) s nl
bl ( ) s (        }       ) s nl
bl ( ) s (        exec psFilePageMerge -i /tmp/all.llDataPrint -o $outFileName -p 8) s nl
bl ( ) s nl
bl ( ) s (        #set nFrame\(current\)  $nowFrame) s nl
bl ( ) s (        #llDataPrintDesktopSet 1) s nl
bl ( ) s (}) s nl

endpage

%%Trailer
cleanup
docsave restore end
