/*
  # pdbView : $Revision$  
  # $Date$ 
  # Created by $Author$
  # Usage : pdbView
  # Attention
  #   $Loccker$
  #  	$State$ 
  #
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stream.h>
#include "vtk.h"

#include <pgsql/libpq-fe.h>

#define GLOBAL_DECLARATION
#include "../inc/config.h"

#include "./ShapeMaker.hh"
#include "ShapeMaker.cc"

#include "./DataBase.hh"
#include "DataBase.cc"

#include "./DataBaseMaker.hh"
#include "DataBaseMaker.cc"


#include "./FunctionMode.hh"

#include "./HomologyStore.hh"
#include "HomologyStore.cc"

#define DEBUG
#include "genUtil.h"
#include "pdbFile.h"
#include "Memory.h"

#include "./DataStore.hh"
#include "DataStore.cc"

#include "./ActorMaker.hh"
#include "ActorMaker.cc"


#include "vtkTextMapper.h"
#include "vtkPicker.h"

class FigureFactory
{
private:
  pdbFile* pdb;
  vtkPolyDataMapper* mapper;
  vtkActor* actor;
  DataStore* dataStore;
  SphereMaker* sphereMaker;
  LineMaker* lineMaker;
  ActorMaker* actorMaker;
  vtkRenderer* ren;
  vtkAssembly* AllMolecule;
  vtkAssembly* CaOnly;
  vtkAssembly* LineOnly;

public:
  FigureFactory();
  void SetData(void* data, void* p, void* render);
  void MAKE(ViewerMode);
  void MakeSphere();
  void MakeLine();
};


FigureFactory::FigureFactory()
{

}

void FigureFactory::SetData(void* data, void* p, void* render)
{
    dataStore = (DataStore*)data;
    pdb = (pdbFile*)p;
    ren = (vtkRenderer *)render;
}


void FigureFactory::MAKE(ViewerMode mode)
{

  switch(mode){
  case SpaceFill:
    sphereMaker = new SphereMaker();
    MakeSphere();
    break;

  case BackBone:
    sphereMaker = new SphereMaker();
    lineMaker = new LineMaker();
    MakeLine();
    break;

  }





}

void FigureFactory::MakeLine()
{
  float x;
  float y;
  float z;
  int i = 1;
  int j = 1;
  cout << form("PdbFile///// = %d\n",pdb->nAtom);
  dataStore->SetArea(pdb->nAtom);
  
  LineOnly = vtkAssembly::New();
  CaOnly = vtkAssembly::New();

  float BeforePoint[3] = {0, 0, 0};
  float AfterPoint[3] = {0, 0, 0};

  pdbFileTop(pdb);
  while(1){
    if(pdbFileIsAtom(pdb)){
      if(pdbFileIsCA(pdb)){
	pdbFileCoordGet(pdb, &x, &y, &z);
	if(j!=1){
	  AfterPoint[0] = x;
	  AfterPoint[1] = y;
	  AfterPoint[2] = z;
	  lineMaker->MAKE(BeforePoint,AfterPoint);
	  actorMaker = new ActorMaker();
	  actorMaker->SetMapper(lineMaker->GetMapper());
	  actorMaker->SetColor(0.5, 0.8, 0.9);
	  
	  LineOnly->AddPart(actorMaker->GetActor());
	  
	}
	BeforePoint[0] = x;
	BeforePoint[1] = y;
	BeforePoint[2] = z;
	
	sphereMaker->SetPosition(x, y, z);
	sphereMaker->SetResolution(2 , 2);
	sphereMaker->SetRadius(0.1);
	sphereMaker->MAKE();
	actorMaker = new ActorMaker();
	actorMaker->SetMapper(sphereMaker->GetMapper());
	actorMaker->SetColor(0.5, 0.8, 0.9);
	CaOnly->AddPart(actorMaker->GetActor());
	dataStore->SET(pdb->PDB,actorMaker->GetActor(),sphereMaker->GetMapper(),i);
	j = j + 1;
      }
      i = i + 1;
    }
    if(pdbFileEnd(pdb)){
      break;
    } else {
      pdbFileNext(pdb);
    }
  }
   
  ren->AddActor(CaOnly);  
  ren->AddActor(LineOnly);  
  
  
}




void FigureFactory::MakeSphere()
{
  float x;
  float y;
  float z;
  int i=1;
  
  cout << form("PdbFile///// = %d\n",pdb->nAtom);
  dataStore->SetArea(pdb->nAtom);
  
  AllMolecule = vtkAssembly::New();
  CaOnly = vtkAssembly::New();
  
  pdbFileTop(pdb);
  while(1){
    if(pdbFileIsAtom(pdb)){
      pdbFileCoordGet(pdb, &x, &y, &z);
      
      sphereMaker->SetPosition(x, y, z);
      sphereMaker->SetResolution(10 , 10);
      sphereMaker->MAKE();
      actorMaker = new ActorMaker();
      actorMaker->SetMapper(sphereMaker->GetMapper());
      actorMaker->SetColor(0.5, 0.8, 0.9);
      AllMolecule->AddPart(actorMaker->GetActor());
      if(pdbFileIsCA(pdb))
	{
	  CaOnly->AddPart(actorMaker->GetActor());
	}
      dataStore->SET(pdb->PDB,actorMaker->GetActor(),sphereMaker->GetMapper(),i);
      
      i=i+1;
    }
    if(pdbFileEnd(pdb)){
      break;
    } else {
      pdbFileNext(pdb);
    }
  }
  
  ren->AddActor(CaOnly);
  //ren->AddActor(AllMolecule);  
}



class DataSearcher{
private:
  DataStore* dataStore;
  pdbRecord* pdb;
  TextMode Mode;
  vtkActor* actor;

public:
  DataSearcher();
  void DataSearcher::SetData(void* data);
  int DataSearcher::GetData(vtkAbstractMapper3D* mapper);
  char* DataSearcher::GetData(vtkAbstractMapper3D* mapper, CG mode);
  void ModeSet(TextMode m);
  char* ReturnText(pdbRecord* pdb);
  void SetActor(vtkActor* a);
  void ChangeColor(vtkAbstractMapper3D* mapper);
  void ChangeColor(int i);
};

DataSearcher::DataSearcher()
{
  Mode = AllSet;
}

void DataSearcher::SetData(void* data)
{
 
  dataStore = (DataStore*)data;
}

void DataSearcher::ModeSet(TextMode m)
{
  Mode = m;
}

char* DataSearcher::GetData(vtkAbstractMapper3D* mapper, CG mode)
{
  vtkAbstractMapper3D* map;
  int i=0;
  
  switch(mode){
  case CAonly:

    dataStore->ResetCaList();
 
    while(i!=-1){
      i = dataStore->GetCaListSerial();
      map = dataStore->GetMapper(i);
      if(mapper == map){
	//SetActor(dataStore->GetActor(i));
	return ReturnText(dataStore->GetPdb(i));
	//return dataStore->GetPdb(i);
      }else if(map == NULL){
	return NULL;
      }
    }
    break;

  case All:
    for(i=0; i<1000000 ; i++){
      map = dataStore->GetMapper(i);
      if(mapper == map){
	return ReturnText(dataStore->GetPdb(i));
      }
      if(mapper == NULL)
	break;
    }
    break;
  }
  return NULL;
}


int DataSearcher::GetData(vtkAbstractMapper3D* mapper)
{
  int i;
  vtkAbstractMapper3D* map;
  
  for(i=0; i<10000000 ; i++){
    map = dataStore->GetMapper(i);
    if(mapper == map){
      return i;
    }else if(map == NULL){
      return 0;
    }
  }
  return 0;
}

void DataSearcher::SetActor(vtkActor* a)
{
  actor = (vtkActor*)a;
}


void DataSearcher::ChangeColor(vtkAbstractMapper3D* mapper)
{
  ActorMaker* actorMaker;
  actorMaker = new ActorMaker();
  printf("ResetColor!!!!\n");

  actorMaker->SetActor(dataStore->GetActor(GetData(mapper)));
  actorMaker->SetColor(1.0, 1.0, 1.0);
}


void DataSearcher::ChangeColor(int i)
{
  ActorMaker* actorMaker;
  actorMaker = new ActorMaker();
  printf("ChangeColor!!!!\n");
  actorMaker->SetActor(dataStore->GetActor(i));
  //printf("getActor (%d)  = %d\n",i,dataStore->GetActor(i));
  actorMaker->SetColor(0.9, 0.3, 0.3);
}

char* DataSearcher::ReturnText(pdbRecord* pdb)
{

  char* text;

  text = (char*)memoryAllocate(sizeof(char)*100, "in ReturnText");

  switch(Mode){
  case ResidueSequenceNumber:
      sprintf(text, "%ld",pdb->ResidueSequenceNumber);
      break;
  case AtomName:
      sprintf(text, "%s",pdb->AtomName);
      break;
  case ResidueName:
      sprintf(text, "%s",pdb->ResidueName);
      break;
  case ChainIdentifier:
      sprintf(text, "%c",pdb->ChainIdentifier);
      break;
  case AllSet:
      sprintf(text, "%c:%s %ld:%s",pdb->ChainIdentifier,pdb->ResidueName,pdb->ResidueSequenceNumber,pdb->AtomName);
      break;
 
  case Homology:
    sprintf(text, "-%s-",dataStore->GetOneCharacter(pdb));
    ChangeColor((int)(pdb->AtomSerialNumber));
    /*
      HomologyStore homologyStore;
      HomologyMode mode;
      mode = AllView;
      
      HomologyStore.SetKey(pdb->ResidueSequenceNumber,pdb->ResidueName,mode);
      sprintf(text, "%c:%s %ld:%s",pdb->ChainIdentifier,pdb->ResidueName,pdb->ResidueSequenceNumber,pdb->AtomName);
    */
    
    break;
  }
  return text;
}

/*
class PickedDataStore;

class PickedDataStore{
private:
  vtkVectorText* text;

  PickedDataStore* TOP;
  PickedDataStore* CURRENT;

  vtkAbstractMapper3D* PickedMapper;
  vtkPolyDataMapper* TextMapper;
  vtkVectorText* TextActor;
  PickedDataStore* NEXT;
  
public:
  
  
};

*/

/*

PickedDataStore::PickedDataStore()
{

  TOP = new PickedDataStore();
  
  TOP->PickedMapper =  vtkAbstractMapper3D::New(); 
  TOP->TextMapper = vtkPolyDataMapper::New();
  TOP->TextActor  = vtkVectorText::New();
  TOP->NEXT = new PickedDataStore();
  TOP->NEXT = NULL;
  TOP=TOP->NEXT;
}
*/
/*

void PickedDataStore::APPEND(PickedDataStore* before)
{
  tmp = new PickedDataStore();

  tmp->PickedMapper =  vtkAbstractMapper3D::New(); 
  tmp->TextMapper = vtkPolyDataMapper::New();
  tmp->TextActor  = vtkVectorText::New();
  tmp->NEXT = new PickedDataStore();
  tmp->NEXT = NULL;

  before->NEXT = tmp;
CURRENT = tmp;
}


void PickedDataStore::SetText(char* text)
{
  text = vtkVectorText::New();




}

void PickedDataStore::SetCurrent()
{
  while(CURRENT->NEXT!=NULL)
    {
      CURRENT=CURRENT->NEXT;
    }
}


vtkVectorText* PickedDataStore::GetTextActor()
{
  SetCurrent();
  return CURRENT->TextActor;
}


*/
/*
int PickedDataStore::NewOrDelete(vtkAbstractMapper3D* mapper)
{
  PickedDataStore* now;
  int create = 0;
  now = TOP;

  while(now->NEXT!=NULL){
     if(now->PickedMapper == mapper){

//Color-Change
//Link-Change
//DELETE
      dataSearcher->ChangeColor(mapper);
      Now->NEXT = Now->NEXT->NEXT;
      delete Now;

      create = 1;
      return create;
      break;
    }
    Now = Now->NEXT;
  }
  
  if(create == 0)
    {


//To-NULL
//APPEND


      Now->NEXT = new PickedList(NULL, mapper);
      Now->NEXT->NEXT = NULL;
      Now = Now->NEXT;
      return create;
    }
}



}
*/




class eosDataPicker{
private:

  vtkActor* pickActor;
  vtkAbstractMapper3D* pickMapper;

  vtkFollower* textActor;
  vtkPolyDataMapper* textMapper;
  vtkVectorText* text;

  vtkRenderer* ren;
  vtkCellPicker* picker;

  pdbRecord* pdbData;
 
  DataStore* dataStore;
  DataSearcher* dataSearcher;

  struct PickedList;  
  struct PickedList{
    
    vtkActor* PickedActor;
    vtkAbstractMapper3D* PickedMapper;
    vtkPolyDataMapper* TextMapper;
    vtkVectorText* TextActor;
    PickedList* NEXT;

    PickedList() {
      PickedActor = NULL;
      PickedMapper = NULL;
    }
    PickedList(vtkActor* actor, vtkAbstractMapper3D* mapper) {
      PickedActor = actor;
      PickedMapper = mapper;
      TextMapper = vtkPolyDataMapper::New();
      TextActor  = vtkVectorText::New();
    };
    PickedList* Append(vtkActor* actor, vtkAbstractMapper3D* mapper) {
      PickedList* tmp;
      tmp = this;

      while(tmp->NEXT!=NULL) {
	tmp = tmp->NEXT;
      }
      this->NEXT = new PickedList(actor, mapper);
      this->NEXT->NEXT=NULL;
      return this->NEXT;
    }
    
    ~PickedList() {
      TextActor->Delete();
      TextMapper->Delete();
    };

  }*pickedList;
  
  Current=Current->Append(actor, mapper);

  struct pickedList* Top;
  struct pickedList* tmp;

public:
  eosDataPicker();

  vtkCellPicker* eosDataPicker::GetPicker();
  void SetData(void* renderer, void* data);
  static void annotatePick(void* arg);
  void annotatePick0();
  vtkAbstractMapper3D* GetPickMapper();
  int PickedDataStore(vtkAbstractMapper3D* mapper);
};

eosDataPicker::eosDataPicker()
{
  picker = vtkCellPicker::New();  
  //textActor = vtkFollower::New();
  //textMapper = vtkPolyDataMapper::New();
  text = vtkVectorText::New();
  dataSearcher = new DataSearcher;

  Top = new PickedList(NULL,NULL);
  Top->NEXT = NULL;

  cout << form("eosDataPicker::eosDataPicker!!\n");

  picker->SetEndPickMethod(&annotatePick, this);
}

int eosDataPicker::PickedDataStore(vtkAbstractMapper3D* mapper)
{
  struct PickedList* Now;
  int create = 0;
  Now = Top;
  
  while(Now->NEXT!=NULL){
    if(Now->PickedMapper == mapper){
      dataSearcher->ChangeColor(mapper);
      Now->NEXT = Now->NEXT->NEXT;
      delete Now;

      create = 1;
      return create;
      break;
    }
    Now = Now->NEXT;
  }
  
  if(create == 0)
    {
      Now->NEXT = new PickedList(NULL, mapper);
      Now->NEXT->NEXT = NULL;
      Now = Now->NEXT;
      return create;
    }
}


void eosDataPicker::SetData(void* renderer, void* data)
{
  ren = (vtkRenderer*)renderer;
  dataStore = (DataStore*)data;
  dataSearcher->SetData(dataStore);

  cout << form("eosDataPicker::GetData!!\n");
}

void eosDataPicker::annotatePick(void* picker)
{
  //vtkRenderer* ren = (vtkRenderer*)arg;

  cout << form("eosDataPicker::annotatePick!!\n");

  ((eosDataPicker*)picker)->annotatePick0();
}

vtkCellPicker* eosDataPicker::GetPicker()
{
  return picker;
}

vtkAbstractMapper3D* eosDataPicker::GetPickMapper()
{
  return pickMapper;
}

void eosDataPicker::annotatePick0()
{

  float xp;
  float yp;
  float zp;
  float* pickPos;
  char* temp;

  //-p1=nothings was picked
  if((picker->GetCellId()) < 0)
    {
      textActor->VisibilityOff();
    }else{
      textActor->VisibilityOn();      
      pickPos = picker->GetPickPosition();
      
      xp = pickPos[0];
      yp = pickPos[1];
      zp = pickPos[2];
     
/*
 
      if(NULL==(pickActor = picker->GetActor())) {
	vtkAssembly* tmp;
	if(NULL!=(tmp=picker->GetAssembly())) {
	  vtkProp3D* p;
	  pickActor = (vtkActor*)tmp->GetParts()->GetItemAsObject(picker->GetSubId());
	  for(p=pickActor; p!=tmp->GetParts()->GetLastProp3D() && p!=NULL; p=tmp->GetParts()->GetNextProp3D()) {
	    cout << form("assembly+++A=%x\n",p);
	  }
	}
      }

*/

 
      pickMapper = picker->GetMapper();
      pickActor = picker->GetActor();  
      cout << form("address+++A=%d,M=%d\n",pickActor , pickMapper);

      if(PickedDataStore(pickMapper) == 1){
	break;
      }else{

      dataSearcher->ModeSet(Homology);
      //dataSearcher->ModeSet(AllSet);
      temp = dataSearcher->GetData(pickMapper,CAonly);
      printf("TEXT-YOTEI===========%s\n",temp);
      //pdbData = dataSearcher->GetData(pickMapper,CAonly);
      
      //pdbData = dataSearcher->GetData(pickMapper);
      
      if(pdbData!=NULL){

	text->SetText(temp);  

	//	text->SetText(form("%s",pdbData->));  
      }else{
	text->SetText("Not Identified");
      }
      
      //3D TEXT VERSION
      
      //text->SetText(form("%f,%f,%f",xp,yp,zp));
      textMapper->SetInput(text->GetOutput());
      textActor->SetMapper(textMapper);
      textActor->SetScale(0.3,0.3,0.3);
      textActor->SetPosition(xp,yp,zp);
      textActor->SetCamera(ren->GetActiveCamera()); 
      ren->AddActor(textActor);
      }

    }
     
}

/*
  Example:
  typedef struct lpdbViewInfo {
  float a;
  int   b;
  } lpdbViewInfo;
  
  typedef enum lpdbViewMode {
  a=0,
  b=1
  } lpdbViewMode;
*/


int
main(int argc, char* argv[]) 
{

  pdbViewInfo info;
  pdbFile pdb;
  pdbFile* ppdb;

  ppdb = &pdb;
  
  init0(&info);
  argCheck(&info, argc, argv);
  init1(&info);
  
  DEBUGPRINT("Program Start\n");
  cout << "start C++\n";
  pdbFileRead(info.fptIn, &pdb);
 

  FILE* TabFile;

  DataBaseMaker dataBaseMaker(TabFile, ppdb);

  vtkRenderer *ren = vtkRenderer::New();
  vtkRenderWindow *renWindow = vtkRenderWindow::New();
  renWindow->AddRenderer(ren);
  vtkRenderWindowInteractor *iren = vtkRenderWindowInteractor::New();
  iren->SetRenderWindow(renWindow);

  DataStore dataStore(ppdb);
  FigureFactory figureFactory;

  figureFactory.SetData(&dataStore, ppdb ,ren);
  figureFactory.MAKE(SpaceFill);
  //figureFactory.MAKE((ViewerMode)info.DisplayMode);

 
  eosDataPicker dataPicker;
  dataPicker.SetData(ren,&dataStore);
  iren->SetPicker(dataPicker.GetPicker());




  //SET TEXT 2D VERSION
  vtkTextMapper* tMapper = vtkTextMapper::New();
  tMapper->SetInput("pdbView");
  tMapper->ShadowOn();

  vtkActor2D* tActor = vtkActor2D::New();
  tActor->SetMapper(tMapper);
  tActor->SetPosition(0,0);

  ren->AddActor2D(tActor);


  //Axes
  vtkAxes* axes = vtkAxes::New();
  axes->SetOrigin(0,0,0);
  vtkPolyDataMapper* axesMapper = vtkPolyDataMapper::New();
  axesMapper->SetInput(axes->GetOutput());
  vtkActor* axesActor = vtkActor::New();
  axesActor->SetMapper(axesMapper);
  ren->AddActor(axesActor);


  //Cube
  vtkCubeSource *cube = vtkCubeSource::New();
  cube->SetCenter(0,0,0);
  cube->SetXLength(3);
  cube->SetYLength(3);
  cube->SetZLength(3);
  vtkPolyDataMapper *cubeMapper = vtkPolyDataMapper::New();
  cubeMapper->SetInput(cube->GetOutput());
  vtkActor *cubeActor = vtkActor::New();
  cubeActor->SetMapper(cubeMapper);
  cubeActor->GetProperty()->SetColor(0.5,0.5,0.5);
  
  ren->AddActor(cubeActor);

  //red
  vtkCubeSource *cube11 = vtkCubeSource::New();
  cube11->SetCenter(5,0,0);
  cube11->SetXLength(3);
  cube11->SetYLength(3);
  cube11->SetZLength(3);
  vtkPolyDataMapper *cubeMapper11 = vtkPolyDataMapper::New();
  cubeMapper11->SetInput(cube11->GetOutput());
  vtkActor *cubeActor11 = vtkActor::New();
  cubeActor11->SetMapper(cubeMapper11);
  cubeActor11->GetProperty()->SetColor(0.9,0.2,0.0);

  
  ren->AddActor(cubeActor11);

  //blue
  vtkCubeSource *cube22 = vtkCubeSource::New();
  cube22->SetXLength(3);
  cube22->SetYLength(3);
  cube22->SetZLength(3);
  cube22->SetCenter(-5,0,0);
  vtkPolyDataMapper *cubeMapper22 = vtkPolyDataMapper::New();
  cubeMapper22->SetInput(cube22->GetOutput());
  vtkActor *cubeActor22 = vtkActor::New();
  cubeActor22->SetMapper(cubeMapper22);
  cubeActor22->GetProperty()->SetColor(0.0,0.2,0.8);


  
  ren->AddActor(cubeActor22);

  //yellow
  vtkCubeSource *cube33 = vtkCubeSource::New();
  cube33->SetXLength(3);
  cube33->SetYLength(3);
  cube33->SetZLength(3);
  cube33->SetCenter(0,5,0);
  vtkPolyDataMapper *cubeMapper33 = vtkPolyDataMapper::New();
  cubeMapper33->SetInput(cube33->GetOutput());
  vtkActor *cubeActor33 = vtkActor::New();
  cubeActor33->SetMapper(cubeMapper33);
  cubeActor33->GetProperty()->SetColor(0.9,0.85,0.1);

  
  ren->AddActor(cubeActor33);

  //cyan
  vtkCubeSource *cube44 = vtkCubeSource::New();
  cube44->SetXLength(3);
  cube44->SetYLength(3);
  cube44->SetZLength(3);
  cube44->SetCenter(0,-5,0);
  vtkPolyDataMapper *cubeMapper44 = vtkPolyDataMapper::New();
  cubeMapper44->SetInput(cube44->GetOutput());
  vtkActor *cubeActor44 = vtkActor::New();
  cubeActor44->SetMapper(cubeMapper44);
  cubeActor44->GetProperty()->SetColor(0.0,0.95,0.95);

  
  ren->AddActor(cubeActor44);

  //white
  vtkCubeSource *cube55 = vtkCubeSource::New();
  cube55->SetXLength(3);
  cube55->SetYLength(3);
  cube55->SetZLength(3);
  cube55->SetCenter(10,0,0);
  vtkPolyDataMapper *cubeMapper55 = vtkPolyDataMapper::New();
  cubeMapper55->SetInput(cube55->GetOutput());
  vtkActor *cubeActor55 = vtkActor::New();
  cubeActor55->SetMapper(cubeMapper55);
  cubeActor55->GetProperty()->SetColor(1.0,1.0,1.0);


  
  ren->AddActor(cubeActor55);

  //pink
  vtkCubeSource *cube66 = vtkCubeSource::New();
  cube66->SetXLength(3);
  cube66->SetYLength(3);
  cube66->SetZLength(3);
  cube66->SetCenter(-10,0,0);
  vtkPolyDataMapper *cubeMapper66 = vtkPolyDataMapper::New();
  cubeMapper66->SetInput(cube66->GetOutput());
  vtkActor *cubeActor66 = vtkActor::New();
  cubeActor66->SetMapper(cubeMapper66);
  cubeActor66->GetProperty()->SetColor(0.95,0.2,0.55);


  
  ren->AddActor(cubeActor66);

  //green
  vtkCubeSource *cube77 = vtkCubeSource::New();
  cube77->SetXLength(3);
  cube77->SetYLength(3);
  cube77->SetZLength(3);
  cube77->SetCenter(0,10,0);
  vtkPolyDataMapper *cubeMapper77 = vtkPolyDataMapper::New();
  cubeMapper77->SetInput(cube77->GetOutput());
  vtkActor *cubeActor77 = vtkActor::New();
  cubeActor77->SetMapper(cubeMapper77);
  cubeActor77->GetProperty()->SetColor(0.0,0.8,0.3);


  ren->AddActor(cubeActor77);

    //Cube
  vtkCubeSource *cube2 = vtkCubeSource::New();
  cube2->SetCenter(5,5,5);
  cube2->SetXLength(3);
  cube2->SetYLength(3);
  cube2->SetZLength(3);
  //cube->SetBounds(0.0,0.5,0.0,0.3,0.0,0.2);
  vtkPolyDataMapper *cubeMapper2 = vtkPolyDataMapper::New();
  cubeMapper2->SetInput(cube2->GetOutput());
  vtkActor *cubeActor2 = vtkActor::New();
  cubeActor2->SetMapper(cubeMapper2);
  cubeActor2->GetProperty()->SetOpacity(0.5);
  cubeActor2->GetProperty()->SetColor(0.8,0.4,0.7);
  
  //assign our actor to the renderer
  
  //ren->AddActor(cubeActor);
  //ren->AddActor(cubeActor2);
  ren->SetBackground(0,0,0);
  
  ren->ResetCamera();
  
  renWindow->PolygonSmoothingOff();
  renWindow->PointSmoothingOff();
  renWindow->LineSmoothingOff();
  
  renWindow->SetSize(400,400);
  
  //draw the resulting scene
  renWindow->Render();
  
  //Begin mouse interaction
  iren->Start();
  
  //picker->Pick( 200, 200, 0, ren);
  
  exit(EXIT_SUCCESS);
}

void
additionalUsage()
{
  fprintf(stderr, "----- Additional Usage -----\n");
}
